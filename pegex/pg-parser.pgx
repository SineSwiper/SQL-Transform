#
# The target production for the whole parse.
#
stmtblock:
      stmtmulti 
;
# the thrashing around here is to discard "empty" statements...
stmtmulti:
      stmtmulti ';' stmt
    | stmt 
;
stmt:
      AlterEventTrigStmt
    | AlterDatabaseStmt
    | AlterDatabaseSetStmt
    | AlterDefaultPrivilegesStmt
    | AlterDomainStmt
    | AlterEnumStmt
    | AlterExtensionStmt
    | AlterExtensionContentsStmt
    | AlterFdwStmt
    | AlterForeignServerStmt
    | AlterForeignTableStmt
    | AlterFunctionStmt
    | AlterGroupStmt
    | AlterObjectSchemaStmt
    | AlterOwnerStmt
    | AlterSeqStmt
    | AlterTableStmt
    | AlterCompositeTypeStmt
    | AlterRoleSetStmt
    | AlterRoleStmt
    | AlterTSConfigurationStmt
    | AlterTSDictionaryStmt
    | AlterUserMappingStmt
    | AlterUserSetStmt
    | AlterUserStmt
    | AnalyzeStmt
    | CheckPointStmt
    | ClosePortalStmt
    | ClusterStmt
    | CommentStmt
    | ConstraintsSetStmt
    | CopyStmt
    | CreateAsStmt
    | CreateAssertStmt
    | CreateCastStmt
    | CreateConversionStmt
    | CreateDomainStmt
    | CreateExtensionStmt
    | CreateFdwStmt
    | CreateForeignServerStmt
    | CreateForeignTableStmt
    | CreateFunctionStmt
    | CreateGroupStmt
    | CreateOpClassStmt
    | CreateOpFamilyStmt
    | AlterOpFamilyStmt
    | CreatePLangStmt
    | CreateSchemaStmt
    | CreateSeqStmt
    | CreateStmt
    | CreateTableSpaceStmt
    | CreateTrigStmt
    | CreateEventTrigStmt
    | CreateRoleStmt
    | CreateUserStmt
    | CreateUserMappingStmt
    | CreatedbStmt
    | DeallocateStmt
    | DeclareCursorStmt
    | DefineStmt
    | DeleteStmt
    | DiscardStmt
    | DoStmt
    | DropAssertStmt
    | DropCastStmt
    | DropFdwStmt
    | DropForeignServerStmt
    | DropGroupStmt
    | DropOpClassStmt
    | DropOpFamilyStmt
    | DropOwnedStmt
    | DropPLangStmt
    | DropRuleStmt
    | DropStmt
    | DropTableSpaceStmt
    | DropTrigStmt
    | DropRoleStmt
    | DropUserStmt
    | DropUserMappingStmt
    | DropdbStmt
    | ExecuteStmt
    | ExplainStmt
    | FetchStmt
    | GrantStmt
    | GrantRoleStmt
    | IndexStmt
    | InsertStmt
    | ListenStmt
    | LoadStmt
    | LockStmt
    | NotifyStmt
    | PrepareStmt
    | ReassignOwnedStmt
    | ReindexStmt
    | RemoveAggrStmt
    | RemoveFuncStmt
    | RemoveOperStmt
    | RenameStmt
    | RevokeStmt
    | RevokeRoleStmt
    | RuleStmt
    | SecLabelStmt
    | SelectStmt
    | TransactionStmt
    | TruncateStmt
    | UnlistenStmt
    | UpdateStmt
    | VacuumStmt
    | VariableResetStmt
    | VariableSetStmt
    | VariableShowStmt
    | ViewStmt
    | # EMPTY
;
##############################################################################
#
# Create a new Postgres DBMS role
#
##############################################################################
CreateRoleStmt:
      CREATE ROLE RoleId opt_with OptRoleList 
;
opt_with:
      WITH
    | # EMPTY
;
#
# Options for CREATE ROLE and ALTER ROLE (also used by CREATE/ALTER USER
# for backwards compatibility).  Note: the only option required by SQL99
# is "WITH ADMIN name".
#
OptRoleList:
      OptRoleList CreateOptRoleElem
    | # EMPTY
;
AlterOptRoleList:
      AlterOptRoleList AlterOptRoleElem
    | # EMPTY
;
AlterOptRoleElem:
      PASSWORD Sconst
    | PASSWORD NULL
    | ENCRYPTED PASSWORD Sconst
    | UNENCRYPTED PASSWORD Sconst
    | INHERIT
    | CONNECTION LIMIT SignedIconst
    | VALID UNTIL Sconst # Supported but not documented for roles, for use by ALTER GROUP.
    | USER name_list
    | IDENT 
                # We handle identifiers that aren't parser keywords with
                # the following special-case codes, to avoid bloating the
                # size of the main parser.
;
CreateOptRoleElem:
      AlterOptRoleElem # The following are not supported by ALTER ROLE/USER/GROUP
    | SYSID Iconst
    | ADMIN name_list
    | ROLE name_list
    | IN ROLE name_list
    | IN GROUP name_list 
;
##############################################################################
#
# Create a new Postgres DBMS user (role with implied login ability)
#
##############################################################################
CreateUserStmt:
      CREATE USER RoleId opt_with OptRoleList 
;
##############################################################################
#
# Alter a postgresql DBMS role
#
##############################################################################
AlterRoleStmt:
      ALTER ROLE RoleId opt_with AlterOptRoleList 
;
opt_in_database:
      # EMPTY
    | IN DATABASE database_name 
;
AlterRoleSetStmt:
      ALTER ROLE RoleId opt_in_database SetResetClause 
;
##############################################################################
#
# Alter a postgresql DBMS user
#
##############################################################################
AlterUserStmt:
      ALTER USER RoleId opt_with AlterOptRoleList 
;
AlterUserSetStmt:
      ALTER USER RoleId SetResetClause 
;
##############################################################################
#
# Drop a postgresql DBMS role
#
# XXX Ideally this would have CASCADE/RESTRICT options, but since a role
# might own objects in multiple databases, there is presently no way to
# implement either cascading or restricting.  Caveat DBA.
##############################################################################
DropRoleStmt:
      DROP ROLE name_list
    | DROP ROLE IF EXISTS name_list 
;
##############################################################################
#
# Drop a postgresql DBMS user
#
# XXX Ideally this would have CASCADE/RESTRICT options, but since a user
# might own objects in multiple databases, there is presently no way to
# implement either cascading or restricting.  Caveat DBA.
##############################################################################
DropUserStmt:
      DROP USER name_list
    | DROP USER IF EXISTS name_list 
;
##############################################################################
#
# Create a postgresql group (role without login ability)
#
##############################################################################
CreateGroupStmt:
      CREATE GROUP RoleId opt_with OptRoleList 
;
##############################################################################
#
# Alter a postgresql group
#
##############################################################################
AlterGroupStmt:
      ALTER GROUP RoleId add_drop USER name_list 
;
add_drop:
      ADD
    | DROP 
;
##############################################################################
#
# Drop a postgresql group
#
# XXX see above notes about cascading DROP USER; groups have same problem.
##############################################################################
DropGroupStmt:
      DROP GROUP name_list
    | DROP GROUP IF EXISTS name_list 
;
##############################################################################
#
# Manipulate a schema
#
##############################################################################
CreateSchemaStmt:
      CREATE SCHEMA OptSchemaName AUTHORIZATION RoleId OptSchemaEltList
    | CREATE SCHEMA ColId OptSchemaEltList 
;
OptSchemaName:
      ColId
    | # EMPTY
;
OptSchemaEltList:
      OptSchemaEltList schema_stmt
    | # EMPTY
;
#
#   schema_stmt are the ones that can show up inside a CREATE SCHEMA
#   statement (in addition to by themselves).
#
schema_stmt:
      CreateStmt
    | IndexStmt
    | CreateSeqStmt
    | CreateTrigStmt
    | GrantStmt
    | ViewStmt 
;
##############################################################################
#
# Set PG internal variable
#     SET name TO 'var_value'
# Include SQL92 syntax (thomas 1997-10-22):
#     SET TIME ZONE 'var_value'
#
##############################################################################
VariableSetStmt:
      SET set_rest
    | SET LOCAL set_rest
    | SET SESSION set_rest 
;
set_rest:
      TRANSACTION transaction_mode_list
    | SESSION CHARACTERISTICS AS TRANSACTION transaction_mode_list
    | set_rest_more 
;
set_rest_more:
      # Generic SET syntaxes:var_name TO var_list
    | var_name '=' var_list
    | var_name TO DEFAULT
    | var_name '=' DEFAULT
    | var_name FROM CURRENT # Special syntaxes mandated by SQL standard:
    | TIME ZONE zone_value
    | CATALOG Sconst
    | SCHEMA Sconst
    | NAMES opt_encoding
    | ROLE ColId_or_Sconst
    | SESSION AUTHORIZATION ColId_or_Sconst
    | SESSION AUTHORIZATION DEFAULT
    | XML OPTION document_or_content # Special syntaxes invented by PostgreSQL:
    | TRANSACTION SNAPSHOT Sconst 
;
var_name:
      ColId
    | var_name '.' ColId 
;
var_list:
      var_value
    | var_list ',' var_value 
;
var_value:
      opt_boolean_or_string
    | NumericOnly 
;
iso_level:
      READ UNCOMMITTED
    | READ COMMITTED
    | REPEATABLE READ
    | SERIALIZABLE 
;
opt_boolean_or_string:
      TRUE
    | FALSE
    | ON 
         # OFF is also accepted as a boolean value, but is handled
         # by the ColId rule below. The action for booleans and strings
         # is the same, so we don't need to distinguish them here.
         
    | ColId_or_Sconst 
;
# Timezone values can be:
# - a string such as 'pst8pdt'
# - an identifier such as "pst8pdt"
# - an integer or floating point number
# - a time interval per SQL99
# ColId gives reduce/reduce errors against ConstInterval and LOCAL,
# so use IDENT (meaning we reject anything that is a key word).
#
zone_value:
      Sconst
    | IDENT
    | ConstInterval Sconst opt_interval
    | ConstInterval '(' Iconst ')' Sconst opt_interval
    | NumericOnly
    | DEFAULT
    | LOCAL 
;
opt_encoding:
      Sconst
    | DEFAULT
    | # EMPTY
;
ColId_or_Sconst:
      ColId
    | Sconst 
;
VariableResetStmt:
      RESET var_name
    | RESET TIME ZONE
    | RESET TRANSACTION ISOLATION LEVEL
    | RESET SESSION AUTHORIZATION
    | RESET ALL 
;
# SetResetClause allows SET or RESET without LOCAL
SetResetClause:
      SET set_rest
    | VariableResetStmt 
;
# SetResetClause allows SET or RESET without LOCAL
FunctionSetResetClause:
      SET set_rest_more
    | VariableResetStmt 
;
VariableShowStmt:
      SHOW var_name
    | SHOW TIME ZONE
    | SHOW TRANSACTION ISOLATION LEVEL
    | SHOW SESSION AUTHORIZATION
    | SHOW ALL 
;
ConstraintsSetStmt:
      SET CONSTRAINTS constraints_set_list constraints_set_mode 
;
constraints_set_list:
      ALL
    | qualified_name_list 
;
constraints_set_mode:
      DEFERRED
    | IMMEDIATE 
;
#
# Checkpoint statement
#
CheckPointStmt:
      CHECKPOINT 
;
##############################################################################
#
# DISCARD { ALL | TEMP | PLANS }
#
##############################################################################
DiscardStmt:
      DISCARD ALL
    | DISCARD TEMP
    | DISCARD TEMPORARY
    | DISCARD PLANS 
;
##############################################################################
#
#   ALTER [ TABLE | INDEX | SEQUENCE | VIEW ] variations
#
# Note: we accept all subcommands for each of the four variants, and sort
# out what's really legal at execution time.
##############################################################################
AlterTableStmt:
      ALTER TABLE relation_expr alter_table_cmds
    | ALTER TABLE IF EXISTS relation_expr alter_table_cmds
    | ALTER INDEX qualified_name alter_table_cmds
    | ALTER INDEX IF EXISTS qualified_name alter_table_cmds
    | ALTER SEQUENCE qualified_name alter_table_cmds
    | ALTER SEQUENCE IF EXISTS qualified_name alter_table_cmds
    | ALTER VIEW qualified_name alter_table_cmds
    | ALTER VIEW IF EXISTS qualified_name alter_table_cmds 
;
alter_table_cmds:
      alter_table_cmd
    | alter_table_cmds ',' alter_table_cmd 
;
alter_table_cmd:
      # ALTER TABLE <name> ADD <coldef>ADD columnDef # ALTER TABLE <name> ADD COLUMN <coldef>
    | ADD COLUMN columnDef # ALTER TABLE <name> ALTER [COLUMN] <colname> {SET DEFAULT <expr>|DROP DEFAULT}
    | ALTER opt_column ColId alter_column_default # ALTER TABLE <name> ALTER [COLUMN] <colname> DROP NOT NULL
    | ALTER opt_column ColId DROP NOT NULL # ALTER TABLE <name> ALTER [COLUMN] <colname> SET NOT NULL
    | ALTER opt_column ColId SET NOT NULL # ALTER TABLE <name> ALTER [COLUMN] <colname> SET STATISTICS <SignedIconst>
    | ALTER opt_column ColId SET STATISTICS SignedIconst # ALTER TABLE <name> ALTER [COLUMN] <colname> SET ( column_parameter = value [, ... ] )
    | ALTER opt_column ColId SET reloptions # ALTER TABLE <name> ALTER [COLUMN] <colname> SET ( column_parameter = value [, ... ] )
    | ALTER opt_column ColId RESET reloptions # ALTER TABLE <name> ALTER [COLUMN] <colname> SET STORAGE <storagemode>
    | ALTER opt_column ColId SET STORAGE ColId # ALTER TABLE <name> DROP [COLUMN] IF EXISTS <colname> [RESTRICT|CASCADE]
    | DROP opt_column IF EXISTS ColId opt_drop_behavior # ALTER TABLE <name> DROP [COLUMN] <colname> [RESTRICT|CASCADE]
    | DROP opt_column ColId opt_drop_behavior 
          # ALTER TABLE <name> ALTER [COLUMN] <colname> [SET DATA] TYPE <typename>
          #      [ USING <expression> ]
         
    | ALTER opt_column ColId opt_set_data TYPE Typename opt_collate_clause alter_using # ALTER FOREIGN TABLE <name> ALTER [COLUMN] <colname> OPTIONS
    | ALTER opt_column ColId alter_generic_options # ALTER TABLE <name> ADD CONSTRAINT ...
    | ADD TableConstraint # ALTER TABLE <name> VALIDATE CONSTRAINT ...
    | VALIDATE CONSTRAINT name # ALTER TABLE <name> DROP CONSTRAINT IF EXISTS <name> [RESTRICT|CASCADE]
    | DROP CONSTRAINT IF EXISTS name opt_drop_behavior # ALTER TABLE <name> DROP CONSTRAINT <name> [RESTRICT|CASCADE]
    | DROP CONSTRAINT name opt_drop_behavior # ALTER TABLE <name> SET WITH OIDS 
    | SET WITH OIDS # ALTER TABLE <name> SET WITHOUT OIDS 
    | SET WITHOUT OIDS # ALTER TABLE <name> CLUSTER ON <indexname>
    | CLUSTER ON name # ALTER TABLE <name> SET WITHOUT CLUSTER
    | SET WITHOUT CLUSTER # ALTER TABLE <name> ENABLE TRIGGER <trig>
    | ENABLE TRIGGER name # ALTER TABLE <name> ENABLE ALWAYS TRIGGER <trig>
    | ENABLE ALWAYS TRIGGER name # ALTER TABLE <name> ENABLE REPLICA TRIGGER <trig>
    | ENABLE REPLICA TRIGGER name # ALTER TABLE <name> ENABLE TRIGGER ALL
    | ENABLE TRIGGER ALL # ALTER TABLE <name> ENABLE TRIGGER USER
    | ENABLE TRIGGER USER # ALTER TABLE <name> DISABLE TRIGGER <trig>
    | DISABLE TRIGGER name # ALTER TABLE <name> DISABLE TRIGGER ALL
    | DISABLE TRIGGER ALL # ALTER TABLE <name> DISABLE TRIGGER USER
    | DISABLE TRIGGER USER # ALTER TABLE <name> ENABLE RULE <rule>
    | ENABLE RULE name # ALTER TABLE <name> ENABLE ALWAYS RULE <rule>
    | ENABLE ALWAYS RULE name # ALTER TABLE <name> ENABLE REPLICA RULE <rule>
    | ENABLE REPLICA RULE name # ALTER TABLE <name> DISABLE RULE <rule>
    | DISABLE RULE name # ALTER TABLE <name> INHERIT <parent>
    | INHERIT qualified_name # ALTER TABLE <name> NO INHERIT <parent>
    | NO INHERIT qualified_name # ALTER TABLE <name> OF <type_name>
    | OF any_name # ALTER TABLE <name> NOT OF
    | NOT OF # ALTER TABLE <name> OWNER TO RoleId
    | OWNER TO RoleId # ALTER TABLE <name> SET TABLESPACE <tablespacename>
    | SET TABLESPACE name # ALTER TABLE <name> SET (...)
    | SET reloptions # ALTER TABLE <name> RESET (...)
    | RESET reloptions
    | alter_generic_options 
;
alter_column_default:
      SET DEFAULT a_expr
    | DROP DEFAULT 
;
opt_drop_behavior:
      CASCADE
    | RESTRICT
    | # EMPTY # default
;
opt_collate_clause:
      COLLATE any_name
    | # EMPTY
;
alter_using:
      USING a_expr
    | # EMPTY
;
reloptions:
      '(' reloption_list ')' 
;
opt_reloptions:
      WITH reloptions
    | # EMPTY
;
reloption_list:
      reloption_elem
    | reloption_list ',' reloption_elem 
;
# This should match def_elem and also allow qualified names
reloption_elem:
      ColLabel '=' def_arg
    | ColLabel
    | ColLabel '.' ColLabel '=' def_arg
    | ColLabel '.' ColLabel 
;
##############################################################################
#
#   ALTER TYPE
#
# really variants of the ALTER TABLE subcommands with different spellings
##############################################################################
AlterCompositeTypeStmt:
      ALTER TYPE any_name alter_type_cmds 
;
alter_type_cmds:
      alter_type_cmd
    | alter_type_cmds ',' alter_type_cmd 
;
alter_type_cmd:
      # ALTER TYPE <name> ADD ATTRIBUTE <coldef> [RESTRICT|CASCADE]ADD ATTRIBUTE TableFuncElement opt_drop_behavior # ALTER TYPE <name> DROP ATTRIBUTE IF EXISTS <attname> [RESTRICT|CASCADE]
    | DROP ATTRIBUTE IF EXISTS ColId opt_drop_behavior # ALTER TYPE <name> DROP ATTRIBUTE <attname> [RESTRICT|CASCADE]
    | DROP ATTRIBUTE ColId opt_drop_behavior # ALTER TYPE <name> ALTER ATTRIBUTE <attname> [SET DATA] TYPE <typename> [RESTRICT|CASCADE]
    | ALTER ATTRIBUTE ColId opt_set_data TYPE Typename opt_collate_clause opt_drop_behavior 
;
##############################################################################
#
#      QUERY :
#            close <portalname>
#
##############################################################################
ClosePortalStmt:
      CLOSE cursor_name
    | CLOSE ALL 
;
##############################################################################
#
#      QUERY :
#            COPY relname [(columnList)] FROM/TO file [WITH] [(options)]
#            COPY ( SELECT ... ) TO file [WITH] [(options)]
#
#            In the preferred syntax the options are comma-separated
#            and use generic identifiers instead of keywords.  The pre-9.0
#            syntax had a hard-wired, space-separated set of options.
#
#            Really old syntax, from versions 7.2 and prior:
#            COPY [ BINARY ] table [ WITH OIDS ] FROM/TO file
#               [ [ USING ] DELIMITERS 'delimiter' ] ]
#               [ WITH NULL AS 'null string' ]
#            This option placement is not supported with COPY (SELECT...).
#
##############################################################################
CopyStmt:
      COPY opt_binary qualified_name opt_column_list opt_oids copy_from copy_file_name copy_delimiter opt_with copy_options
    | COPY select_with_parens TO copy_file_name opt_with copy_options 
;
copy_from:
      FROM
    | TO 
;
#
# copy_file_name NULL indicates stdio is used. Whether stdin or stdout is
# used depends on the direction. (It really doesn't make sense to copy from
# stdout. We silently correct the "typo".)       - AY 9/94
#
copy_file_name:
      Sconst
    | STDIN
    | STDOUT 
;
copy_options:
      copy_opt_list
    | '(' copy_generic_opt_list ')' 
;
# old COPY option syntax
copy_opt_list:
      copy_opt_list copy_opt_item
    | # EMPTY
;
copy_opt_item:
      BINARY
    | OIDS
    | DELIMITER opt_as Sconst
    | NULL opt_as Sconst
    | CSV
    | HEADER
    | QUOTE opt_as Sconst
    | ESCAPE opt_as Sconst
    | FORCE QUOTE columnList
    | FORCE QUOTE '*'
    | FORCE NOT NULL columnList
    | ENCODING Sconst 
;
# The following exist for backward compatibility with very old versions
opt_binary:
      BINARY
    | # EMPTY
;
opt_oids:
      WITH OIDS
    | # EMPTY
;
copy_delimiter:
      opt_using DELIMITERS Sconst
    | # EMPTY
;
opt_using:
      USING
    | # EMPTY
;
# new COPY option syntax
copy_generic_opt_list:
      copy_generic_opt_elem
    | copy_generic_opt_list ',' copy_generic_opt_elem 
;
copy_generic_opt_elem:
      ColLabel copy_generic_opt_arg 
;
copy_generic_opt_arg:
      opt_boolean_or_string
    | NumericOnly
    | '*'
    | '(' copy_generic_opt_arg_list ')'
    | # EMPTY
;
copy_generic_opt_arg_list:
      copy_generic_opt_arg_list_item
    | copy_generic_opt_arg_list ',' copy_generic_opt_arg_list_item 
;
# beware of emitting non-string list elements here; see commands/define.c
copy_generic_opt_arg_list_item:
      opt_boolean_or_string 
;
##############################################################################
#
#      QUERY :
#            CREATE TABLE relname
#
##############################################################################
CreateStmt:
      CREATE OptTemp TABLE qualified_name '(' OptTableElementList ')' OptInherit OptWith OnCommitOption OptTableSpace
    | CREATE OptTemp TABLE IF NOT EXISTS qualified_name '(' OptTableElementList ')' OptInherit OptWith OnCommitOption OptTableSpace
    | CREATE OptTemp TABLE qualified_name OF any_name OptTypedTableElementList OptWith OnCommitOption OptTableSpace
    | CREATE OptTemp TABLE IF NOT EXISTS qualified_name OF any_name OptTypedTableElementList OptWith OnCommitOption OptTableSpace 
;
#
# Redundancy here is needed to avoid shift/reduce conflicts,
# since TEMP is not a reserved word.  See also OptTempTableName.
#
# NOTE: we accept both GLOBAL and LOCAL options; since we have no modules
# the LOCAL keyword is really meaningless.
#
OptTemp:
      TEMPORARY
    | TEMP
    | LOCAL TEMPORARY
    | LOCAL TEMP
    | GLOBAL TEMPORARY
    | GLOBAL TEMP
    | UNLOGGED
    | # EMPTY
;
OptTableElementList:
      TableElementList
    | # EMPTY
;
OptTypedTableElementList:
      '(' TypedTableElementList ')'
    | # EMPTY
;
TableElementList:
      TableElement
    | TableElementList ',' TableElement 
;
TypedTableElementList:
      TypedTableElement
    | TypedTableElementList ',' TypedTableElement 
;
TableElement:
      columnDef
    | TableLikeClause
    | TableConstraint 
;
TypedTableElement:
      columnOptions
    | TableConstraint 
;
columnDef:
      ColId Typename ColQualList 
;
columnOptions:
      ColId WITH OPTIONS ColQualList 
;
ColQualList:
      ColQualList ColConstraint
    | # EMPTY
;
ColConstraint:
      CONSTRAINT name ColConstraintElem
    | ColConstraintElem
    | ConstraintAttr 
          # Note: the CollateClause is momentarily included in
          # the list built by ColQualList, but we split it out
          # again in SplitColQualList.
         
    | COLLATE any_name 
;
# DEFAULT NULL is already the default for Postgres.
# But define it here and carry it forward into the system
# to make it explicit.
# - thomas 1998-09-13
#
# WITH NULL and NULL are not SQL92-standard syntax elements,
# so leave them out. Use DEFAULT NULL to explicitly indicate
# that a column may have that value. WITH NULL leads to
# shift/reduce conflicts with WITH TIME ZONE anyway.
# - thomas 1999-01-08
#
# DEFAULT expression must be b_expr not a_expr to prevent shift/reduce
# conflict on NOT (since NOT might start a subsequent NOT NULL constraint,
# or be part of a_expr NOT LIKE or similar constructs).
#
ColConstraintElem:
      NOT NULL
    | NULL
    | UNIQUE opt_definition OptConsTableSpace
    | PRIMARY KEY opt_definition OptConsTableSpace
    | CHECK '(' a_expr ')'
    | DEFAULT b_expr
    | REFERENCES qualified_name opt_column_list key_match key_actions 
;
#
# ConstraintAttr represents constraint attributes, which we parse as if
# they were independent constraint clauses, in order to avoid shift/reduce
# conflicts (since NOT might start either an independent NOT NULL clause
# or an attribute).  parse_utilcmd.c is responsible for attaching the
# attribute information to the preceding "real" constraint node, and for
# complaining if attribute clauses appear in the wrong place or wrong
# combinations.
#
# See also ConstraintAttributeSpec, which can be used in places where
# there is no parsing conflict.  (Note: currently, NOT VALID is an allowed
# clause in ConstraintAttributeSpec, but not here.  Someday we might need
# to allow it here too, but for the moment it doesn't seem useful in the
# statements that use ConstraintAttr.)
#
ConstraintAttr:
      DEFERRABLE
    | NOT DEFERRABLE
    | INITIALLY DEFERRED
    | INITIALLY IMMEDIATE 
;
#
# SQL99 supports wholesale borrowing of a table definition via the LIKE clause.
# This seems to be a poor man's inheritance capability, with the resulting
# tables completely decoupled except for the original commonality in definitions.
#
# This is very similar to CREATE TABLE AS except for the INCLUDING DEFAULTS extension
# which is a part of SQL:2003.
#
TableLikeClause:
      LIKE qualified_name TableLikeOptionList 
;
TableLikeOptionList:
      TableLikeOptionList INCLUDING TableLikeOption
    | TableLikeOptionList EXCLUDING TableLikeOption
    | # EMPTY
;
TableLikeOption:
      DEFAULTS
    | CONSTRAINTS
    | INDEXES
    | STORAGE
    | COMMENTS
    | ALL 
;
# ConstraintElem specifies constraint syntax which is not embedded into
#   a column definition. ColConstraintElem specifies the embedded form.
# - thomas 1997-12-03
#
TableConstraint:
      CONSTRAINT name ConstraintElem
    | ConstraintElem 
;
ConstraintElem:
      CHECK '(' a_expr ')' ConstraintAttributeSpec
    | UNIQUE '(' columnList ')' opt_definition OptConsTableSpace ConstraintAttributeSpec
    | UNIQUE ExistingIndex ConstraintAttributeSpec
    | PRIMARY KEY '(' columnList ')' opt_definition OptConsTableSpace ConstraintAttributeSpec
    | PRIMARY KEY ExistingIndex ConstraintAttributeSpec
    | EXCLUDE access_method_clause '(' ExclusionConstraintList ')' opt_definition OptConsTableSpace ExclusionWhereClause ConstraintAttributeSpec
    | FOREIGN KEY '(' columnList ')' REFERENCES qualified_name opt_column_list key_match key_actions ConstraintAttributeSpec 
;
opt_column_list:
      '(' columnList ')'
    | # EMPTY
;
columnList:
      columnElem
    | columnList ',' columnElem 
;
columnElem:
      ColId 
;
key_match:
      MATCH FULL
    | MATCH PARTIAL
    | MATCH SIMPLE
    | # EMPTY
;
ExclusionConstraintList:
      ExclusionConstraintElem
    | ExclusionConstraintList ',' ExclusionConstraintElem 
;
ExclusionConstraintElem:
      index_elem WITH any_operator # allow OPERATOR() decoration for the benefit of ruleutils.c
    | index_elem WITH OPERATOR '(' any_operator ')' 
;
ExclusionWhereClause:
      WHERE '(' a_expr ')'
    | # EMPTY
;
#
# We combine the update and delete actions into one value temporarily
# for simplicity of parsing, and then break them down again in the
# calling production.  update is in the left 8 bits, delete in the right.
# Note that NOACTION is the default.
#
key_actions:
      key_update
    | key_delete
    | key_update key_delete
    | key_delete key_update
    | # EMPTY
;
key_update:
      ON UPDATE key_action 
;
key_delete:
      ON DELETE key_action 
;
key_action:
      NO ACTION
    | RESTRICT
    | CASCADE
    | SET NULL
    | SET DEFAULT 
;
OptInherit:
      INHERITS '(' qualified_name_list ')'
    | # EMPTY
;
# WITH (options) is preferred, WITH OIDS and WITHOUT OIDS are legacy forms
OptWith:
      WITH reloptions
    | WITH OIDS
    | WITHOUT OIDS
    | # EMPTY
;
OnCommitOption:
      ON COMMIT DROP
    | ON COMMIT DELETE ROWS
    | ON COMMIT PRESERVE ROWS
    | # EMPTY
;
OptTableSpace:
      TABLESPACE name
    | # EMPTY
;
OptConsTableSpace:
      USING INDEX TABLESPACE name
    | # EMPTY
;
ExistingIndex:
      USING INDEX index_name 
;
#
# Note: CREATE TABLE ... AS SELECT ... is just another spelling for
# SELECT ... INTO.
#
CreateAsStmt:
      CREATE OptTemp TABLE create_as_target AS SelectStmt opt_with_data
                # When the SelectStmt is a set-operation tree, we must
                # stuff the INTO information into the leftmost component
                # Select, because that's where analyze.c will expect
                # to find it.   Similarly, the output column names must
                # be attached to that Select's target list.
               
;
create_as_target:
      qualified_name OptCreateAs OptWith OnCommitOption OptTableSpace 
;
OptCreateAs:
      '(' CreateAsList ')'
    | # EMPTY
;
CreateAsList:
      CreateAsElement
    | CreateAsList ',' CreateAsElement 
;
CreateAsElement:
      ColId 
;
opt_with_data:
      WITH DATA
    | WITH NO DATA
    | # EMPTY
;
##############################################################################
#
#      QUERY :
#            CREATE SEQUENCE seqname
#            ALTER SEQUENCE seqname
#
##############################################################################
CreateSeqStmt:
      CREATE OptTemp SEQUENCE qualified_name OptSeqOptList 
;
AlterSeqStmt:
      ALTER SEQUENCE qualified_name SeqOptList 
;
OptSeqOptList:
      SeqOptList
    | # EMPTY
;
SeqOptList:
      SeqOptElem
    | SeqOptList SeqOptElem 
;
SeqOptElem:
      CACHE NumericOnly
    | CYCLE
    | NO CYCLE
    | INCREMENT opt_by NumericOnly
    | MAXVALUE NumericOnly
    | MINVALUE NumericOnly
    | NO MAXVALUE
    | NO MINVALUE
    | OWNED BY any_name
    | START opt_with NumericOnly
    | RESTART
    | RESTART opt_with NumericOnly 
;
opt_by:
      BY
    | # empty
;
NumericOnly:
      FCONST
    | '-' FCONST
    | SignedIconst 
;
NumericOnly_list:
      NumericOnly
    | NumericOnly_list ',' NumericOnly 
;
##############################################################################
#
#      QUERIES :
#            CREATE [OR REPLACE] [TRUSTED] [PROCEDURAL] LANGUAGE ...
#            DROP [PROCEDURAL] LANGUAGE ...
#
##############################################################################
CreatePLangStmt:
      CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst
    | CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst HANDLER handler_name opt_inline_handler opt_validator 
;
opt_trusted:
      TRUSTED
    | # EMPTY
;
# This ought to be just func_name, but that causes reduce/reduce conflicts
# (CREATE LANGUAGE is the only place where func_name isn't followed by '(').
# Work around by using simple names, instead.
#
handler_name:
      name
    | name attrs 
;
opt_inline_handler:
      INLINE handler_name
    | # EMPTY
;
validator_clause:
      VALIDATOR handler_name
    | NO VALIDATOR 
;
opt_validator:
      validator_clause
    | # EMPTY
;
DropPLangStmt:
      DROP opt_procedural LANGUAGE ColId_or_Sconst opt_drop_behavior
    | DROP opt_procedural LANGUAGE IF EXISTS ColId_or_Sconst opt_drop_behavior 
;
opt_procedural:
      PROCEDURAL
    | # EMPTY
;
##############################################################################
#
#       QUERY:
#             CREATE TABLESPACE tablespace LOCATION '/path/to/tablespace/''
#
##############################################################################
CreateTableSpaceStmt:
      CREATE TABLESPACE name OptTableSpaceOwner LOCATION Sconst 
;
OptTableSpaceOwner:
      OWNER name
    | # EMPTY
;
##############################################################################
#
#       QUERY :
#            DROP TABLESPACE <tablespace>
#
#      No need for drop behaviour as we cannot implement dependencies for
#      objects in other databases; we can only support RESTRICT.
#
##############################################################################
DropTableSpaceStmt:
      DROP TABLESPACE name
    | DROP TABLESPACE IF EXISTS name 
;
##############################################################################
#
#       QUERY:
#             CREATE EXTENSION extension
#             [ WITH ] [ SCHEMA schema ] [ VERSION version ] [ FROM oldversion ]
#
##############################################################################
CreateExtensionStmt:
      CREATE EXTENSION name opt_with create_extension_opt_list
    | CREATE EXTENSION IF NOT EXISTS name opt_with create_extension_opt_list 
;
create_extension_opt_list:
      create_extension_opt_list create_extension_opt_item
    | # EMPTY
;
create_extension_opt_item:
      SCHEMA name
    | VERSION ColId_or_Sconst
    | FROM ColId_or_Sconst 
;
##############################################################################
#
# ALTER EXTENSION name UPDATE [ TO version ]
#
##############################################################################
AlterExtensionStmt:
      ALTER EXTENSION name UPDATE alter_extension_opt_list 
;
alter_extension_opt_list:
      alter_extension_opt_list alter_extension_opt_item
    | # EMPTY
;
alter_extension_opt_item:
      TO ColId_or_Sconst 
;
##############################################################################
#
# ALTER EXTENSION name ADD/DROP object-identifier
#
##############################################################################
AlterExtensionContentsStmt:
      ALTER EXTENSION name add_drop AGGREGATE func_name aggr_args
    | ALTER EXTENSION name add_drop CAST '(' Typename AS Typename ')'
    | ALTER EXTENSION name add_drop COLLATION any_name
    | ALTER EXTENSION name add_drop CONVERSION any_name
    | ALTER EXTENSION name add_drop DOMAIN any_name
    | ALTER EXTENSION name add_drop FUNCTION function_with_argtypes
    | ALTER EXTENSION name add_drop opt_procedural LANGUAGE name
    | ALTER EXTENSION name add_drop OPERATOR any_operator oper_argtypes
    | ALTER EXTENSION name add_drop OPERATOR CLASS any_name USING access_method
    | ALTER EXTENSION name add_drop OPERATOR FAMILY any_name USING access_method
    | ALTER EXTENSION name add_drop SCHEMA name
    | ALTER EXTENSION name add_drop TABLE any_name
    | ALTER EXTENSION name add_drop TEXT SEARCH PARSER any_name
    | ALTER EXTENSION name add_drop TEXT SEARCH DICTIONARY any_name
    | ALTER EXTENSION name add_drop TEXT SEARCH TEMPLATE any_name
    | ALTER EXTENSION name add_drop TEXT SEARCH CONFIGURATION any_name
    | ALTER EXTENSION name add_drop SEQUENCE any_name
    | ALTER EXTENSION name add_drop VIEW any_name
    | ALTER EXTENSION name add_drop FOREIGN TABLE any_name
    | ALTER EXTENSION name add_drop FOREIGN DATA WRAPPER name
    | ALTER EXTENSION name add_drop SERVER name
    | ALTER EXTENSION name add_drop TYPE any_name 
;
##############################################################################
#
#       QUERY:
#             CREATE FOREIGN DATA WRAPPER name options
#
##############################################################################
CreateFdwStmt:
      CREATE FOREIGN DATA WRAPPER name opt_fdw_options create_generic_options 
;
fdw_option:
      HANDLER handler_name
    | NO HANDLER
    | VALIDATOR handler_name
    | NO VALIDATOR 
;
fdw_options:
      fdw_option
    | fdw_options fdw_option 
;
opt_fdw_options:
      fdw_options
    | # EMPTY
;
##############################################################################
#
#       QUERY :
#            DROP FOREIGN DATA WRAPPER name
#
##############################################################################
DropFdwStmt:
      DROP FOREIGN DATA WRAPPER name opt_drop_behavior
    | DROP FOREIGN DATA WRAPPER IF EXISTS name opt_drop_behavior 
;
##############################################################################
#
#       QUERY :
#            ALTER FOREIGN DATA WRAPPER name options
#
##############################################################################
AlterFdwStmt:
      ALTER FOREIGN DATA WRAPPER name opt_fdw_options alter_generic_options
    | ALTER FOREIGN DATA WRAPPER name fdw_options 
;
# Options definition for CREATE FDW, SERVER and USER MAPPING
create_generic_options:
      OPTIONS '(' generic_option_list ')'
    | # EMPTY
;
generic_option_list:
      generic_option_elem
    | generic_option_list ',' generic_option_elem 
;
# Options definition for ALTER FDW, SERVER and USER MAPPING
alter_generic_options:
      OPTIONS '(' alter_generic_option_list ')' 
;
alter_generic_option_list:
      alter_generic_option_elem
    | alter_generic_option_list ',' alter_generic_option_elem 
;
alter_generic_option_elem:
      generic_option_elem
    | SET generic_option_elem
    | ADD generic_option_elem
    | DROP generic_option_name 
;
generic_option_elem:
      generic_option_name generic_option_arg 
;
generic_option_name:
      ColLabel 
;
# We could use def_arg here, but the spec only requires string literals
generic_option_arg:
      Sconst 
;
##############################################################################
#
#       QUERY:
#             CREATE SERVER name [TYPE] [VERSION] [OPTIONS]
#
##############################################################################
CreateForeignServerStmt:
      CREATE SERVER name opt_type opt_foreign_server_version FOREIGN DATA WRAPPER name create_generic_options 
;
opt_type:
      TYPE Sconst
    | # EMPTY
;
foreign_server_version:
      VERSION Sconst
    | VERSION NULL 
;
opt_foreign_server_version:
      foreign_server_version
    | # EMPTY
;
##############################################################################
#
#       QUERY :
#            DROP SERVER name
#
##############################################################################
DropForeignServerStmt:
      DROP SERVER name opt_drop_behavior
    | DROP SERVER IF EXISTS name opt_drop_behavior 
;
##############################################################################
#
#       QUERY :
#            ALTER SERVER name [VERSION] [OPTIONS]
#
##############################################################################
AlterForeignServerStmt:
      ALTER SERVER name foreign_server_version alter_generic_options
    | ALTER SERVER name foreign_server_version
    | ALTER SERVER name alter_generic_options 
;
##############################################################################
#
#       QUERY:
#             CREATE FOREIGN TABLE relname (...) SERVER name (...)
#
##############################################################################
CreateForeignTableStmt:
      CREATE FOREIGN TABLE qualified_name OptForeignTableElementList SERVER name create_generic_options
    | CREATE FOREIGN TABLE IF NOT EXISTS qualified_name OptForeignTableElementList SERVER name create_generic_options 
;
OptForeignTableElementList:
      '(' ForeignTableElementList ')'
    | '(' ')' 
;
ForeignTableElementList:
      ForeignTableElement
    | ForeignTableElementList ',' ForeignTableElement 
;
ForeignTableElement:
      columnDef 
;
##############################################################################
#
#       QUERY:
#             ALTER FOREIGN TABLE relname [...]
#
##############################################################################
AlterForeignTableStmt:
      ALTER FOREIGN TABLE relation_expr alter_table_cmds 
;
##############################################################################
#
#       QUERY:
#             CREATE USER MAPPING FOR auth_ident SERVER name [OPTIONS]
#
##############################################################################
CreateUserMappingStmt:
      CREATE USER MAPPING FOR auth_ident SERVER name create_generic_options 
;
# User mapping authorization identifier
auth_ident:
      CURRENT_USER
    | USER
    | RoleId 
;
##############################################################################
#
#       QUERY :
#            DROP USER MAPPING FOR auth_ident SERVER name
#
##############################################################################
DropUserMappingStmt:
      DROP USER MAPPING FOR auth_ident SERVER name
    | DROP USER MAPPING IF EXISTS FOR auth_ident SERVER name 
;
##############################################################################
#
#       QUERY :
#            ALTER USER MAPPING FOR auth_ident SERVER name OPTIONS
#
##############################################################################
AlterUserMappingStmt:
      ALTER USER MAPPING FOR auth_ident SERVER name alter_generic_options 
;
##############################################################################
#
#      QUERIES :
#            CREATE TRIGGER ...
#            DROP TRIGGER ...
#
##############################################################################
CreateTrigStmt:
      CREATE TRIGGER name TriggerActionTime TriggerEvents ON qualified_name TriggerForSpec TriggerWhen EXECUTE PROCEDURE func_name '(' TriggerFuncArgs ')'
    | CREATE CONSTRAINT TRIGGER name AFTER TriggerEvents ON qualified_name OptConstrFromTable ConstraintAttributeSpec FOR EACH ROW TriggerWhen EXECUTE PROCEDURE func_name '(' TriggerFuncArgs ')' 
;
TriggerActionTime:
      BEFORE
    | AFTER
    | INSTEAD OF 
;
TriggerEvents:
      TriggerOneEvent
    | TriggerEvents OR TriggerOneEvent 
;
TriggerOneEvent:
      INSERT
    | DELETE
    | UPDATE
    | UPDATE OF columnList
    | TRUNCATE 
;
TriggerForSpec:
      FOR TriggerForOptEach TriggerForType
    | # EMPTY
            # If ROW/STATEMENT not specified, default to
            # STATEMENT, per SQL
;
TriggerForOptEach:
      EACH
    | # EMPTY
;
TriggerForType:
      ROW
    | STATEMENT 
;
TriggerWhen:
      WHEN '(' a_expr ')'
    | # EMPTY
;
TriggerFuncArgs:
      TriggerFuncArg
    | TriggerFuncArgs ',' TriggerFuncArg
    | # EMPTY
;
TriggerFuncArg:
      Iconst
    | FCONST
    | Sconst
    | ColLabel 
;
OptConstrFromTable:
      FROM qualified_name
    | # EMPTY
;
ConstraintAttributeSpec:
      # EMPTY
    | ConstraintAttributeSpec ConstraintAttributeElem 
;
ConstraintAttributeElem:
      NOT DEFERRABLE
    | DEFERRABLE
    | INITIALLY IMMEDIATE
    | INITIALLY DEFERRED
    | NOT VALID
    | NO INHERIT 
;
DropTrigStmt:
      DROP TRIGGER name ON qualified_name opt_drop_behavior
    | DROP TRIGGER IF EXISTS name ON qualified_name opt_drop_behavior 
;
##############################################################################
#
#      QUERIES :
#            CREATE ASSERTION ...
#            DROP ASSERTION ...
#
##############################################################################
CreateAssertStmt:
      CREATE ASSERTION name CHECK '(' a_expr ')' ConstraintAttributeSpec 
;
DropAssertStmt:
      DROP ASSERTION name opt_drop_behavior 
;
##############################################################################
#
#      QUERY :
#            define (aggregate,operator,type)
#
##############################################################################
DefineStmt:
      CREATE AGGREGATE func_name aggr_args definition
    | CREATE AGGREGATE func_name old_aggr_definition # old-style (pre-8.2) syntax for CREATE AGGREGATE
    | CREATE OPERATOR any_operator definition
    | CREATE TYPE any_name definition
    | CREATE TYPE any_name # Shell type (identified by lack of definition)
    | CREATE TYPE any_name AS '(' OptTableFuncElementList ')'
    | CREATE TYPE any_name AS ENUM '(' opt_enum_val_list ')'
    | CREATE TEXT SEARCH PARSER any_name definition
    | CREATE TEXT SEARCH DICTIONARY any_name definition
    | CREATE TEXT SEARCH TEMPLATE any_name definition
    | CREATE TEXT SEARCH CONFIGURATION any_name definition
    | CREATE COLLATION any_name definition
    | CREATE COLLATION any_name FROM any_name 
;
definition:
      '(' def_list ')' 
;
def_list:
      def_elem
    | def_list ',' def_elem 
;
def_elem:
      ColLabel '=' def_arg
    | ColLabel 
;
# Note: any simple identifier will be returned as a type name!
def_arg:
      func_type
    | reserved_keyword
    | qual_all_Op
    | NumericOnly
    | Sconst 
;
aggr_args:
      '(' type_list ')'
    | '(' '*' ')' 
;
old_aggr_definition:
      '(' old_aggr_list ')' 
;
old_aggr_list:
      old_aggr_elem
    | old_aggr_list ',' old_aggr_elem 
;
#
# Must use IDENT here to avoid reduce/reduce conflicts; fortunately none of
# the item names needed in old aggregate definitions are likely to become
# SQL keywords.
#
old_aggr_elem:
      IDENT '=' def_arg 
;
opt_enum_val_list:
      enum_val_list
    | # EMPTY
;
enum_val_list:
      Sconst
    | enum_val_list ',' Sconst 
;
##############################################################################
#
#   ALTER TYPE enumtype ADD ...
#
##############################################################################
AlterEnumStmt:
      ALTER TYPE any_name ADD VALUE Sconst
    | ALTER TYPE any_name ADD VALUE Sconst BEFORE Sconst
    | ALTER TYPE any_name ADD VALUE Sconst AFTER Sconst 
;
##############################################################################
#
#      QUERIES :
#            CREATE OPERATOR CLASS ...
#            CREATE OPERATOR FAMILY ...
#            ALTER OPERATOR FAMILY ...
#            DROP OPERATOR CLASS ...
#            DROP OPERATOR FAMILY ...
#
##############################################################################
CreateOpClassStmt:
      CREATE OPERATOR CLASS any_name opt_default FOR TYPE Typename USING access_method opt_opfamily AS opclass_item_list 
;
opclass_item_list:
      opclass_item
    | opclass_item_list ',' opclass_item 
;
opclass_item:
      OPERATOR Iconst any_operator opclass_purpose opt_recheck
    | OPERATOR Iconst any_operator oper_argtypes opclass_purpose opt_recheck
    | FUNCTION Iconst func_name func_args
    | FUNCTION Iconst '(' type_list ')' func_name func_args
    | STORAGE Typename 
;
opt_default:
      DEFAULT
    | # EMPTY
;
opt_opfamily:
      FAMILY any_name
    | # EMPTY
;
opclass_purpose:
      FOR SEARCH
    | FOR ORDER BY any_name
    | # EMPTY
;
#
# RECHECK no longer does anything in opclass definitions,
# but we still accept it to ease porting of old database
# dumps.
#
opt_recheck:
      RECHECK
    | # EMPTY
;
CreateOpFamilyStmt:
      CREATE OPERATOR FAMILY any_name USING access_method 
;
AlterOpFamilyStmt:
      ALTER OPERATOR FAMILY any_name USING access_method ADD opclass_item_list
    | ALTER OPERATOR FAMILY any_name USING access_method DROP opclass_drop_list 
;
opclass_drop_list:
      opclass_drop
    | opclass_drop_list ',' opclass_drop 
;
opclass_drop:
      OPERATOR Iconst '(' type_list ')'
    | FUNCTION Iconst '(' type_list ')' 
;
DropOpClassStmt:
      DROP OPERATOR CLASS any_name USING access_method opt_drop_behavior
    | DROP OPERATOR CLASS IF EXISTS any_name USING access_method opt_drop_behavior 
;
DropOpFamilyStmt:
      DROP OPERATOR FAMILY any_name USING access_method opt_drop_behavior
    | DROP OPERATOR FAMILY IF EXISTS any_name USING access_method opt_drop_behavior 
;
##############################################################################
#
#      QUERY:
#
#      DROP OWNED BY username [, username ...] [ RESTRICT | CASCADE ]
#      REASSIGN OWNED BY username [, username ...] TO username
#
##############################################################################
DropOwnedStmt:
      DROP OWNED BY name_list opt_drop_behavior 
;
ReassignOwnedStmt:
      REASSIGN OWNED BY name_list TO name 
;
##############################################################################
#
#      QUERY:
#
#      DROP itemtype [ IF EXISTS ] itemname [, itemname ...]
#           [ RESTRICT | CASCADE ]
#
##############################################################################
DropStmt:
      DROP drop_type IF EXISTS any_name_list opt_drop_behavior
    | DROP drop_type any_name_list opt_drop_behavior
    | DROP INDEX CONCURRENTLY any_name_list opt_drop_behavior
    | DROP INDEX CONCURRENTLY IF EXISTS any_name_list opt_drop_behavior 
;
drop_type:
      TABLE
    | SEQUENCE
    | VIEW
    | INDEX
    | FOREIGN TABLE
    | EVENT_TRIGGER
    | TYPE
    | DOMAIN
    | COLLATION
    | CONVERSION
    | SCHEMA
    | EXTENSION
    | TEXT SEARCH PARSER
    | TEXT SEARCH DICTIONARY
    | TEXT SEARCH TEMPLATE
    | TEXT SEARCH CONFIGURATION 
;
any_name_list:
      any_name
    | any_name_list ',' any_name 
;
any_name:
      ColId
    | ColId attrs 
;
attrs:
      '.' attr_name
    | attrs '.' attr_name 
;
##############################################################################
#
#      QUERY:
#            truncate table relname1, relname2, ...
#
##############################################################################
TruncateStmt:
      TRUNCATE opt_table relation_expr_list opt_restart_seqs opt_drop_behavior 
;
opt_restart_seqs:
      CONTINUE IDENTITY
    | RESTART IDENTITY
    | # EMPTY
;
##############################################################################
#
#   The COMMENT ON statement can take different forms based upon the type of
#   the object associated with the comment. The form of the statement is:
#
#   COMMENT ON [ [ DATABASE | DOMAIN | INDEX | SEQUENCE | TABLE | TYPE | VIEW |
#               COLLATION | CONVERSION | LANGUAGE | OPERATOR CLASS |
#               LARGE OBJECT | CAST | COLUMN | SCHEMA | TABLESPACE |
#               EXTENSION | ROLE | TEXT SEARCH PARSER |
#               TEXT SEARCH DICTIONARY | TEXT SEARCH TEMPLATE |
#               TEXT SEARCH CONFIGURATION | FOREIGN TABLE |
#               FOREIGN DATA WRAPPER | SERVER | EVENT TRIGGER ] <objname> |
#             AGGREGATE <aggname> (arg1, ...) |
#             FUNCTION <funcname> (arg1, arg2, ...) |
#             OPERATOR <op> (leftoperand_typ, rightoperand_typ) |
#             TRIGGER <triggername> ON <relname> |
#             CONSTRAINT <constraintname> ON <relname> |
#             RULE <rulename> ON <relname> ]
#            IS 'text'
#
##############################################################################
CommentStmt:
      COMMENT ON comment_type any_name IS comment_text
    | COMMENT ON AGGREGATE func_name aggr_args IS comment_text
    | COMMENT ON FUNCTION func_name func_args IS comment_text
    | COMMENT ON OPERATOR any_operator oper_argtypes IS comment_text
    | COMMENT ON CONSTRAINT name ON any_name IS comment_text
    | COMMENT ON RULE name ON any_name IS comment_text
    | COMMENT ON RULE name IS comment_text # Obsolete syntax supported for awhile for compatibility
    | COMMENT ON TRIGGER name ON any_name IS comment_text
    | COMMENT ON OPERATOR CLASS any_name USING access_method IS comment_text
    | COMMENT ON OPERATOR FAMILY any_name USING access_method IS comment_text
    | COMMENT ON LARGE OBJECT NumericOnly IS comment_text
    | COMMENT ON CAST '(' Typename AS Typename ')' IS comment_text
    | COMMENT ON opt_procedural LANGUAGE any_name IS comment_text
    | COMMENT ON TEXT SEARCH PARSER any_name IS comment_text
    | COMMENT ON TEXT SEARCH DICTIONARY any_name IS comment_text
    | COMMENT ON TEXT SEARCH TEMPLATE any_name IS comment_text
    | COMMENT ON TEXT SEARCH CONFIGURATION any_name IS comment_text 
;
comment_type:
      COLUMN
    | DATABASE
    | SCHEMA
    | INDEX
    | SEQUENCE
    | TABLE
    | DOMAIN
    | TYPE
    | VIEW
    | COLLATION
    | CONVERSION
    | TABLESPACE
    | EXTENSION
    | ROLE
    | FOREIGN TABLE
    | SERVER
    | FOREIGN DATA WRAPPER
    | EVENT TRIGGER 
;
comment_text:
      Sconst
    | NULL 
;
##############################################################################
#
#  SECURITY LABEL [FOR <provider>] ON <object> IS <label>
#
#  As with COMMENT ON, <object> can refer to various types of database
#  objects (e.g. TABLE, COLUMN, etc.).
#
##############################################################################
SecLabelStmt:
      SECURITY LABEL opt_provider ON security_label_type any_name IS security_label
    | SECURITY LABEL opt_provider ON AGGREGATE func_name aggr_args IS security_label
    | SECURITY LABEL opt_provider ON FUNCTION func_name func_args IS security_label
    | SECURITY LABEL opt_provider ON LARGE OBJECT NumericOnly IS security_label
    | SECURITY LABEL opt_provider ON opt_procedural LANGUAGE any_name IS security_label 
;
opt_provider:
      FOR ColId_or_Sconst
    | # empty
;
security_label_type:
      COLUMN
    | DATABASE
    | EVENT TRIGGER
    | SCHEMA
    | FOREIGN TABLE
    | SCHEMA
    | SEQUENCE
    | TABLE
    | DOMAIN
    | ROLE
    | TABLESPACE
    | TYPE
    | VIEW 
;
security_label:
      Sconst
    | NULL 
;
##############################################################################
#
#      QUERY:
#         fetch/move
#
##############################################################################
FetchStmt:
      FETCH fetch_args
    | MOVE fetch_args 
;
fetch_args:
      cursor_name
    | from_in cursor_name
    | NEXT opt_from_in cursor_name
    | PRIOR opt_from_in cursor_name
    | FIRST opt_from_in cursor_name
    | LAST opt_from_in cursor_name
    | ABSOLUTE SignedIconst opt_from_in cursor_name
    | RELATIVE SignedIconst opt_from_in cursor_name
    | SignedIconst opt_from_in cursor_name
    | ALL opt_from_in cursor_name
    | FORWARD opt_from_in cursor_name
    | FORWARD SignedIconst opt_from_in cursor_name
    | FORWARD ALL opt_from_in cursor_name
    | BACKWARD opt_from_in cursor_name
    | BACKWARD SignedIconst opt_from_in cursor_name
    | BACKWARD ALL opt_from_in cursor_name 
;
from_in:
      FROM
    | IN 
;
opt_from_in:
      from_in
    | # EMPTY
;
##############################################################################
#
# GRANT and REVOKE statements
#
##############################################################################
GrantStmt:
      GRANT privileges ON privilege_target TO grantee_list opt_grant_grant_option 
;
RevokeStmt:
      REVOKE privileges ON privilege_target FROM grantee_list opt_drop_behavior
    | REVOKE GRANT OPTION FOR privileges ON privilege_target FROM grantee_list opt_drop_behavior 
;
#
# Privilege names are represented as strings; the validity of the privilege
# names gets checked at execution.  This is a bit annoying but we have little
# choice because of the syntactic conflict with lists of role names in
# GRANT/REVOKE.  What's more, we have to call out in the "privilege"
# production any reserved keywords that need to be usable as privilege names.
#

# either ALL [PRIVILEGES] or a list of individual privileges
privileges:
      privilege_list
    | ALL
    | ALL PRIVILEGES
    | ALL '(' columnList ')'
    | ALL PRIVILEGES '(' columnList ')' 
;
privilege_list:
      privilege
    | privilege_list ',' privilege 
;
privilege:
      SELECT opt_column_list
    | REFERENCES opt_column_list
    | CREATE opt_column_list
    | ColId opt_column_list 
;
# Don't bother trying to fold the first two rules into one using
# opt_table.  You're going to get conflicts.
#
privilege_target:
      qualified_name_list
    | TABLE qualified_name_list
    | SEQUENCE qualified_name_list
    | FOREIGN DATA WRAPPER name_list
    | FOREIGN SERVER name_list
    | FUNCTION function_with_argtypes_list
    | DATABASE name_list
    | LANGUAGE name_list
    | LARGE OBJECT NumericOnly_list
    | SCHEMA name_list
    | TABLESPACE name_list
    | ALL TABLES IN SCHEMA name_list
    | ALL SEQUENCES IN SCHEMA name_list
    | ALL FUNCTIONS IN SCHEMA name_list 
;
grantee_list:
      grantee
    | grantee_list ',' grantee 
;
grantee:
      RoleId
    | GROUP RoleId 
;
opt_grant_grant_option:
      WITH GRANT OPTION
    | # EMPTY
;
function_with_argtypes_list:
      function_with_argtypes
    | function_with_argtypes_list ',' function_with_argtypes 
;
function_with_argtypes:
      func_name func_args 
;
##############################################################################
#
# GRANT and REVOKE ROLE statements
#
##############################################################################
GrantRoleStmt:
      GRANT privilege_list TO name_list opt_grant_admin_option opt_granted_by 
;
RevokeRoleStmt:
      REVOKE privilege_list FROM name_list opt_granted_by opt_drop_behavior
    | REVOKE ADMIN OPTION FOR privilege_list FROM name_list opt_granted_by opt_drop_behavior 
;
opt_grant_admin_option:
      WITH ADMIN OPTION
    | # EMPTY
;
opt_granted_by:
      GRANTED BY RoleId
    | # EMPTY
;
##############################################################################
#
# ALTER DEFAULT PRIVILEGES statement
#
##############################################################################
AlterDefaultPrivilegesStmt:
      ALTER DEFAULT PRIVILEGES DefACLOptionList DefACLAction 
;
DefACLOptionList:
      DefACLOptionList DefACLOption
    | # EMPTY
;
DefACLOption:
      IN SCHEMA name_list
    | FOR ROLE name_list
    | FOR USER name_list 
;
#
# This should match GRANT/REVOKE, except that individual target objects
# are not mentioned and we only allow a subset of object types.
#
DefACLAction:
      GRANT privileges ON defacl_privilege_target TO grantee_list opt_grant_grant_option
    | REVOKE privileges ON defacl_privilege_target FROM grantee_list opt_drop_behavior
    | REVOKE GRANT OPTION FOR privileges ON defacl_privilege_target FROM grantee_list opt_drop_behavior 
;
defacl_privilege_target:
      TABLES
    | FUNCTIONS
    | SEQUENCES
    | TYPES 
;
##############################################################################
#
#      QUERY: CREATE INDEX
#
# Note: we cannot put TABLESPACE clause after WHERE clause unless we are
# willing to make TABLESPACE a fully reserved word.
##############################################################################
IndexStmt:
      CREATE opt_unique INDEX opt_concurrently opt_index_name ON qualified_name access_method_clause '(' index_params ')' opt_reloptions OptTableSpace where_clause 
;
opt_unique:
      UNIQUE
    | # EMPTY
;
opt_concurrently:
      CONCURRENTLY
    | # EMPTY
;
opt_index_name:
      index_name
    | # EMPTY
;
access_method_clause:
      USING access_method
    | # EMPTY
;
index_params:
      index_elem
    | index_params ',' index_elem 
;
#
# Index attributes can be either simple column references, or arbitrary
# expressions in parens.  For backwards-compatibility reasons, we allow
# an expression that's just a function call to be written without parens.
#
index_elem:
      ColId opt_collate opt_class opt_asc_desc opt_nulls_order
    | func_expr opt_collate opt_class opt_asc_desc opt_nulls_order
    | '(' a_expr ')' opt_collate opt_class opt_asc_desc opt_nulls_order 
;
opt_collate:
      COLLATE any_name
    | # EMPTY
;
opt_class:
      any_name
    | USING any_name
    | # EMPTY
;
opt_asc_desc:
      ASC
    | DESC
    | # EMPTY
;
opt_nulls_order:
      NULLS_FIRST
    | NULLS_LAST
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            create [or replace] function <fname>
#                  [(<type-1> { , <type-n>})]
#                  returns <type-r>
#                  as <filename or code in language as appropriate>
#                  language <lang> [with parameters]
#
##############################################################################
CreateFunctionStmt:
      CREATE opt_or_replace FUNCTION func_name func_args_with_defaults RETURNS func_return createfunc_opt_list opt_definition
    | CREATE opt_or_replace FUNCTION func_name func_args_with_defaults RETURNS TABLE '(' table_func_column_list ')' createfunc_opt_list opt_definition
    | CREATE opt_or_replace FUNCTION func_name func_args_with_defaults createfunc_opt_list opt_definition 
;
opt_or_replace:
      OR REPLACE
    | # EMPTY
;
func_args:
      '(' func_args_list ')'
    | '(' ')' 
;
func_args_list:
      func_arg
    | func_args_list ',' func_arg 
;
#
# func_args_with_defaults is separate because we only want to accept
# defaults in CREATE FUNCTION, not in ALTER etc.
#
func_args_with_defaults:
      '(' func_args_with_defaults_list ')'
    | '(' ')' 
;
func_args_with_defaults_list:
      func_arg_with_default
    | func_args_with_defaults_list ',' func_arg_with_default 
;
#
# The style with arg_class first is SQL99 standard, but Oracle puts
# param_name first; accept both since it's likely people will try both
# anyway.  Don't bother trying to save productions by letting arg_class
# have an empty alternative ... you'll get shift/reduce conflicts.
#
# We can catch over-specified arguments here if we want to,
# but for now better to silently swallow typmod, etc.
# - thomas 2000-03-22
#
func_arg:
      arg_class param_name func_type
    | param_name arg_class func_type
    | param_name func_type
    | arg_class func_type
    | func_type 
;
# INOUT is SQL99 standard, IN OUT is for Oracle compatibility
arg_class:
      IN
    | OUT
    | INOUT
    | IN OUT
    | VARIADIC 
;
#
# Ideally param_name should be ColId, but that causes too many conflicts.
#
param_name:
      type_function_name 
;
func_return:
      func_type # We can catch over-specified results here if we want to,
               # but for now better to silently swallow typmod, etc.
               # - thomas 2000-03-22
               
;
#
# We would like to make the %TYPE productions here be ColId attrs etc,
# but that causes reduce/reduce conflicts.  type_function_name
# is next best choice.
#
func_type:
      Typename
    | type_function_name attrs '%' TYPE
    | SETOF type_function_name attrs '%' TYPE 
;
func_arg_with_default:
      func_arg
    | func_arg DEFAULT a_expr
    | func_arg '=' a_expr 
;
createfunc_opt_list:
      # Must be at least one to prevent conflictcreatefunc_opt_item
    | createfunc_opt_list createfunc_opt_item 
;
#
# Options common to both CREATE FUNCTION and ALTER FUNCTION
#
common_func_opt_item:
      CALLED ON NULL INPUT
    | RETURNS NULL ON NULL INPUT
    | STRICT
    | IMMUTABLE
    | STABLE
    | VOLATILE
    | EXTERNAL SECURITY DEFINER
    | EXTERNAL SECURITY INVOKER
    | SECURITY DEFINER
    | SECURITY INVOKER
    | COST NumericOnly
    | ROWS NumericOnly
    | FunctionSetResetClause # we abuse the normal content of a DefElem here
;
createfunc_opt_item:
      AS func_as
    | LANGUAGE ColId_or_Sconst
    | WINDOW
    | common_func_opt_item 
;
func_as:
      Sconst
    | Sconst ',' Sconst 
;
opt_definition:
      WITH definition
    | # EMPTY
;
table_func_column:
      param_name func_type 
;
table_func_column_list:
      table_func_column
    | table_func_column_list ',' table_func_column 
;
##############################################################################
# ALTER FUNCTION
#
# RENAME and OWNER subcommands are already provided by the generic
# ALTER infrastructure, here we just specify alterations that can
# only be applied to functions.
#
##############################################################################
AlterFunctionStmt:
      ALTER FUNCTION function_with_argtypes alterfunc_opt_list opt_restrict 
;
alterfunc_opt_list:
      # At least one option must be specifiedcommon_func_opt_item
    | alterfunc_opt_list common_func_opt_item 
;
# Ignored, merely for SQL compliance
opt_restrict:
      RESTRICT
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#
#      DROP FUNCTION funcname (arg1, arg2, ...) [ RESTRICT | CASCADE ]
#      DROP AGGREGATE aggname (arg1, ...) [ RESTRICT | CASCADE ]
#      DROP OPERATOR opname (leftoperand_typ, rightoperand_typ) [ RESTRICT | CASCADE ]
#
##############################################################################
RemoveFuncStmt:
      DROP FUNCTION func_name func_args opt_drop_behavior
    | DROP FUNCTION IF EXISTS func_name func_args opt_drop_behavior 
;
RemoveAggrStmt:
      DROP AGGREGATE func_name aggr_args opt_drop_behavior
    | DROP AGGREGATE IF EXISTS func_name aggr_args opt_drop_behavior 
;
RemoveOperStmt:
      DROP OPERATOR any_operator oper_argtypes opt_drop_behavior
    | DROP OPERATOR IF EXISTS any_operator oper_argtypes opt_drop_behavior 
;
oper_argtypes:
      '(' Typename ')'
    | '(' Typename ',' Typename ')'
    | '(' NONE ',' Typename ')' # left unary
    | '(' Typename ',' NONE ')' # right unary
;
any_operator:
      all_Op
    | ColId '.' any_operator 
;
##############################################################################
#
#      DO <anonymous code block> [ LANGUAGE language ]
#
# We use a DefElem list for future extensibility, and to allow flexibility
# in the clause order.
#
##############################################################################
DoStmt:
      DO dostmt_opt_list 
;
dostmt_opt_list:
      dostmt_opt_item
    | dostmt_opt_list dostmt_opt_item 
;
dostmt_opt_item:
      Sconst
    | LANGUAGE ColId_or_Sconst 
;
##############################################################################
#
#      CREATE CAST / DROP CAST
#
##############################################################################
CreateCastStmt:
      CREATE CAST '(' Typename AS Typename ')' WITH FUNCTION function_with_argtypes cast_context
    | CREATE CAST '(' Typename AS Typename ')' WITHOUT FUNCTION cast_context
    | CREATE CAST '(' Typename AS Typename ')' WITH INOUT cast_context 
;
cast_context:
      AS IMPLICIT
    | AS ASSIGNMENT
    | # EMPTY
;
DropCastStmt:
      DROP CAST opt_if_exists '(' Typename AS Typename ')' opt_drop_behavior 
;
opt_if_exists:
      IF EXISTS
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#
#      REINDEX type <name> [FORCE]
#
# FORCE no longer does anything, but we accept it for backwards compatibility
##############################################################################
ReindexStmt:
      REINDEX reindex_type qualified_name opt_force
    | REINDEX SYSTEM name opt_force
    | REINDEX DATABASE name opt_force 
;
reindex_type:
      INDEX
    | TABLE 
;
opt_force:
      FORCE
    | # EMPTY
;
##############################################################################
#
# ALTER THING name RENAME TO newname
#
##############################################################################
RenameStmt:
      ALTER AGGREGATE func_name aggr_args RENAME TO name
    | ALTER COLLATION any_name RENAME TO name
    | ALTER CONVERSION any_name RENAME TO name
    | ALTER DATABASE database_name RENAME TO database_name
    | ALTER FUNCTION function_with_argtypes RENAME TO name
    | ALTER GROUP RoleId RENAME TO RoleId
    | ALTER opt_procedural LANGUAGE name RENAME TO name
    | ALTER OPERATOR CLASS any_name USING access_method RENAME TO name
    | ALTER OPERATOR FAMILY any_name USING access_method RENAME TO name
    | ALTER SCHEMA name RENAME TO name
    | ALTER TABLE relation_expr RENAME TO name
    | ALTER SEQUENCE qualified_name RENAME TO name
    | ALTER VIEW qualified_name RENAME TO name
    | ALTER INDEX qualified_name RENAME TO name
    | ALTER FOREIGN TABLE relation_expr RENAME TO name
    | ALTER TABLE relation_expr RENAME opt_column name TO name
    | ALTER FOREIGN TABLE relation_expr RENAME opt_column name TO name
    | ALTER TRIGGER name ON qualified_name RENAME TO name
    | ALTER ROLE RoleId RENAME TO RoleId
    | ALTER USER RoleId RENAME TO RoleId
    | ALTER TABLESPACE name RENAME TO name
    | ALTER TABLESPACE name SET reloptions
    | ALTER TABLESPACE name RESET reloptions
    | ALTER TEXT SEARCH PARSER any_name RENAME TO name
    | ALTER TEXT SEARCH DICTIONARY any_name RENAME TO name
    | ALTER TEXT SEARCH TEMPLATE any_name RENAME TO name
    | ALTER TEXT SEARCH CONFIGURATION any_name RENAME TO name
    | ALTER TYPE any_name RENAME TO name
    | ALTER TYPE any_name RENAME ATTRIBUTE name TO name opt_drop_behavior 
;
opt_column:
      COLUMN  /*** Just noise... ***/
    | # EMPTY
;
opt_set_data:
      SET DATA
    | # EMPTY
;
##############################################################################
#
# ALTER THING name SET SCHEMA name
#
##############################################################################
AlterObjectSchemaStmt:
      ALTER AGGREGATE func_name aggr_args SET SCHEMA name
    | ALTER COLLATION any_name SET SCHEMA name
    | ALTER CONVERSION any_name SET SCHEMA name
    | ALTER DOMAIN any_name SET SCHEMA name
    | ALTER EXTENSION any_name SET SCHEMA name
    | ALTER FUNCTION function_with_argtypes SET SCHEMA name
    | ALTER OPERATOR any_operator oper_argtypes SET SCHEMA name
    | ALTER OPERATOR CLASS any_name USING access_method SET SCHEMA name
    | ALTER OPERATOR FAMILY any_name USING access_method SET SCHEMA name
    | ALTER TABLE relation_expr SET SCHEMA name
    | ALTER TEXT SEARCH PARSER any_name SET SCHEMA name
    | ALTER TEXT SEARCH DICTIONARY any_name SET SCHEMA name
    | ALTER TEXT SEARCH TEMPLATE any_name SET SCHEMA name
    | ALTER TEXT SEARCH CONFIGURATION any_name SET SCHEMA name
    | ALTER SEQUENCE qualified_name SET SCHEMA name
    | ALTER VIEW qualified_name SET SCHEMA name
    | ALTER FOREIGN TABLE relation_expr SET SCHEMA name
    | ALTER TYPE any_name SET SCHEMA name 
;
##############################################################################
#
# ALTER THING name OWNER TO newname
#
##############################################################################
AlterOwnerStmt:
      ALTER AGGREGATE func_name aggr_args OWNER TO RoleId
    | ALTER COLLATION any_name OWNER TO RoleId
    | ALTER CONVERSION any_name OWNER TO RoleId
    | ALTER DATABASE database_name OWNER TO RoleId
    | ALTER DOMAIN any_name OWNER TO RoleId
    | ALTER FUNCTION function_with_argtypes OWNER TO RoleId
    | ALTER opt_procedural LANGUAGE name OWNER TO RoleId
    | ALTER LARGE OBJECT NumericOnly OWNER TO RoleId
    | ALTER OPERATOR any_operator oper_argtypes OWNER TO RoleId
    | ALTER OPERATOR CLASS any_name USING access_method OWNER TO RoleId
    | ALTER OPERATOR FAMILY any_name USING access_method OWNER TO RoleId
    | ALTER SCHEMA name OWNER TO RoleId
    | ALTER TYPE any_name OWNER TO RoleId
    | ALTER TABLESPACE name OWNER TO RoleId
    | ALTER TEXT SEARCH DICTIONARY any_name OWNER TO RoleId
    | ALTER TEXT SEARCH CONFIGURATION any_name OWNER TO RoleId
    | ALTER FOREIGN DATA WRAPPER name OWNER TO RoleId
    | ALTER SERVER name OWNER TO RoleId 
;
##############################################################################
#
#      QUERY:   Define Rewrite Rule
#
##############################################################################
RuleStmt:
      CREATE opt_or_replace RULE name AS ON event TO qualified_name where_clause DO opt_instead RuleActionList 
;
RuleActionList:
      NOTHING
    | RuleActionStmt
    | '(' RuleActionMulti ')' 
;
# the thrashing around here is to discard "empty" statements...
RuleActionMulti:
      RuleActionMulti ';' RuleActionStmtOrEmpty
    | RuleActionStmtOrEmpty 
;
RuleActionStmt:
      SelectStmt
    | InsertStmt
    | UpdateStmt
    | DeleteStmt
    | NotifyStmt 
;
RuleActionStmtOrEmpty:
      RuleActionStmt
    | # EMPTY
;
event:
      SELECT
    | UPDATE
    | DELETE
    | INSERT 
;
opt_instead:
      INSTEAD
    | ALSO
    | # EMPTY
;
DropRuleStmt:
      DROP RULE name ON qualified_name opt_drop_behavior
    | DROP RULE IF EXISTS name ON qualified_name opt_drop_behavior 
;
##############################################################################
#
#      QUERY:
#            NOTIFY <identifier> can appear both in rule bodies and
#            as a query-level command
#
##############################################################################
NotifyStmt:
      NOTIFY ColId notify_payload 
;
notify_payload:
      ',' Sconst
    | # EMPTY
;
ListenStmt:
      LISTEN ColId 
;
UnlistenStmt:
      UNLISTEN ColId
    | UNLISTEN '*' 
;
##############################################################################
#
#      Transactions:
#
#      BEGIN / COMMIT / ROLLBACK
#      (also older versions END / ABORT)
#
##############################################################################
TransactionStmt:
      ABORT opt_transaction
    | BEGIN opt_transaction transaction_mode_list_or_empty
    | START TRANSACTION transaction_mode_list_or_empty
    | COMMIT opt_transaction
    | END opt_transaction
    | ROLLBACK opt_transaction
    | SAVEPOINT ColId
    | RELEASE SAVEPOINT ColId
    | RELEASE ColId
    | ROLLBACK opt_transaction TO SAVEPOINT ColId
    | ROLLBACK opt_transaction TO ColId
    | PREPARE TRANSACTION Sconst
    | COMMIT PREPARED Sconst
    | ROLLBACK PREPARED Sconst 
;
opt_transaction:
      WORK
    | TRANSACTION
    | # EMPTY
;
transaction_mode_item:
      ISOLATION LEVEL iso_level
    | READ ONLY
    | READ WRITE
    | DEFERRABLE
    | NOT DEFERRABLE 
;
# Syntax with commas is SQL-spec, without commas is Postgres historical
transaction_mode_list:
      transaction_mode_item
    | transaction_mode_list ',' transaction_mode_item
    | transaction_mode_list transaction_mode_item 
;
transaction_mode_list_or_empty:
      transaction_mode_list
    | # EMPTY
;
##############################################################################
#
#   QUERY:
#      CREATE [ OR REPLACE ] [ TEMP ] VIEW <viewname> '('target-list ')'
#         AS <query> [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
#
##############################################################################
ViewStmt:
      CREATE OptTemp VIEW qualified_name opt_column_list AS SelectStmt opt_check_option
    | CREATE OR REPLACE OptTemp VIEW qualified_name opt_column_list AS SelectStmt opt_check_option 
;
opt_check_option:
      WITH CHECK OPTION
    | WITH CASCADED CHECK OPTION
    | WITH LOCAL CHECK OPTION
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            LOAD "filename"
#
##############################################################################
LoadStmt:
      LOAD file_name 
;
##############################################################################
#
#      CREATE DATABASE
#
##############################################################################
CreatedbStmt:
      CREATE DATABASE database_name opt_with createdb_opt_list 
;
createdb_opt_list:
      createdb_opt_list createdb_opt_item
    | # EMPTY
;
createdb_opt_item:
      TABLESPACE opt_equal name
    | TABLESPACE opt_equal DEFAULT
    | LOCATION opt_equal Sconst
    | LOCATION opt_equal DEFAULT
    | TEMPLATE opt_equal name
    | TEMPLATE opt_equal DEFAULT
    | ENCODING opt_equal Sconst
    | ENCODING opt_equal Iconst
    | ENCODING opt_equal DEFAULT
    | LC_COLLATE opt_equal Sconst
    | LC_COLLATE opt_equal DEFAULT
    | LC_CTYPE opt_equal Sconst
    | LC_CTYPE opt_equal DEFAULT
    | CONNECTION LIMIT opt_equal SignedIconst
    | OWNER opt_equal name
    | OWNER opt_equal DEFAULT 
;
#
#   Though the equals sign doesn't match other WITH options, pg_dump uses
#   equals for backward compatibility, and it doesn't seem worth removing it.
#
opt_equal:
      '='
    | # EMPTY
;
##############################################################################
#
#      ALTER DATABASE
#
##############################################################################
AlterDatabaseStmt:
      ALTER DATABASE database_name opt_with alterdb_opt_list
    | ALTER DATABASE database_name SET TABLESPACE name 
;
AlterDatabaseSetStmt:
      ALTER DATABASE database_name SetResetClause 
;
alterdb_opt_list:
      alterdb_opt_list alterdb_opt_item
    | # EMPTY
;
alterdb_opt_item:
      CONNECTION LIMIT opt_equal SignedIconst 
;
##############################################################################
#
#      DROP DATABASE [ IF EXISTS ]
#
# This is implicitly CASCADE, no need for drop behavior
##############################################################################
DropdbStmt:
      DROP DATABASE database_name
    | DROP DATABASE IF EXISTS database_name 
;
##############################################################################
#
# Manipulate a domain
#
##############################################################################
CreateDomainStmt:
      CREATE DOMAIN any_name opt_as Typename ColQualList 
;
AlterDomainStmt:
      # ALTER DOMAIN <domain> {SET DEFAULT <expr>|DROP DEFAULT}ALTER DOMAIN any_name alter_column_default # ALTER DOMAIN <domain> DROP NOT NULL
    | ALTER DOMAIN any_name DROP NOT NULL # ALTER DOMAIN <domain> SET NOT NULL
    | ALTER DOMAIN any_name SET NOT NULL # ALTER DOMAIN <domain> ADD CONSTRAINT ...
    | ALTER DOMAIN any_name ADD TableConstraint # ALTER DOMAIN <domain> DROP CONSTRAINT <name> [RESTRICT|CASCADE]
    | ALTER DOMAIN any_name DROP CONSTRAINT name opt_drop_behavior 
;
opt_as:
      AS
    | # EMPTY
;
##############################################################################
#
# Manipulate a text search dictionary or configuration
#
##############################################################################
AlterTSDictionaryStmt:
      ALTER TEXT SEARCH DICTIONARY any_name definition 
;
AlterTSConfigurationStmt:
      ALTER TEXT SEARCH CONFIGURATION any_name ADD MAPPING FOR name_list WITH any_name_list
    | ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list WITH any_name_list
    | ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING REPLACE any_name WITH any_name
    | ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list REPLACE any_name WITH any_name
    | ALTER TEXT SEARCH CONFIGURATION any_name DROP MAPPING FOR name_list
    | ALTER TEXT SEARCH CONFIGURATION any_name DROP MAPPING IF EXISTS FOR name_list 
;
##############################################################################
#
# Manipulate a conversion
#
#      CREATE [DEFAULT] CONVERSION <conversion_name>
#      FOR <encoding_name> TO <encoding_name> FROM <func_name>
#
##############################################################################
CreateConversionStmt:
      CREATE opt_default CONVERSION any_name FOR Sconst TO Sconst FROM any_name 
;
##############################################################################
#
#      QUERY:
#            CLUSTER [VERBOSE] <qualified_name> [ USING <index_name> ]
#            CLUSTER [VERBOSE]
#            CLUSTER [VERBOSE] <index_name> ON <qualified_name> (for pre-8.3)
#
##############################################################################
ClusterStmt:
      CLUSTER opt_verbose qualified_name cluster_index_specification
    | CLUSTER opt_verbose # kept for pre-8.3 compatibility
    | CLUSTER opt_verbose index_name ON qualified_name 
;
cluster_index_specification:
      USING index_name
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            VACUUM
#            ANALYZE
#
##############################################################################
VacuumStmt:
      VACUUM opt_full opt_freeze opt_verbose
    | VACUUM opt_full opt_freeze opt_verbose qualified_name
    | VACUUM opt_full opt_freeze opt_verbose AnalyzeStmt
    | VACUUM '(' vacuum_option_list ')'
    | VACUUM '(' vacuum_option_list ')' qualified_name opt_name_list 
;
vacuum_option_list:
      vacuum_option_elem
    | vacuum_option_list ',' vacuum_option_elem 
;
vacuum_option_elem:
      analyze_keyword
    | VERBOSE
    | FREEZE
    | FULL 
;
AnalyzeStmt:
      analyze_keyword opt_verbose
    | analyze_keyword opt_verbose qualified_name opt_name_list 
;
analyze_keyword:
      ANALYZE
    | ANALYSE # British
;
opt_verbose:
      VERBOSE
    | # EMPTY
;
opt_full:
      FULL
    | # EMPTY
;
opt_freeze:
      FREEZE
    | # EMPTY
;
opt_name_list:
      '(' name_list ')'
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            EXPLAIN [ANALYZE] [VERBOSE] query
#            EXPLAIN ( options ) query
#
##############################################################################
ExplainStmt:
      EXPLAIN ExplainableStmt
    | EXPLAIN analyze_keyword opt_verbose ExplainableStmt
    | EXPLAIN VERBOSE ExplainableStmt
    | EXPLAIN '(' explain_option_list ')' ExplainableStmt 
;
ExplainableStmt:
      SelectStmt
    | InsertStmt
    | UpdateStmt
    | DeleteStmt
    | DeclareCursorStmt
    | CreateAsStmt
    | ExecuteStmt # by default all are $$=$_[1]
;
explain_option_list:
      explain_option_elem
    | explain_option_list ',' explain_option_elem 
;
explain_option_elem:
      explain_option_name explain_option_arg 
;
explain_option_name:
      ColId
    | analyze_keyword
    | VERBOSE 
;
explain_option_arg:
      opt_boolean_or_string
    | NumericOnly
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            PREPARE <plan_name> [(args, ...)] AS <query>
#
##############################################################################
PrepareStmt:
      PREPARE name prep_type_clause AS PreparableStmt 
;
prep_type_clause:
      '(' type_list ')'
    | # EMPTY
;
PreparableStmt:
      SelectStmt
    | InsertStmt
    | UpdateStmt
    | DeleteStmt # by default all are $$=$_[1]
;
##############################################################################
#
# EXECUTE <plan_name> [(params, ...)]
# CREATE TABLE <name> AS EXECUTE <plan_name> [(params, ...)]
#
##############################################################################
ExecuteStmt:
      EXECUTE name execute_param_clause
    | CREATE OptTemp TABLE create_as_target AS EXECUTE name execute_param_clause opt_with_data 
;
execute_param_clause:
      '(' expr_list ')'
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            DEALLOCATE [PREPARE] <plan_name>
#
##############################################################################
DeallocateStmt:
      DEALLOCATE name
    | DEALLOCATE PREPARE name
    | DEALLOCATE ALL
    | DEALLOCATE PREPARE ALL 
;
##############################################################################
#
#      QUERY:
#            INSERT STATEMENTS
#
##############################################################################
InsertStmt:
      opt_with_clause INSERT INTO qualified_name insert_rest returning_clause 
;
insert_rest:
      SelectStmt
    | '(' insert_column_list ')' SelectStmt
    | DEFAULT VALUES 
;
insert_column_list:
      insert_column_item
    | insert_column_list ',' insert_column_item 
;
insert_column_item:
      ColId opt_indirection 
;
returning_clause:
      RETURNING target_list
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            DELETE STATEMENTS
#
##############################################################################
DeleteStmt:
      opt_with_clause DELETE FROM relation_expr_opt_alias using_clause where_or_current_clause returning_clause 
;
using_clause:
      USING from_list
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            LOCK TABLE
#
##############################################################################
LockStmt:
      LOCK opt_table relation_expr_list opt_lock opt_nowait 
;
opt_lock:
      IN lock_type MODE
    | # EMPTY
;
lock_type:
      ACCESS SHARE
    | ROW SHARE
    | ROW EXCLUSIVE
    | SHARE UPDATE EXCLUSIVE
    | SHARE
    | SHARE ROW EXCLUSIVE
    | EXCLUSIVE
    | ACCESS EXCLUSIVE 
;
opt_nowait:
      NOWAIT
    | # EMPTY
;
##############################################################################
#
#      QUERY:
#            UpdateStmt (UPDATE)
#
##############################################################################
UpdateStmt:
      opt_with_clause UPDATE relation_expr_opt_alias SET set_clause_list from_clause where_or_current_clause returning_clause 
;
set_clause_list:
      set_clause
    | set_clause_list ',' set_clause 
;
set_clause:
      single_set_clause
    | multiple_set_clause 
;
single_set_clause:
      set_target '=' ctext_expr 
;
multiple_set_clause:
      '(' set_target_list ')' '=' ctext_row 
;
set_target:
      ColId opt_indirection 
;
set_target_list:
      set_target
    | set_target_list ',' set_target 
;
##############################################################################
#
#      QUERY:
#            CURSOR STATEMENTS
#
##############################################################################
DeclareCursorStmt:
      DECLARE cursor_name cursor_options CURSOR opt_hold FOR SelectStmt 
;
cursor_name:
      name 
;
cursor_options:
      # EMPTY
    | cursor_options NO SCROLL
    | cursor_options SCROLL
    | cursor_options BINARY
    | cursor_options INSENSITIVE 
;
opt_hold:
      # EMPTY
    | WITH HOLD
    | WITHOUT HOLD 
;
##############################################################################
#
#      QUERY:
#            SELECT STATEMENTS
#
##############################################################################

# A complete SELECT statement looks like this.
#
# The rule returns either a single SelectStmt node or a tree of them,
# representing a set-operation tree.
#
# There is an ambiguity when a sub-SELECT is within an a_expr and there
# are excess parentheses: do the parentheses belong to the sub-SELECT or
# to the surrounding a_expr?  We don't really care, but bison wants to know.
# To resolve the ambiguity, we are careful to define the grammar so that
# the decision is staved off as long as possible: as long as we can keep
# absorbing parentheses into the sub-SELECT, we will do so, and only when
# it's no longer possible to do that will we decide that parens belong to
# the expression.   For example, in "SELECT (((SELECT 2)) + 3)" the extra
# parentheses are treated as part of the sub-select.  The necessity of doing
# it that way is shown by "SELECT (((SELECT 2)) UNION SELECT 2)".   Had we
# parsed "((SELECT 2))" as an a_expr, it'd be too late to go back to the
# SELECT viewpoint when we see the UNION.
#
# This approach is implemented by defining a nonterminal select_with_parens,
# which represents a SELECT with at least one outer layer of parentheses,
# and being careful to use select_with_parens, never '(' SelectStmt ')',
# in the expression grammar.  We will then have shift-reduce conflicts
# which we can resolve in favor of always treating '(' <select> ')' as
# a select_with_parens.  To resolve the conflicts, the productions that
# conflict with the select_with_parens productions are manually given
# precedences lower than the precedence of ')', thereby ensuring that we
# shift ')' (and then reduce to select_with_parens) rather than trying to
# reduce the inner <select> nonterminal to something else.  We use UMINUS
# precedence for this, which is a fairly arbitrary choice.
#
# To be able to define select_with_parens itself without ambiguity, we need
# a nonterminal select_no_parens that represents a SELECT structure with no
# outermost parentheses.  This is a little bit tedious, but it works.
#
# In non-expression contexts, we use SelectStmt which can represent a SELECT
# with or without outer parentheses.
#
SelectStmt:
      select_no_parens %prec UMINUS
    | select_with_parens %prec UMINUS 
;
select_with_parens:
      '(' select_no_parens ')'
    | '(' select_with_parens ')' 
;
#
# This rule parses the equivalent of the standard's <query expression>.
# The duplicative productions are annoying, but hard to get rid of without
# creating shift/reduce conflicts.
#
#   FOR UPDATE/SHARE may be before or after LIMIT/OFFSET.
#   In <=7.2.X, LIMIT/OFFSET had to be after FOR UPDATE
#   We now support both orderings, but prefer LIMIT/OFFSET before FOR UPDATE/SHARE
#   2002-08-28 bjm
#
select_no_parens:
      simple_select
    | select_clause sort_clause
    | select_clause opt_sort_clause for_locking_clause opt_select_limit
    | select_clause opt_sort_clause select_limit opt_for_locking_clause
    | with_clause select_clause
    | with_clause select_clause sort_clause
    | with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit
    | with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause 
;
select_clause:
      simple_select
    | select_with_parens 
;
#
# This rule parses SELECT statements that can appear within set operations,
# including UNION, INTERSECT and EXCEPT.  '(' and ')' can be used to specify
# the ordering of the set operations.   Without '(' and ')' we want the
# operations to be ordered per the precedence specs at the head of this file.
#
# As with select_no_parens, simple_select cannot have outer parentheses,
# but can have parenthesized subclauses.
#
# Note that sort clauses cannot be included at this level --- SQL92 requires
#      SELECT foo UNION SELECT bar ORDER BY baz
# to be parsed as
#      (SELECT foo UNION SELECT bar) ORDER BY baz
# not
#      SELECT foo UNION (SELECT bar ORDER BY baz)
# Likewise for WITH, FOR UPDATE and LIMIT.  Therefore, those clauses are
# described as part of the select_no_parens production, not simple_select.
# This does not limit functionality, because you can reintroduce these
# clauses inside parentheses.
#
# NOTE: only the leftmost component SelectStmt should have INTO.
# However, this is not checked by the grammar; parse analysis must check it.
#
simple_select:
      SELECT opt_distinct target_list into_clause from_clause where_clause group_clause having_clause window_clause
    | values_clause
    | TABLE relation_expr # same as SELECT * FROM relation_expr
    | select_clause UNION opt_all select_clause
    | select_clause INTERSECT opt_all select_clause
    | select_clause EXCEPT opt_all select_clause 
;
#
# SQL standard WITH clause looks like:
#
# WITH [ RECURSIVE ] <query name> [ (<column>,...) ]
#      AS (query) [ SEARCH or CYCLE clause ]
#
# We don't currently support the SEARCH or CYCLE clause.
#
with_clause:
      WITH cte_list
    | WITH RECURSIVE cte_list 
;
cte_list:
      common_table_expr
    | cte_list ',' common_table_expr 
;
common_table_expr:
      name opt_name_list AS '(' PreparableStmt ')' 
;
opt_with_clause:
      with_clause
    | # EMPTY
;
into_clause:
      INTO OptTempTableName
    | # EMPTY
;
#
# Redundancy here is needed to avoid shift/reduce conflicts,
# since TEMP is not a reserved word.  See also OptTemp.
#
OptTempTableName:
      TEMPORARY opt_table qualified_name
    | TEMP opt_table qualified_name
    | LOCAL TEMPORARY opt_table qualified_name
    | LOCAL TEMP opt_table qualified_name
    | GLOBAL TEMPORARY opt_table qualified_name
    | GLOBAL TEMP opt_table qualified_name
    | UNLOGGED opt_table qualified_name
    | TABLE qualified_name
    | qualified_name 
;
opt_table:
      TABLE
    | # EMPTY
;
opt_all:
      ALL
    | DISTINCT
    | # EMPTY
;
# We use (NIL) as a placeholder to indicate that all target expressions
# should be placed in the DISTINCT list during parsetree analysis.
#
opt_distinct:
      DISTINCT
    | DISTINCT ON '(' expr_list ')'
    | ALL
    | # EMPTY
;
opt_sort_clause:
      sort_clause
    | # EMPTY
;
sort_clause:
      ORDER BY sortby_list 
;
sortby_list:
      sortby
    | sortby_list ',' sortby 
;
sortby:
      a_expr USING qual_all_Op opt_nulls_order
    | a_expr opt_asc_desc opt_nulls_order 
;
select_limit:
      limit_clause offset_clause
    | offset_clause limit_clause
    | limit_clause  # Changed to support LimitYX
    | offset_clause 
;
opt_select_limit:
      select_limit
    | # EMPTY
;
limit_clause:
      LIMIT select_limit_value
    | LIMIT select_limit_value ',' select_offset_value
    | FETCH first_or_next opt_select_fetch_first_value row_or_rows ONLY 
;
offset_clause:
      OFFSET select_offset_value # SQL:2008 syntax
    | OFFSET select_offset_value2 row_or_rows 
;
select_limit_value:
      a_expr # LIMIT ALL is represented as a NULL constant
    | ALL 
;
select_offset_value:
      a_expr 
;
#
# Allowing full expressions without parentheses causes various parsing
# problems with the trailing ROW/ROWS key words.  SQL only calls for
# constants, so we allow the rest only with parentheses.  If omitted,
# default to 1.
#
opt_select_fetch_first_value:
      SignedIconst
    | '(' a_expr ')'
    | # EMPTY
;
#
# Again, the trailing ROW/ROWS in this case prevent the full expression
# syntax.  c_expr is the best we can do.
#
select_offset_value2:
      c_expr 
;
# noise words
row_or_rows:
      ROW
    | ROWS 
;
first_or_next:
      FIRST
    | NEXT 
;
group_clause:
      GROUP BY expr_list
    | # EMPTY
;
having_clause:
      HAVING a_expr
    | # EMPTY
;
for_locking_clause:
      for_locking_items
    | FOR READ ONLY 
;
opt_for_locking_clause:
      for_locking_clause
    | # EMPTY
;
for_locking_items:
      for_locking_item
    | for_locking_items for_locking_item 
;
for_locking_item:
      FOR UPDATE locked_rels_list opt_nowait
    | FOR SHARE locked_rels_list opt_nowait 
;
locked_rels_list:
      OF qualified_name_list
    | # EMPTY
;
values_clause:
      VALUES ctext_row
    | values_clause ',' ctext_row 
;
##############################################################################
#
#   clauses common to all Optimizable Stmts:
#      from_clause    - allow list of both JOIN expressions and table names
#      where_clause   - qualifications for joins or restrictions
#
##############################################################################
from_clause:
      FROM from_list
    | # EMPTY
;
from_list:
      table_ref
    | from_list ',' table_ref 
;
#
# table_ref is where an alias clause can be attached.   Note we cannot make
# alias_clause have an empty production because that causes parse conflicts
# between table_ref := '(' joined_table ')' alias_clause
# and joined_table := '(' joined_table ')'.  So, we must have the
# redundant-looking productions here instead.
#
table_ref:
      relation_expr
    | relation_expr alias_clause
    | func_table
    | func_table alias_clause
    | func_table AS '(' TableFuncElementList ')'
    | func_table AS ColId '(' TableFuncElementList ')'
    | func_table ColId '(' TableFuncElementList ')'
          # The SQL spec does not permit a subselect
          # (<derived_table>) without an alias clause,
          # so we don't either.  This avoids the problem
          # of needing to invent a unique refname for it.
          # That could be surmounted if there's sufficient
          # popular demand, but for now let's just implement
          # the spec and see if anyone complains.
          # However, it does seem like a good idea to emit
          # an error message that's better than "syntax error".
         
    | select_with_parens
    | select_with_parens alias_clause
    | joined_table
    | '(' joined_table ')' alias_clause 
;
#
# It may seem silly to separate joined_table from table_ref, but there is
# method in SQL92's madness: if you don't do it this way you get reduce-
# reduce conflicts, because it's not clear to the parser generator whether
# to expect alias_clause after ')' or not.  For the same reason we must
# treat 'JOIN' and 'join_type JOIN' separately, rather than allowing
# join_type to expand to empty; if we try it, the parser generator can't
# figure out when to reduce an empty join_type right after table_ref.
#
# Note that a CROSS JOIN is the same as an unqualified
# INNER JOIN, and an INNER JOIN/ON has the same shape
# but a qualification expression to limit membership.
# A NATURAL JOIN implicitly matches column names between
# tables and the shape is determined by which columns are
# in common. We'll collect columns during the later transformations.
#
joined_table:
      '(' joined_table ')'
    | table_ref CROSS JOIN table_ref # CROSS JOIN is same as unqualified inner join
    | table_ref join_type JOIN table_ref join_qual
    | table_ref JOIN table_ref join_qual # letting join_type reduce to empty doesn't work
    | table_ref NATURAL join_type JOIN table_ref
    | table_ref NATURAL JOIN table_ref # letting join_type reduce to empty doesn't work
;
alias_clause:
      AS ColId '(' name_list ')'
    | AS ColId
    | ColId '(' name_list ')'
    | ColId 
;
join_type:
      FULL join_outer
    | LEFT join_outer
    | RIGHT join_outer
    | INNER 
;
# OUTER is just noise...
join_outer:
      OUTER
    | # EMPTY
;
# JOIN qualification clauses
# Possibilities are:
#   USING ( column list ) allows only unqualified column names,
#                    which must match between tables.
#   ON expr allows more general qualifications.
#
# We return USING as a List node, while an ON-expr will not be a List.
#
join_qual:
      USING '(' name_list ')'
    | ON a_expr 
;
relation_expr:
      qualified_name # default inheritance
    | qualified_name '*' # inheritance query
    | ONLY qualified_name # no inheritance
    | ONLY '(' qualified_name ')' # no inheritance, SQL99-style syntax
;
relation_expr_list:
      relation_expr
    | relation_expr_list ',' relation_expr 
;
#
# Given "UPDATE foo set set ...", we have to decide without looking any
# further ahead whether the first "set" is an alias or the UPDATE's SET
# keyword.  Since "set" is allowed as a column name both interpretations
# are feasible.  We resolve the shift/reduce conflict by giving the first
# relation_expr_opt_alias production a higher precedence than the SET token
# has, causing the parser to prefer to reduce, in effect assuming that the
# SET is not an alias.
#
relation_expr_opt_alias:
      relation_expr %prec UMINUS
    | relation_expr ColId
    | relation_expr AS ColId 
;
func_table:
      func_expr 
;
where_clause:
      WHERE a_expr
    | # EMPTY
;
# variant for UPDATE and DELETE
where_or_current_clause:
      WHERE a_expr
    | WHERE CURRENT OF cursor_name
    | # EMPTY
;
OptTableFuncElementList:
      TableFuncElementList
    | # EMPTY
;
TableFuncElementList:
      TableFuncElement
    | TableFuncElementList ',' TableFuncElement 
;
TableFuncElement:
      ColId Typename opt_collate_clause 
;
##############################################################################
#
#   Type syntax
#      SQL92 introduces a large amount of type-specific syntax.
#      Define individual clauses to handle these cases, and use
#       the generic case to handle regular type-extensible Postgres syntax.
#      - thomas 1997-10-10
#
##############################################################################
Typename:
      SimpleTypename opt_array_bounds
    | SETOF SimpleTypename opt_array_bounds # SQL standard syntax, currently only one-dimensional
    | SimpleTypename ARRAY '[' Iconst ']'
    | SETOF SimpleTypename ARRAY '[' Iconst ']'
    | SimpleTypename ARRAY
    | SETOF SimpleTypename ARRAY 
;
opt_array_bounds:
      opt_array_bounds '[' ']'
    | opt_array_bounds '[' Iconst ']'
    | # EMPTY
;
SimpleTypename:
      GenericType
    | Numeric
    | Bit
    | Character
    | ConstDatetime
    | ConstInterval opt_interval
    | ConstInterval '(' Iconst ')' opt_interval 
;
# We have a separate ConstTypename to allow defaulting fixed-length
# types such as CHAR() and BIT() to an unspecified length.
# SQL9x requires that these default to a length of one, but this
# makes no sense for constructs like CHAR 'hi' and BIT '0101',
# where there is an obvious better choice to make.
# Note that ConstInterval is not included here since it must
# be pushed up higher in the rules to accomodate the postfix
# options (e.g. INTERVAL '1' YEAR). Likewise, we have to handle
# the generic-type-name case in AExprConst to avoid premature
# reduce/reduce conflicts against function names.
#
ConstTypename:
      Numeric
    | ConstBit
    | ConstCharacter
    | ConstDatetime 
;
#
# GenericType covers all type names that don't have special syntax mandated
# by the standard, including qualified names.  We also allow type modifiers.
# To avoid parsing conflicts against function invocations, the modifiers
# have to be shown as expr_list here, but parse analysis will only accept
# constants for them.
#
GenericType:
      type_function_name opt_type_modifiers
    | type_function_name attrs opt_type_modifiers 
;
opt_type_modifiers:
      '(' expr_list ')'
    | # EMPTY
;
#
# SQL92 numeric data types
#
Numeric:
      INT
    | INTEGER
    | SMALLINT
    | BIGINT
    | REAL
    | FLOAT opt_float
    | DOUBLE PRECISION
    | DECIMAL opt_type_modifiers
    | DEC opt_type_modifiers
    | NUMERIC opt_type_modifiers
    | BOOLEAN 
;
#
# Check FLOAT() precision limits assuming IEEE floating
# types - thomas 1997-09-18
#
opt_float:
      '(' Iconst ')'
    | # EMPTY
;
#
# SQL92 bit-field data types
# The following implements BIT() and BIT VARYING().
#
Bit:
      BitWithLength
    | BitWithoutLength 
;
# ConstBit is like Bit except "BIT" defaults to unspecified length
# See notes for ConstCharacter, which addresses same issue for "CHAR"
ConstBit:
      BitWithLength
    | BitWithoutLength 
;
BitWithLength:
      BIT opt_varying '(' expr_list ')' 
;
BitWithoutLength:
      BIT opt_varying 
;
#
# SQL92 character data types
# The following implements CHAR() and VARCHAR().
#
Character:
      CharacterWithLength
    | CharacterWithoutLength 
;
ConstCharacter:
      CharacterWithLength # Length was not specified so allow to be unrestricted.
          * This handles problems with fixed-length (bpchar) strings
          * which in column definitions must default to a length
          * of one, but should not be constrained if the length
          * was not specified.
         
    | CharacterWithoutLength 
;
CharacterWithLength:
      character '(' Iconst ')' opt_charset 
;
CharacterWithoutLength:
      character opt_charset 
;
character:
      CHARACTER opt_varying
    | CHAR opt_varying
    | VARCHAR
    | NATIONAL CHARACTER opt_varying
    | NATIONAL CHAR opt_varying
    | NCHAR opt_varying 
;
opt_varying:
      VARYING
    | # EMPTY
;
opt_charset:
      CHARACTER SET ColId
    | # EMPTY
;
#
# SQL92 date/time types
#
ConstDatetime:
      TIMESTAMP '(' Iconst ')' opt_timezone
    | TIMESTAMP opt_timezone
    | TIME '(' Iconst ')' opt_timezone
    | TIME opt_timezone 
;
ConstInterval:
      INTERVAL 
;
opt_timezone:
      WITH_TIME ZONE
    | WITHOUT TIME ZONE
    | # EMPTY
;
opt_interval:
      YEAR
    | MONTH
    | DAY
    | HOUR
    | MINUTE
    | interval_second
    | YEAR TO MONTH
    | DAY TO HOUR
    | DAY TO MINUTE
    | DAY TO interval_second
    | HOUR TO MINUTE
    | HOUR TO interval_second
    | MINUTE TO interval_second
    | # EMPTY
;
interval_second:
      SECOND
    | SECOND '(' Iconst ')' 
;
##############################################################################
#
#   expression grammar
#
##############################################################################

#
# General expressions
# This is the heart of the expression syntax.
#
# We have two expression types: a_expr is the unrestricted kind, and
# b_expr is a subset that must be used in some places to avoid shift/reduce
# conflicts.  For example, we can't do BETWEEN as "BETWEEN a_expr AND a_expr"
# because that use of AND conflicts with AND as a boolean operator.  So,
# b_expr is used in BETWEEN and we remove boolean keywords from b_expr.
#
# Note that '(' a_expr ')' is a b_expr, so an unrestricted expression can
# always be used by surrounding it with parens.
#
# c_expr is all the productions that are common to a_expr and b_expr;
# it's factored out just to eliminate redundant coding.
#
a_expr:
      c_expr
    | a_expr TYPECAST Typename
    | a_expr COLLATE any_name
    | a_expr AT TIME ZONE a_expr %prec AT 
       * These operators must be called out explicitly in order to make use
       * of bison's automatic operator-precedence handling.  All other
       * operator names are handled by the generic productions using "Op",
       * below; and all those operators will have the same precedence.
       *
       * If you add more explicitly-known operators, be sure to add them
       * also to b_expr and to the MathOp list above.
      
    | '+' a_expr %prec UMINUS
    | '-' a_expr %prec UMINUS
    | a_expr '+' a_expr
    | a_expr '-' a_expr
    | a_expr '*' a_expr
    | a_expr '/' a_expr
    | a_expr '%' a_expr
    | a_expr '^' a_expr
    | a_expr '<' a_expr
    | a_expr '>' a_expr
    | a_expr '=' a_expr
    | a_expr qual_Op a_expr %prec Op
    | qual_Op a_expr %prec Op
    | a_expr qual_Op %prec POSTFIXOP
    | a_expr AND a_expr
    | a_expr OR a_expr
    | NOT a_expr
    | a_expr LIKE a_expr
    | a_expr LIKE a_expr ESCAPE a_expr
    | a_expr NOT LIKE a_expr
    | a_expr NOT LIKE a_expr ESCAPE a_expr
    | a_expr ILIKE a_expr
    | a_expr ILIKE a_expr ESCAPE a_expr
    | a_expr NOT ILIKE a_expr
    | a_expr NOT ILIKE a_expr ESCAPE a_expr
    | a_expr SIMILAR TO a_expr %prec SIMILAR
    | a_expr SIMILAR TO a_expr ESCAPE a_expr
    | a_expr NOT SIMILAR TO a_expr %prec SIMILAR
    | a_expr NOT SIMILAR TO a_expr ESCAPE a_expr # NullTest clause
          * Define SQL92-style Null test clause.
          * Allow two forms described in the standard:
          *   a IS NULL
          *   a IS NOT NULL
          * Allow two SQL extensions
          *   a ISNULL
          *   a NOTNULL
         
    | a_expr IS NULL %prec IS
    | a_expr ISNULL
    | a_expr IS NOT NULL %prec IS
    | a_expr NOTNULL
    | row OVERLAPS row
    | a_expr IS TRUE %prec IS
    | a_expr IS NOT TRUE %prec IS
    | a_expr IS FALSE %prec IS
    | a_expr IS NOT FALSE %prec IS
    | a_expr IS UNKNOWN %prec IS
    | a_expr IS NOT UNKNOWN %prec IS
    | a_expr IS DISTINCT FROM a_expr %prec IS
    | a_expr IS NOT DISTINCT FROM a_expr %prec IS
    | a_expr IS OF '(' type_list ')' %prec IS
    | a_expr IS NOT OF '(' type_list ')' %prec IS 
          *   Ideally we would not use hard-wired operators below but
          *   instead use opclasses.  However, mixed data types and other
          *   issues make this difficult:
          *   http://archives.postgresql.org/pgsql-hackers/2008-08/msg01142.php
         
    | a_expr BETWEEN opt_asymmetric b_expr AND b_expr %prec BETWEEN
    | a_expr NOT BETWEEN opt_asymmetric b_expr AND b_expr %prec BETWEEN
    | a_expr BETWEEN SYMMETRIC b_expr AND b_expr %prec BETWEEN
    | a_expr NOT BETWEEN SYMMETRIC b_expr AND b_expr %prec BETWEEN
    | a_expr IN in_expr
    | a_expr NOT IN in_expr
    | a_expr subquery_Op sub_type select_with_parens %prec Op
    | a_expr subquery_Op sub_type '(' a_expr ')' %prec Op
    | UNIQUE select_with_parens # Not sure how to get rid of the parentheses
            # but there are lots of shift/reduce errors without them.
            #
            # Should be able to implement this by plopping the entire
            # select into a node, then transforming the target expressions
            # from whatever they are into count(*), and testing the
            # entire result equal to one.
            # But, will probably implement a separate node in the executor.
            
    | a_expr IS DOCUMENT %prec IS
    | a_expr IS NOT DOCUMENT %prec IS 
;
#
# Restricted expressions
#
# b_expr is a subset of the complete expression syntax defined by a_expr.
#
# Presently, AND, NOT, IS, and IN are the a_expr keywords that would
# cause trouble in the places where b_expr is used.  For simplicity, we
# just eliminate all the boolean-keyword-operator productions from b_expr.
#
b_expr:
      c_expr
    | b_expr TYPECAST Typename
    | '+' b_expr %prec UMINUS
    | '-' b_expr %prec UMINUS
    | b_expr '+' b_expr
    | b_expr '-' b_expr
    | b_expr '*' b_expr
    | b_expr '/' b_expr
    | b_expr '%' b_expr
    | b_expr '^' b_expr
    | b_expr '<' b_expr
    | b_expr '>' b_expr
    | b_expr '=' b_expr
    | b_expr qual_Op b_expr %prec Op
    | qual_Op b_expr %prec Op
    | b_expr qual_Op %prec POSTFIXOP
    | b_expr IS DISTINCT FROM b_expr %prec IS
    | b_expr IS NOT DISTINCT FROM b_expr %prec IS
    | b_expr IS OF '(' type_list ')' %prec IS
    | b_expr IS NOT OF '(' type_list ')' %prec IS
    | b_expr IS DOCUMENT %prec IS
    | b_expr IS NOT DOCUMENT %prec IS 
;
#
# Productions that can be used in both a_expr and b_expr.
#
# Note: productions that refer recursively to a_expr or b_expr mostly
# cannot appear here.   However, it's OK to refer to a_exprs that occur
# inside parentheses, such as function arguments; that cannot introduce
# ambiguity to the b_expr syntax.
#
c_expr:
      columnref
    | AexprConst
    | PARAM opt_indirection
    | '(' a_expr ')' opt_indirection
    | case_expr
    | func_expr
    | select_with_parens %prec UMINUS
    | EXISTS select_with_parens
    | ARRAY select_with_parens
    | ARRAY array_expr
    | row 
;
#
# func_expr is split out from c_expr just so that we have a classification
# for "everything that is a function call or looks like one".  This isn't
# very important, but it saves us having to document which variants are
# legal in the backwards-compatible functional-index syntax for CREATE INDEX.
# (Note that many of the special SQL functions wouldn't actually make any
# sense as functional index entries, but we ignore that consideration here.)
#
func_expr:
      func_name '(' ')' over_clause
    | func_name '(' func_arg_list ')' over_clause
    | func_name '(' VARIADIC func_arg_expr ')' over_clause
    | func_name '(' func_arg_list ',' VARIADIC func_arg_expr ')' over_clause
    | func_name '(' func_arg_list sort_clause ')' over_clause
    | func_name '(' ALL func_arg_list opt_sort_clause ')' over_clause
    | func_name '(' DISTINCT func_arg_list opt_sort_clause ')' over_clause
    | func_name '(' '*' ')' over_clause 
            # We consider AGGREGATE(*) to invoke a parameterless
            # aggregate.  This does the right thing for COUNT(*),
            # and there are no other aggregates in SQL92 that accept
            # '*' as parameter.
            #
            # The FuncCall node is also marked agg_star = TRUE,
            # so that later processing can detect what the argument
            # really was.
            
    | CURRENT_DATE 
            # Translate as "'now'::text::date".
            #
            # We cannot use "'now'::date" because coerce_type() will
            # immediately reduce that to a constant representing
            # today's date.  We need to delay the conversion until
            # runtime, else the wrong things will happen when
            # CURRENT_DATE is used in a column default value or rule.
            #
            # This could be simplified if we had a way to generate
            # an expression tree representing runtime application
            # of type-input conversion functions.  (As of PG 7.3
            # that is actually possible, but not clear that we want
            # to rely on it.)
            
    | CURRENT_TIME 
            # Translate as "'now'::text::timetz".
            # See comments for CURRENT_DATE.
            
    | CURRENT_TIME '(' Iconst ')' 
            # Translate as "'now'::text::timetz(n)".
            # See comments for CURRENT_DATE.
            
    | CURRENT_TIMESTAMP 
            # Translate as "now()", since we have a function that
            # does exactly what is needed.
            
    | CURRENT_TIMESTAMP '(' Iconst ')' 
            # Translate as "'now'::text::timestamptz(n)".
            # See comments for CURRENT_DATE.
            
    | LOCALTIME 
            # Translate as "'now'::text::time".
            # See comments for CURRENT_DATE.
            
    | LOCALTIME '(' Iconst ')' 
            # Translate as "'now'::text::time(n)".
            # See comments for CURRENT_DATE.
            
    | LOCALTIMESTAMP 
            # Translate as "'now'::text::timestamp".
            # See comments for CURRENT_DATE.
            
    | LOCALTIMESTAMP '(' Iconst ')' 
            # Translate as "'now'::text::timestamp(n)".
            # See comments for CURRENT_DATE.
            
    | CURRENT_ROLE
    | CURRENT_USER
    | SESSION_USER
    | USER
    | CURRENT_CATALOG
    | CURRENT_SCHEMA
    | CAST '(' a_expr AS Typename ')'
    | EXTRACT '(' extract_list ')'
    | OVERLAY '(' overlay_list ')' # overlay(A PLACING B FROM C FOR D) is converted to
            # overlay(A, B, C, D)
            # overlay(A PLACING B FROM C) is converted to
            # overlay(A, B, C)
            
    | POSITION '(' position_list ')' # position(A in B) is converted to position(B, A)
    | SUBSTRING '(' substr_list ')' # substring(A from B for C) is converted to
            # substring(A, B, C) - thomas 2000-11-28
            
    | TREAT '(' a_expr AS Typename ')' # TREAT(expr AS target) converts expr of a particular type to target,
            # which is defined to be a subtype of the original expression.
            # In SQL99, this is intended for use with structured UDTs,
            # but let's make this a generally useful form allowing stronger
            # coercions than are handled by implicit casting.
            
    | TRIM '(' BOTH trim_list ')' # various trim expressions are defined in SQL92
            # - thomas 1997-07-19
            
    | TRIM '(' LEADING trim_list ')'
    | TRIM '(' TRAILING trim_list ')'
    | TRIM '(' trim_list ')'
    | NULLIF '(' a_expr ',' a_expr ')'
    | COALESCE '(' expr_list ')'
    | GREATEST '(' expr_list ')'
    | LEAST '(' expr_list ')'
    | XMLCONCAT '(' expr_list ')'
    | XMLELEMENT '(' NAME ColLabel ')'
    | XMLELEMENT '(' NAME ColLabel ',' xml_attributes ')'
    | XMLELEMENT '(' NAME ColLabel ',' expr_list ')'
    | XMLELEMENT '(' NAME ColLabel ',' xml_attributes ',' expr_list ')'
    | XMLEXISTS '(' c_expr xmlexists_argument ')' # xmlexists(A PASSING [BY REF] B [BY REF]) is
            # converted to xmlexists(A, B)
    | XMLFOREST '(' xml_attribute_list ')'
    | XMLPARSE '(' document_or_content a_expr xml_whitespace_option ')'
    | XMLPI '(' NAME ColLabel ')'
    | XMLPI '(' NAME ColLabel ',' a_expr ')'
    | XMLROOT '(' a_expr ',' xml_root_version opt_xml_root_standalone ')'
    | XMLSERIALIZE '(' document_or_content a_expr AS SimpleTypename ')' 
;
#
# SQL/XML support
#
xml_root_version:
      VERSION a_expr
    | VERSION NO VALUE 
;
opt_xml_root_standalone:
      ',' STANDALONE YES
    | ',' STANDALONE NO
    | ',' STANDALONE NO VALUE
    | # EMPTY
;
xml_attributes:
      XMLATTRIBUTES '(' xml_attribute_list ')' 
;
xml_attribute_list:
      xml_attribute_el
    | xml_attribute_list ',' xml_attribute_el 
;
xml_attribute_el:
      a_expr AS ColLabel
    | a_expr 
;
document_or_content:
      DOCUMENT
    | CONTENT 
;
xml_whitespace_option:
      PRESERVE WHITESPACE
    | STRIP WHITESPACE
    | # EMPTY
;
# We allow several variants for SQL and other compatibility.
xmlexists_argument:
      PASSING c_expr
    | PASSING c_expr BY REF
    | PASSING BY REF c_expr
    | PASSING BY REF c_expr BY REF 
;
#
# Window Definitions
#
window_clause:
      WINDOW window_definition_list
    | # EMPTY
;
window_definition_list:
      window_definition
    | window_definition_list ',' window_definition 
;
window_definition:
      ColId AS window_specification 
;
over_clause:
      OVER window_specification
    | OVER ColId
    | # EMPTY
;
window_specification:
      '(' opt_existing_window_name opt_partition_clause opt_sort_clause opt_frame_clause ')' 
;
#
# If we see PARTITION, RANGE, or ROWS as the first token after the '('
# of a window_specification, we want the assumption to be that there is
# no existing_window_name; but those keywords are unreserved and so could
# be ColIds.  We fix this by making them have the same precedence as IDENT
# and giving the empty production here a slightly higher precedence, so
# that the shift/reduce conflict is resolved in favor of reducing the rule.
# These keywords are thus precluded from being an existing_window_name but
# are not reserved for any other purpose.
#
opt_existing_window_name:
      ColId
    | # EMPTY%prec Op 
;
opt_partition_clause:
      PARTITION BY expr_list
    | # EMPTY
;
#
# For frame clauses, we return a WindowDef, but only some fields are used:
# frameOptions, startOffset, and endOffset.
#
# This is only a subset of the full SQL:2008 frame_clause grammar.
# We don't support <window frame exclusion> yet.
#
opt_frame_clause:
      RANGE frame_extent
    | ROWS frame_extent
    | # EMPTY
;
frame_extent:
      frame_bound
    | BETWEEN frame_bound AND frame_bound 
;
#
# This is used for both frame start and frame end, with output set up on
# the assumption it's frame start; the frame_extent productions must reject
# invalid cases.
#
frame_bound:
      UNBOUNDED PRECEDING
    | UNBOUNDED FOLLOWING
    | CURRENT ROW
    | a_expr PRECEDING
    | a_expr FOLLOWING 
;
#
# Supporting nonterminals for expressions.
#

# Explicit row production.
#
# SQL99 allows an optional ROW keyword, so we can now do single-element rows
# without conflicting with the parenthesized a_expr production.  Without the
# ROW keyword, there must be more than one a_expr inside the parens.
#
row:
      ROW '(' expr_list ')'
    | ROW '(' ')'
    | '(' expr_list ',' a_expr ')' 
;
sub_type:
      ANY
    | SOME
    | ALL 
;
all_Op:
      Op
    | MathOp 
;
MathOp:
      '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '^'
    | '<'
    | '>'
    | '=' 
;
qual_Op:
      Op
    | OPERATOR '(' any_operator ')' 
;
qual_all_Op:
      all_Op
    | OPERATOR '(' any_operator ')' 
;
subquery_Op:
      all_Op
    | OPERATOR '(' any_operator ')'
    | LIKE
    | NOT LIKE
    | ILIKE
    | NOT ILIKE # cannot put SIMILAR TO here, because SIMILAR TO is a hack.
# the regular expression is preprocessed by a function (similar_escape),
# and the ~ operator for posix regular expressions is used.
#        x SIMILAR TO y     ->    x ~ similar_escape(y)
# this transformation is made on the fly by the parser upwards.
# however the SubLink structure which handles any/some/all stuff
# is not ready for such a thing.
#
;
expr_list:
      a_expr
    | expr_list ',' a_expr 
;
# function arguments can have names
func_arg_list:
      func_arg_expr
    | func_arg_list ',' func_arg_expr 
;
func_arg_expr:
      a_expr
    | param_name COLON_EQUALS a_expr 
;
type_list:
      Typename
    | type_list ',' Typename 
;
array_expr:
      '[' expr_list ']'
    | '[' array_expr_list ']'
    | '[' ']' 
;
array_expr_list:
      array_expr
    | array_expr_list ',' array_expr 
;
extract_list:
      extract_arg FROM a_expr
    | # EMPTY
;
# Allow delimited string Sconst in extract_arg as an SQL extension.
# - thomas 2001-04-12
#
extract_arg:
      IDENT
    | YEAR
    | MONTH
    | DAY
    | HOUR
    | MINUTE
    | SECOND
    | Sconst 
;
# OVERLAY() arguments
# SQL99 defines the OVERLAY() function:
# o overlay(text placing text from int for int)
# o overlay(text placing text from int)
# and similarly for binary strings
#
overlay_list:
      a_expr overlay_placing substr_from substr_for
    | a_expr overlay_placing substr_from 
;
overlay_placing:
      PLACING a_expr 
;
# position_list uses b_expr not a_expr to avoid conflict with general IN
position_list:
      b_expr IN b_expr
    | # EMPTY
;
# SUBSTRING() arguments
# SQL9x defines a specific syntax for arguments to SUBSTRING():
# o substring(text from int for int)
# o substring(text from int) get entire string from starting point "int"
# o substring(text for int) get first "int" characters of string
# o substring(text from pattern) get entire string matching pattern
# o substring(text from pattern for escape) same with specified escape char
# We also want to support generic substring functions which accept
# the usual generic list of arguments. So we will accept both styles
# here, and convert the SQL9x style to the generic list for further
# processing. - thomas 2000-11-28
#
substr_list:
      a_expr substr_from substr_for # not legal per SQL99, but might as well allow it
    | a_expr substr_for substr_from
    | a_expr substr_from
    | a_expr substr_for 
            # Since there are no cases where this syntax allows
            # a textual FOR value, we forcibly cast the argument
            # to int4.  The possible matches in pg_proc are
            # substring(text,int4) and substring(text,text),
            # and we don't want the parser to choose the latter,
            # which it is likely to do if the second argument
            # is unknown or doesn't have an implicit cast to int4.
            
    | expr_list
    | # EMPTY
;
substr_from:
      FROM a_expr 
;
substr_for:
      FOR a_expr 
;
trim_list:
      a_expr FROM expr_list
    | FROM expr_list
    | expr_list 
;
in_expr:
      select_with_parens
    | '(' expr_list ')' 
;
#
# Define SQL92-style case clause.
# - Full specification
#   CASE WHEN a = b THEN c ... ELSE d END
# - Implicit argument
#   CASE a WHEN b THEN c ... ELSE d END
#
case_expr:
      CASE case_arg when_clause_list case_default END 
;
when_clause_list:
      when_clause # There must be at least one
    | when_clause_list when_clause 
;
when_clause:
      WHEN a_expr THEN a_expr 
;
case_default:
      ELSE a_expr
    | # EMPTY
;
case_arg:
      a_expr
    | # EMPTY
;
columnref:
      ColId
    | ColId indirection 
;
indirection_el:
      '.' attr_name
    | '.' '*'
    | '[' a_expr ']'
    | '[' a_expr ':' a_expr ']' 
;
indirection:
      indirection_el
    | indirection indirection_el 
;
opt_indirection:
      # EMPTY
    | opt_indirection indirection_el 
;
opt_asymmetric:
      ASYMMETRIC
    | # EMPTY
;
#
# The SQL spec defines "contextually typed value expressions" and
# "contextually typed row value constructors", which for our purposes
# are the same as "a_expr" and "row" except that DEFAULT can appear at
# the top level.
#
ctext_expr:
      a_expr
    | DEFAULT 
;
ctext_expr_list:
      ctext_expr
    | ctext_expr_list ',' ctext_expr 
;
#
# We should allow ROW '(' ctext_expr_list ')' too, but that seems to require
# making VALUES a fully reserved word, which will probably break more apps
# than allowing the noise-word is worth.
#
ctext_row:
      '(' ctext_expr_list ')' 
;
##############################################################################
#
#   target list for SELECT
#
##############################################################################
target_list:
      target_el
    | target_list ',' target_el 
;
target_el:
      a_expr AS ColLabel 
          * We support omitting AS only for column labels that aren't
          * any known keyword.  There is an ambiguity against postfix
          * operators: is "a ! b" an infix expression, or a postfix
          * expression and a column label?  We prefer to resolve this
          * as an infix expression, which we accomplish by assigning
          * IDENT a precedence higher than POSTFIXOP.
         
    | a_expr IDENT
    | a_expr
    | '*' 
;
##############################################################################
#
#   Names and constants
#
##############################################################################
qualified_name_list:
      qualified_name
    | qualified_name_list ',' qualified_name 
;
#
# The production for a qualified relation name has to exactly match the
# production for a qualified func_name, because in a FROM clause we cannot
# tell which we are parsing until we see what comes after it ('(' for a
# func_name, something else for a relation). Therefore we allow 'indirection'
# which may contain subscripts, and reject that case in the C code.
#
qualified_name:
      ColId
    | ColId indirection 
;
name_list:
      name
    | name_list ',' name 
;
name:
      ColId 
;
database_name:
      ColId 
;
access_method:
      ColId 
;
attr_name:
      ColLabel 
;
index_name:
      ColId 
;
file_name:
      Sconst 
;
#
# The production for a qualified func_name has to exactly match the
# production for a qualified columnref, because we cannot tell which we
# are parsing until we see what comes after it ('(' or Sconst for a func_name,
# anything else for a columnref).  Therefore we allow 'indirection' which
# may contain subscripts, and reject that case in the C code.  (If we
# ever implement SQL99-like methods, such syntax may actually become legal!)
#
func_name:
      type_function_name
    | ColId indirection 
;
#
# Constants
#
AexprConst:
      Iconst
    | FCONST
    | Sconst
    | BCONST # This is a bit constant per SQL99:
             # Without Feature F511, "BIT data type",
             # a <general literal> shall not be a
             # <bit string literal> or a <hex string literal>.
            
    | XCONST
    | func_name Sconst
    | func_name '(' func_arg_list ')' Sconst
    | ConstTypename Sconst
    | ConstInterval Sconst opt_interval
    | ConstInterval '(' Iconst ')' Sconst opt_interval
    | TRUE
    | FALSE
    | NULL 
;
Iconst:
      ICONST 
;
Sconst:
      SCONST 
;
RoleId:
      ColId 
;
SignedIconst:
      Iconst
    | '+' Iconst
    | '-' Iconst 
;
#
# Name classification hierarchy.
#
# IDENT is the lexeme returned by the lexer for identifiers that match
# no known keyword.  In most cases, we can accept certain keywords as
# names, not only IDENTs.   We prefer to accept as many such keywords
# as possible to minimize the impact of "reserved words" on programmers.
# So, we divide names into several possible classes.  The classification
# is chosen in part to make keywords acceptable as names wherever possible.
#

# Column identifier --- names that can be column, table, etc names.
#
ColId:
      IDENT
    | unreserved_keyword
    | col_name_keyword 
;
# Type/function identifier --- names that can be type or function names.
#
type_function_name:
      IDENT
    | unreserved_keyword
    | type_func_name_keyword 
;
# Column label --- allowed labels in "AS" clauses.
# This presently includes *all* Postgres keywords.
#
ColLabel:
      IDENT
    | unreserved_keyword
    | col_name_keyword
    | type_func_name_keyword
    | reserved_keyword 
;
#
# Keyword category lists.  Generally, every keyword present in
# the Postgres grammar should appear in exactly one of these lists.
#
# Put a new keyword into the first list that it can go into without causing
# shift or reduce conflicts.  The earlier lists define "less reserved"
# categories of keywords.
#
# Make sure that each keyword's category in kwlist.h matches where
# it is listed here.  (Someday we may be able to generate these lists and
# kwlist.h's table from a common master list.)
#

### NOTE: As a matter of optimization for a top-down parser, we convert
### these into REs similar to L_KEYWORD.

# "Unreserved" keywords --- available for use as any kind of name.
#
unreserved_keyword: / (i: 
      ABORT
    | ABSOLUTE
    | ACCESS
    | ACTION
    | ADD
    | ADMIN
    | AFTER
    | AGGREGATE
    | ALSO
    | ALTER
    | ALWAYS
    | ASSERTION
    | ASSIGNMENT
    | AT
    | ATTRIBUTE
    | BACKWARD
    | BEFORE
    | BEGIN
    | BY
    | CACHE
    | CALLED
    | CASCADE
    | CASCADED
    | CATALOG
    | CHAIN
    | CHARACTERISTICS
    | CHECKPOINT
    | CLASS
    | CLOSE
    | CLUSTER
    | COMMENT
    | COMMENTS
    | COMMIT
    | COMMITTED
    | CONFIGURATION
    | CONNECTION
    | CONSTRAINTS
    | CONTENT
    | CONTINUE
    | CONVERSION
    | COPY
    | COST
    | CSV
    | CURRENT
    | CURSOR
    | CYCLE
    | DATA
    | DATABASE
    | DAY
    | DEALLOCATE
    | DECLARE
    | DEFAULTS
    | DEFERRED
    | DEFINER
    | DELETE
    | DELIMITER
    | DELIMITERS
    | DICTIONARY
    | DISABLE
    | DISCARD
    | DOCUMENT
    | DOMAIN
    | DOUBLE
    | DROP
    | EACH
    | ENABLE
    | ENCODING
    | ENCRYPTED
    | ENUM
    | ESCAPE
    | EXCLUDE
    | EXCLUDING
    | EXCLUSIVE
    | EXECUTE
    | EXPLAIN
    | EXTENSION
    | EXTERNAL
    | FAMILY
    | FIRST
    | FOLLOWING
    | FORCE
    | FORWARD
    | FUNCTION
    | FUNCTIONS
    | GLOBAL
    | GRANTED
    | HANDLER
    | HEADER
    | HOLD
    | HOUR
    | IDENTITY
    | IF
    | IMMEDIATE
    | IMMUTABLE
    | IMPLICIT
    | INCLUDING
    | INCREMENT
    | INDEX
    | INDEXES
    | INHERIT
    | INHERITS
    | INLINE
    | INPUT
    | INSENSITIVE
    | INSERT
    | INSTEAD
    | INVOKER
    | ISOLATION
    | KEY
    | LABEL
    | LANGUAGE
    | LARGE
    | LAST
    | LC_COLLATE
    | LC_CTYPE
    | LEAKPROOF
    | LEVEL
    | LISTEN
    | LOAD
    | LOCAL
    | LOCATION
    | LOCK
    | MAPPING
    | MATCH
    | MAXVALUE
    | MINUTE
    | MINVALUE
    | MODE
    | MONTH
    | MOVE
    | NAME
    | NAMES
    | NEXT
    | NO
    | NOTHING
    | NOTIFY
    | NOWAIT
    | NULLS
    | OBJECT
    | OF
    | OFF
    | OIDS
    | OPERATOR
    | OPTION
    | OPTIONS
    | OWNED
    | OWNER
    | PARSER
    | PARTIAL
    | PARTITION
    | PASSING
    | PASSWORD
    | PLANS
    | PRECEDING
    | PREPARE
    | PREPARED
    | PRESERVE
    | PRIOR
    | PRIVILEGES
    | PROCEDURAL
    | PROCEDURE
    | QUOTE
    | RANGE
    | READ
    | REASSIGN
    | RECHECK
    | RECURSIVE
    | REF
    | REINDEX
    | RELATIVE
    | RELEASE
    | RENAME
    | REPEATABLE
    | REPLACE
    | REPLICA
    | RESET
    | RESTART
    | RESTRICT
    | RETURNS
    | REVOKE
    | ROLE
    | ROLLBACK
    | ROWS
    | RULE
    | SAVEPOINT
    | SCHEMA
    | SCROLL
    | SEARCH
    | SECOND
    | SECURITY
    | SEQUENCE
    | SEQUENCES
    | SERIALIZABLE
    | SERVER
    | SESSION
    | SET
    | SHARE
    | SHOW
    | SIMPLE
    | SNAPSHOT
    | STABLE
    | STANDALONE
    | START
    | STATEMENT
    | STATISTICS
    | STDIN
    | STDOUT
    | STORAGE
    | STRICT
    | STRIP
    | SYSID
    | SYSTEM
    | TABLES
    | TABLESPACE
    | TEMP
    | TEMPLATE
    | TEMPORARY
    | TEXT
    | TRANSACTION
    | TRIGGER
    | TRUNCATE
    | TRUSTED
    | TYPE
    | TYPES
    | UNBOUNDED
    | UNCOMMITTED
    | UNENCRYPTED
    | UNKNOWN
    | UNLISTEN
    | UNLOGGED
    | UNTIL
    | UPDATE
    | VACUUM
    | VALID
    | VALIDATE
    | VALIDATOR
    | VALUE
    | VARYING
    | VERSION
    | VIEW
    | VOLATILE
    | WHITESPACE
    | WITHOUT
    | WORK
    | WRAPPER
    | WRITE
    | XML
    | YEAR
    | YES
    | ZONE 
) / !L_IDENT_REST

# Column identifier --- keywords that can be column, table, etc names.
#
# Many of these keywords will in fact be recognized as type or function
# names too; but they have special productions for the purpose, and so
# can't be treated as "generic" type or function names.
#
# The type names appearing here are not usable as function names
# because they can be followed by '(' in typename productions, which
# looks too much like a function call for an LR(1) parser.
#
col_name_keyword: / (i: 
      BETWEEN
    | BIGINT
    | BIT
    | BOOLEAN
    | CHAR
    | CHARACTER
    | COALESCE
    | DEC
    | DECIMAL
    | EXISTS
    | EXTRACT
    | FLOAT
    | GREATEST
    | INOUT
    | INT
    | INTEGER
    | INTERVAL
    | LEAST
    | NATIONAL
    | NCHAR
    | NONE
    | NULLIF
    | NUMERIC
    | OUT
    | OVERLAY
    | POSITION
    | PRECISION
    | REAL
    | ROW
    | SETOF
    | SMALLINT
    | SUBSTRING
    | TIME
    | TIMESTAMP
    | TREAT
    | TRIM
    | VALUES
    | VARCHAR
    | XMLATTRIBUTES
    | XMLCONCAT
    | XMLELEMENT
    | XMLEXISTS
    | XMLFOREST
    | XMLPARSE
    | XMLPI
    | XMLROOT
    | XMLSERIALIZE 
) / !L_IDENT_REST | NCHAR  # have to include this one because of the N'' exception

# Type/function identifier --- keywords that can be type or function names.
#
# Most of these are keywords that are used as operators in expressions;
# in general such keywords can't be column names because they would be
# ambiguous with variables, but they are unambiguous as function identifiers.
#
# Do not include POSITION, SUBSTRING, etc here since they have explicit
# productions in a_expr to support the goofy SQL9x argument syntax.
# - thomas 2000-11-28
#
type_func_name_keyword: / (i: 
      AUTHORIZATION
    | BINARY
    | COLLATION
    | CONCURRENTLY
    | CROSS
    | CURRENT_SCHEMA
    | FREEZE
    | FULL
    | ILIKE
    | INNER
    | IS
    | ISNULL
    | JOIN
    | LEFT
    | LIKE
    | NATURAL
    | NOTNULL
    | OUTER
    | OVER
    | OVERLAPS
    | RIGHT
    | SIMILAR
    | VERBOSE 
) / !L_IDENT_REST
# Reserved keyword --- these keywords are usable only as a ColLabel.
#
# Keywords appear here if they could not be distinguished from variable,
# type, or function names in some contexts.  Don't put things here unless
# forced to.
#
reserved_keyword: / (i: 
      ALL
    | ANALYSE
    | ANALYZE
    | AND
    | ANY
    | ARRAY
    | AS
    | ASC
    | ASYMMETRIC
    | BOTH
    | CASE
    | CAST
    | CHECK
    | COLLATE
    | COLUMN
    | CONSTRAINT
    | CREATE
    | CURRENT_CATALOG
    | CURRENT_DATE
    | CURRENT_ROLE
    | CURRENT_TIME
    | CURRENT_TIMESTAMP
    | CURRENT_USER
    | DEFAULT
    | DEFERRABLE
    | DESC
    | DISTINCT
    | DO
    | ELSE
    | END
    | EXCEPT
    | FALSE
    | FETCH
    | FOR
    | FOREIGN
    | FROM
    | GRANT
    | GROUP
    | HAVING
    | IN
    | INITIALLY
    | INTERSECT
    | INTO
    | LATERAL
    | LEADING
    | LIMIT
    | LOCALTIME
    | LOCALTIMESTAMP
    | NOT
    | NULL
    | OFFSET
    | ON
    | ONLY
    | OR
    | ORDER
    | PLACING
    | PRIMARY
    | REFERENCES
    | RETURNING
    | SELECT
    | SESSION_USER
    | SOME
    | SYMMETRIC
    | TABLE
    | THEN
    | TO
    | TRAILING
    | TRUE
    | UNION
    | UNIQUE
    | USER
    | USING
    | VARIADIC
    | WHEN
    | WHERE
    | WINDOW
    | WITH 
) / !L_IDENT_REST
