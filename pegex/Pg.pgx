%grammar SQL::Transform::Parser::Pg

#   The target production for the whole parse.
stmtblock: stmtmulti

# the thrashing around here is to discard "empty" statements...
stmtmulti  :
     stmtmulti_1
   | stmtmulti_2
;
stmtmulti_1: stmtmulti <SEMI> stmt  ### WARNING: Recursion; needs refactoring! ###
stmtmulti_2: stmt

stmt: (
     AlterEventTrigStmt
   | AlterDatabaseStmt
   | AlterDatabaseSetStmt
   | AlterDefaultPrivilegesStmt
   | AlterDomainStmt
   | AlterEnumStmt
   | AlterExtensionStmt
   | AlterExtensionContentsStmt
   | AlterFdwStmt
   | AlterForeignServerStmt
   | AlterForeignTableStmt
   | AlterFunctionStmt
   | AlterGroupStmt
   | AlterObjectSchemaStmt
   | AlterOwnerStmt
   | AlterSeqStmt
   | AlterTableStmt
   | AlterCompositeTypeStmt
   | AlterRoleSetStmt
   | AlterRoleStmt
   | AlterTSConfigurationStmt
   | AlterTSDictionaryStmt
   | AlterUserMappingStmt
   | AlterUserSetStmt
   | AlterUserStmt
   | AnalyzeStmt
   | CheckPointStmt
   | ClosePortalStmt
   | ClusterStmt
   | CommentStmt
   | ConstraintsSetStmt
   | CopyStmt
   | CreateAsStmt
   | CreateAssertStmt
   | CreateCastStmt
   | CreateConversionStmt
   | CreateDomainStmt
   | CreateExtensionStmt
   | CreateFdwStmt
   | CreateForeignServerStmt
   | CreateForeignTableStmt
   | CreateFunctionStmt
   | CreateGroupStmt
   | CreateOpClassStmt
   | CreateOpFamilyStmt
   | AlterOpFamilyStmt
   | CreatePLangStmt
   | CreateSchemaStmt
   | CreateSeqStmt
   | CreateStmt
   | CreateTableSpaceStmt
   | CreateTrigStmt
   | CreateEventTrigStmt
   | CreateRoleStmt
   | CreateUserStmt
   | CreateUserMappingStmt
   | CreatedbStmt
   | DeallocateStmt
   | DeclareCursorStmt
   | DefineStmt
   | DeleteStmt
   | DiscardStmt
   | DoStmt
   | DropAssertStmt
   | DropCastStmt
   | DropFdwStmt
   | DropForeignServerStmt
   | DropGroupStmt
   | DropOpClassStmt
   | DropOpFamilyStmt
   | DropOwnedStmt
   | DropPLangStmt
   | DropRuleStmt
   | DropStmt
   | DropTableSpaceStmt
   | DropTrigStmt
   | DropRoleStmt
   | DropUserStmt
   | DropUserMappingStmt
   | DropdbStmt
   | ExecuteStmt
   | ExplainStmt
   | FetchStmt
   | GrantStmt
   | GrantRoleStmt
   | IndexStmt
   | InsertStmt
   | ListenStmt
   | LoadStmt
   | LockStmt
   | NotifyStmt
   | PrepareStmt
   | ReassignOwnedStmt
   | ReindexStmt
   | RemoveAggrStmt
   | RemoveFuncStmt
   | RemoveOperStmt
   | RenameStmt
   | RevokeStmt
   | RevokeRoleStmt
   | RuleStmt
   | SecLabelStmt
   | SelectStmt
   | TransactionStmt
   | TruncateStmt
   | UnlistenStmt
   | UpdateStmt
   | VacuumStmt
   | VariableResetStmt
   | VariableSetStmt
   | VariableShowStmt
   | ViewStmt
)?

#############################################################################
#
# Create a new Postgres DBMS role
#
#############################################################################
CreateRoleStmt: CREATE ROLE RoleId opt_with OptRoleList

opt_with  : opt_with_1?
opt_with_1: WITH

# Options for CREATE ROLE and ALTER ROLE (also used by CREATE/ALTER USER
# for backwards compatibility).  Note: the only option required by SQL99
# is "WITH ADMIN name".
OptRoleList  : OptRoleList_1?
OptRoleList_1: OptRoleList CreateOptRoleElem  ### WARNING: Recursion; needs refactoring! ###

AlterOptRoleList  : AlterOptRoleList_1?
AlterOptRoleList_1: AlterOptRoleList AlterOptRoleElem  ### WARNING: Recursion; needs refactoring! ###

AlterOptRoleElem  :
     AlterOptRoleElem_1
   | AlterOptRoleElem_2
   | AlterOptRoleElem_3
   | AlterOptRoleElem_4
   | AlterOptRoleElem_5
   | AlterOptRoleElem_6
   | AlterOptRoleElem_7
   | AlterOptRoleElem_8
   | AlterOptRoleElem_9
;
AlterOptRoleElem_1: PASSWORD Sconst
AlterOptRoleElem_2: PASSWORD NULL
AlterOptRoleElem_3: ENCRYPTED PASSWORD Sconst
AlterOptRoleElem_4: UNENCRYPTED PASSWORD Sconst
AlterOptRoleElem_5: INHERIT
AlterOptRoleElem_6: CONNECTION LIMIT SignedIconst
AlterOptRoleElem_7: VALID UNTIL Sconst
AlterOptRoleElem_8: USER name_list
AlterOptRoleElem_9: IDENT

CreateOptRoleElem  :
     CreateOptRoleElem_1
   | CreateOptRoleElem_2
   | CreateOptRoleElem_3
   | CreateOptRoleElem_4
   | CreateOptRoleElem_5
   | CreateOptRoleElem_6
;
CreateOptRoleElem_1: AlterOptRoleElem
CreateOptRoleElem_2: SYSID Iconst
CreateOptRoleElem_3: ADMIN name_list
CreateOptRoleElem_4: ROLE name_list
CreateOptRoleElem_5: IN ROLE name_list
CreateOptRoleElem_6: IN GROUP name_list

#############################################################################
#
# Create a new Postgres DBMS user (role with implied login ability)
#
#############################################################################
CreateUserStmt: CREATE USER RoleId opt_with OptRoleList

#############################################################################
#
# Alter a postgresql DBMS role
#
#############################################################################
AlterRoleStmt: ALTER ROLE RoleId opt_with AlterOptRoleList

opt_in_database  : opt_in_database_1?
opt_in_database_1: IN DATABASE database_name

AlterRoleSetStmt: ALTER ROLE RoleId opt_in_database SetResetClause

#############################################################################
#
# Alter a postgresql DBMS user
#
#############################################################################
AlterUserStmt: ALTER USER RoleId opt_with AlterOptRoleList

AlterUserSetStmt: ALTER USER RoleId SetResetClause

#############################################################################
#
# Drop a postgresql DBMS role
#
# XXX Ideally this would have CASCADE/RESTRICT options, but since a role
# might own objects in multiple databases, there is presently no way to
# implement either cascading or restricting.  Caveat DBA.
#############################################################################
DropRoleStmt  :
     DropRoleStmt_1
   | DropRoleStmt_2
;
DropRoleStmt_1: DROP ROLE name_list
DropRoleStmt_2: DROP ROLE IF EXISTS name_list

#############################################################################
#
# Drop a postgresql DBMS user
#
# XXX Ideally this would have CASCADE/RESTRICT options, but since a user
# might own objects in multiple databases, there is presently no way to
# implement either cascading or restricting.  Caveat DBA.
#############################################################################
DropUserStmt  :
     DropUserStmt_1
   | DropUserStmt_2
;
DropUserStmt_1: DROP USER name_list
DropUserStmt_2: DROP USER IF EXISTS name_list

#############################################################################
#
# Create a postgresql group (role without login ability)
#
#############################################################################
CreateGroupStmt: CREATE GROUP RoleId opt_with OptRoleList

#############################################################################
#
# Alter a postgresql group
#
#############################################################################
AlterGroupStmt: ALTER GROUP RoleId add_drop USER name_list

add_drop  :
     add_drop_1
   | add_drop_2
;
add_drop_1: ADD
add_drop_2: DROP

#############################################################################
#
# Drop a postgresql group
#
# XXX see above notes about cascading DROP USER; groups have same problem.
#############################################################################
DropGroupStmt  :
     DropGroupStmt_1
   | DropGroupStmt_2
;
DropGroupStmt_1: DROP GROUP name_list
DropGroupStmt_2: DROP GROUP IF EXISTS name_list

#############################################################################
#
# Manipulate a schema
#
#############################################################################
CreateSchemaStmt  :
     CreateSchemaStmt_1
   | CreateSchemaStmt_2
;
CreateSchemaStmt_1: CREATE SCHEMA OptSchemaName AUTHORIZATION RoleId OptSchemaEltList
CreateSchemaStmt_2: CREATE SCHEMA ColId OptSchemaEltList

OptSchemaName  : OptSchemaName_1?
OptSchemaName_1: ColId

OptSchemaEltList  : OptSchemaEltList_1?
OptSchemaEltList_1: OptSchemaEltList schema_stmt  ### WARNING: Recursion; needs refactoring! ###

#   schema_stmt are the ones that can show up inside a CREATE SCHEMA
#   statement (in addition to by themselves).
schema_stmt:
     CreateStmt
   | IndexStmt
   | CreateSeqStmt
   | CreateTrigStmt
   | GrantStmt
   | ViewStmt
;

#############################################################################
#
# Set PG internal variable
#     SET name TO 'var_value'
# Include SQL92 syntax (thomas 1997-10-22):
#     SET TIME ZONE 'var_value'
#
#############################################################################
VariableSetStmt  :
     VariableSetStmt_1
   | VariableSetStmt_2
   | VariableSetStmt_3
;
VariableSetStmt_1: SET set_rest
VariableSetStmt_2: SET LOCAL set_rest
VariableSetStmt_3: SET SESSION set_rest

set_rest  :
     set_rest_1
   | set_rest_2
   | set_rest_more
;
set_rest_1: TRANSACTION transaction_mode_list
set_rest_2: SESSION CHARACTERISTICS AS TRANSACTION transaction_mode_list

set_rest_more   :
     set_rest_more_1
   | set_rest_more_2
   | set_rest_more_3
   | set_rest_more_4
   | set_rest_more_5
   | set_rest_more_6
   | set_rest_more_7
   | set_rest_more_8
   | set_rest_more_9
   | set_rest_more_10
   | set_rest_more_11
   | set_rest_more_12
   | set_rest_more_13
   | set_rest_more_14
;
set_rest_more_1 : 
# Generic SET syntaxes:
    var_name TO var_list
set_rest_more_2 : var_name <EQUAL> var_list
set_rest_more_3 : var_name TO DEFAULT
set_rest_more_4 : var_name <EQUAL> DEFAULT
set_rest_more_5 : var_name FROM CURRENT
set_rest_more_6 : TIME ZONE zone_value
set_rest_more_7 : CATALOG Sconst
set_rest_more_8 : SCHEMA Sconst
set_rest_more_9 : NAMES opt_encoding
set_rest_more_10: ROLE ColId_or_Sconst
set_rest_more_11: SESSION AUTHORIZATION ColId_or_Sconst
set_rest_more_12: SESSION AUTHORIZATION DEFAULT
set_rest_more_13: XML OPTION document_or_content
set_rest_more_14: TRANSACTION SNAPSHOT Sconst

var_name  :
     var_name_1
   | var_name_2
;
var_name_1: ColId
var_name_2: var_name <DOT> ColId  ### WARNING: Recursion; needs refactoring! ###

var_list  :
     var_list_1
   | var_list_2
;
var_list_1: var_value
var_list_2: var_list <COMMA> var_value  ### WARNING: Recursion; needs refactoring! ###

var_value  :
     var_value_1
   | var_value_2
;
var_value_1: opt_boolean_or_string
var_value_2: NumericOnly

iso_level  :
     iso_level_1
   | iso_level_2
   | iso_level_3
   | iso_level_4
;
iso_level_1: READ UNCOMMITTED
iso_level_2: READ COMMITTED
iso_level_3: REPEATABLE READ
iso_level_4: SERIALIZABLE

opt_boolean_or_string  :
     opt_boolean_or_string_1
   | opt_boolean_or_string_2
   | opt_boolean_or_string_3
   | opt_boolean_or_string_4
;
opt_boolean_or_string_1: TRUE
opt_boolean_or_string_2: FALSE
opt_boolean_or_string_3: ON
opt_boolean_or_string_4: ColId_or_Sconst

# Timezone values can be:
# - a string such as 'pst8pdt'
# - an identifier such as "pst8pdt"
# - an integer or floating point number
# - a time interval per SQL99
# ColId gives reduce/reduce errors against ConstInterval and LOCAL,
# so use IDENT (meaning we reject anything that is a key word).
zone_value  :
     zone_value_1
   | zone_value_2
   | zone_value_3
   | zone_value_4
   | zone_value_5
   | zone_value_6
   | zone_value_7
;
zone_value_1: Sconst
zone_value_2: IDENT
zone_value_3: ConstInterval Sconst opt_interval
zone_value_4: ConstInterval <LPAREN> Iconst <RPAREN> Sconst opt_interval
zone_value_5: NumericOnly
zone_value_6: DEFAULT
zone_value_7: LOCAL

opt_encoding  : (
     opt_encoding_1
   | opt_encoding_2
)?
opt_encoding_1: Sconst
opt_encoding_2: DEFAULT

ColId_or_Sconst  :
     ColId_or_Sconst_1
   | ColId_or_Sconst_2
;
ColId_or_Sconst_1: ColId
ColId_or_Sconst_2: Sconst

VariableResetStmt  :
     VariableResetStmt_1
   | VariableResetStmt_2
   | VariableResetStmt_3
   | VariableResetStmt_4
   | VariableResetStmt_5
;
VariableResetStmt_1: RESET var_name
VariableResetStmt_2: RESET TIME ZONE
VariableResetStmt_3: RESET TRANSACTION ISOLATION LEVEL
VariableResetStmt_4: RESET SESSION AUTHORIZATION
VariableResetStmt_5: RESET ALL

# SetResetClause allows SET or RESET without LOCAL
SetResetClause  :
     SetResetClause_1
   | SetResetClause_2
;
SetResetClause_1: SET set_rest
SetResetClause_2: VariableResetStmt

# SetResetClause allows SET or RESET without LOCAL
FunctionSetResetClause  :
     FunctionSetResetClause_1
   | FunctionSetResetClause_2
;
FunctionSetResetClause_1: SET set_rest_more
FunctionSetResetClause_2: VariableResetStmt

VariableShowStmt  :
     VariableShowStmt_1
   | VariableShowStmt_2
   | VariableShowStmt_3
   | VariableShowStmt_4
   | VariableShowStmt_5
;
VariableShowStmt_1: SHOW var_name
VariableShowStmt_2: SHOW TIME ZONE
VariableShowStmt_3: SHOW TRANSACTION ISOLATION LEVEL
VariableShowStmt_4: SHOW SESSION AUTHORIZATION
VariableShowStmt_5: SHOW ALL

ConstraintsSetStmt: SET CONSTRAINTS constraints_set_list constraints_set_mode

constraints_set_list  :
     constraints_set_list_1
   | constraints_set_list_2
;
constraints_set_list_1: ALL
constraints_set_list_2: qualified_name_list

constraints_set_mode  :
     constraints_set_mode_1
   | constraints_set_mode_2
;
constraints_set_mode_1: DEFERRED
constraints_set_mode_2: IMMEDIATE

# Checkpoint statement
CheckPointStmt: CHECKPOINT

#############################################################################
#
# DISCARD { ALL | TEMP | PLANS }
#
#############################################################################
DiscardStmt  :
     DiscardStmt_1
   | DiscardStmt_2
   | DiscardStmt_3
   | DiscardStmt_4
;
DiscardStmt_1: DISCARD ALL
DiscardStmt_2: DISCARD TEMP
DiscardStmt_3: DISCARD TEMPORARY
DiscardStmt_4: DISCARD PLANS

#############################################################################
#
#   ALTER [ TABLE | INDEX | SEQUENCE | VIEW ] variations
#
# Note: we accept all subcommands for each of the four variants, and sort
# out what's really legal at execution time.
#############################################################################
AlterTableStmt  :
     AlterTableStmt_1
   | AlterTableStmt_2
   | AlterTableStmt_3
   | AlterTableStmt_4
   | AlterTableStmt_5
   | AlterTableStmt_6
   | AlterTableStmt_7
   | AlterTableStmt_8
;
AlterTableStmt_1: ALTER TABLE relation_expr alter_table_cmds
AlterTableStmt_2: ALTER TABLE IF EXISTS relation_expr alter_table_cmds
AlterTableStmt_3: ALTER INDEX qualified_name alter_table_cmds
AlterTableStmt_4: ALTER INDEX IF EXISTS qualified_name alter_table_cmds
AlterTableStmt_5: ALTER SEQUENCE qualified_name alter_table_cmds
AlterTableStmt_6: ALTER SEQUENCE IF EXISTS qualified_name alter_table_cmds
AlterTableStmt_7: ALTER VIEW qualified_name alter_table_cmds
AlterTableStmt_8: ALTER VIEW IF EXISTS qualified_name alter_table_cmds

alter_table_cmds  :
     alter_table_cmds_1
   | alter_table_cmds_2
;
alter_table_cmds_1: alter_table_cmd
alter_table_cmds_2: alter_table_cmds <COMMA> alter_table_cmd  ### WARNING: Recursion; needs refactoring! ###

alter_table_cmd   :
     alter_table_cmd_1
   | alter_table_cmd_2
   | alter_table_cmd_3
   | alter_table_cmd_4
   | alter_table_cmd_5
   | alter_table_cmd_6
   | alter_table_cmd_7
   | alter_table_cmd_8
   | alter_table_cmd_9
   | alter_table_cmd_10
   | alter_table_cmd_11
   | alter_table_cmd_12
   | alter_table_cmd_13
   | alter_table_cmd_14
   | alter_table_cmd_15
   | alter_table_cmd_16
   | alter_table_cmd_17
   | alter_table_cmd_18
   | alter_table_cmd_19
   | alter_table_cmd_20
   | alter_table_cmd_21
   | alter_table_cmd_22
   | alter_table_cmd_23
   | alter_table_cmd_24
   | alter_table_cmd_25
   | alter_table_cmd_26
   | alter_table_cmd_27
   | alter_table_cmd_28
   | alter_table_cmd_29
   | alter_table_cmd_30
   | alter_table_cmd_31
   | alter_table_cmd_32
   | alter_table_cmd_33
   | alter_table_cmd_34
   | alter_table_cmd_35
   | alter_table_cmd_36
   | alter_table_cmd_37
   | alter_table_cmd_38
   | alter_table_cmd_39
   | alter_table_cmd_40
   | alter_table_cmd_41
   | alter_table_cmd_42
;
alter_table_cmd_1 : 
# ALTER TABLE <name> ADD <coldef>
    ADD columnDef
alter_table_cmd_2 : ADD COLUMN columnDef
alter_table_cmd_3 : ALTER opt_column ColId alter_column_default
alter_table_cmd_4 : ALTER opt_column ColId DROP NOT NULL
alter_table_cmd_5 : ALTER opt_column ColId SET NOT NULL
alter_table_cmd_6 : ALTER opt_column ColId SET STATISTICS SignedIconst
alter_table_cmd_7 : ALTER opt_column ColId SET reloptions
alter_table_cmd_8 : ALTER opt_column ColId RESET reloptions
alter_table_cmd_9 : ALTER opt_column ColId SET STORAGE ColId
alter_table_cmd_10: DROP opt_column IF EXISTS ColId opt_drop_behavior
alter_table_cmd_11: DROP opt_column ColId opt_drop_behavior
alter_table_cmd_12: ALTER opt_column ColId opt_set_data TYPE Typename opt_collate_clause alter_using
alter_table_cmd_13: ALTER opt_column ColId alter_generic_options
alter_table_cmd_14: ADD TableConstraint
alter_table_cmd_15: VALIDATE CONSTRAINT name
alter_table_cmd_16: DROP CONSTRAINT IF EXISTS name opt_drop_behavior
alter_table_cmd_17: DROP CONSTRAINT name opt_drop_behavior
alter_table_cmd_18: SET WITH OIDS
alter_table_cmd_19: SET WITHOUT OIDS
alter_table_cmd_20: CLUSTER ON name
alter_table_cmd_21: SET WITHOUT CLUSTER
alter_table_cmd_22: ENABLE TRIGGER name
alter_table_cmd_23: ENABLE ALWAYS TRIGGER name
alter_table_cmd_24: ENABLE REPLICA TRIGGER name
alter_table_cmd_25: ENABLE TRIGGER ALL
alter_table_cmd_26: ENABLE TRIGGER USER
alter_table_cmd_27: DISABLE TRIGGER name
alter_table_cmd_28: DISABLE TRIGGER ALL
alter_table_cmd_29: DISABLE TRIGGER USER
alter_table_cmd_30: ENABLE RULE name
alter_table_cmd_31: ENABLE ALWAYS RULE name
alter_table_cmd_32: ENABLE REPLICA RULE name
alter_table_cmd_33: DISABLE RULE name
alter_table_cmd_34: INHERIT qualified_name
alter_table_cmd_35: NO INHERIT qualified_name
alter_table_cmd_36: OF any_name
alter_table_cmd_37: NOT OF
alter_table_cmd_38: OWNER TO RoleId
alter_table_cmd_39: SET TABLESPACE name
alter_table_cmd_40: SET reloptions
alter_table_cmd_41: RESET reloptions
alter_table_cmd_42: alter_generic_options

alter_column_default  :
     alter_column_default_1
   | alter_column_default_2
;
alter_column_default_1: SET DEFAULT a_expr
alter_column_default_2: DROP DEFAULT

opt_drop_behavior  : (
     opt_drop_behavior_1
   | opt_drop_behavior_2
)?
opt_drop_behavior_1: CASCADE
opt_drop_behavior_2: RESTRICT

opt_collate_clause  : opt_collate_clause_1?
opt_collate_clause_1: COLLATE any_name

alter_using  : alter_using_1?
alter_using_1: USING a_expr

reloptions: <LPAREN> reloption_list <RPAREN>

opt_reloptions  : opt_reloptions_1?
opt_reloptions_1: WITH reloptions

reloption_list  :
     reloption_list_1
   | reloption_list_2
;
reloption_list_1: reloption_elem
reloption_list_2: reloption_list <COMMA> reloption_elem  ### WARNING: Recursion; needs refactoring! ###

# This should match def_elem and also allow qualified names
reloption_elem  :
     reloption_elem_1
   | reloption_elem_2
   | reloption_elem_3
   | reloption_elem_4
;
reloption_elem_1: ColLabel <EQUAL> def_arg
reloption_elem_2: ColLabel
reloption_elem_3: ColLabel <DOT> ColLabel <EQUAL> def_arg
reloption_elem_4: ColLabel <DOT> ColLabel

#############################################################################
#
#   ALTER TYPE
#
# really variants of the ALTER TABLE subcommands with different spellings
#############################################################################
AlterCompositeTypeStmt: ALTER TYPE any_name alter_type_cmds

alter_type_cmds  :
     alter_type_cmds_1
   | alter_type_cmds_2
;
alter_type_cmds_1: alter_type_cmd
alter_type_cmds_2: alter_type_cmds <COMMA> alter_type_cmd  ### WARNING: Recursion; needs refactoring! ###

alter_type_cmd  :
     alter_type_cmd_1
   | alter_type_cmd_2
   | alter_type_cmd_3
   | alter_type_cmd_4
;
alter_type_cmd_1: 
# ALTER TYPE <name> ADD ATTRIBUTE <coldef> [RESTRICT|CASCADE]
    ADD ATTRIBUTE TableFuncElement opt_drop_behavior
alter_type_cmd_2: DROP ATTRIBUTE IF EXISTS ColId opt_drop_behavior
alter_type_cmd_3: DROP ATTRIBUTE ColId opt_drop_behavior
alter_type_cmd_4: ALTER ATTRIBUTE ColId opt_set_data TYPE Typename opt_collate_clause opt_drop_behavior

#############################################################################
#
#      QUERY :
#            close <portalname>
#
#############################################################################
ClosePortalStmt  :
     ClosePortalStmt_1
   | ClosePortalStmt_2
;
ClosePortalStmt_1: CLOSE cursor_name
ClosePortalStmt_2: CLOSE ALL

#############################################################################
#
#      QUERY :
#            COPY relname [(columnList)] FROM/TO file [WITH] [(options)]
#            COPY ( SELECT ... ) TO file [WITH] [(options)]
#
#            In the preferred syntax the options are comma-separated
#            and use generic identifiers instead of keywords.  The pre-9.0
#            syntax had a hard-wired, space-separated set of options.
#
#            Really old syntax, from versions 7.2 and prior:
#            COPY [ BINARY ] table [ WITH OIDS ] FROM/TO file
#               [ [ USING ] DELIMITERS 'delimiter' ] ]
#               [ WITH NULL AS 'null string' ]
#            This option placement is not supported with COPY (SELECT...).
#
#############################################################################
CopyStmt  :
     CopyStmt_1
   | CopyStmt_2
;
CopyStmt_1: COPY opt_binary qualified_name opt_column_list opt_oids copy_from copy_file_name copy_delimiter opt_with copy_options
CopyStmt_2: COPY select_with_parens TO copy_file_name opt_with copy_options

copy_from  :
     copy_from_1
   | copy_from_2
;
copy_from_1: FROM
copy_from_2: TO

# copy_file_name NULL indicates stdio is used. Whether stdin or stdout is
# used depends on the direction. (It really doesn't make sense to copy from
# stdout. We silently correct the "typo".)       - AY 9/94
copy_file_name  :
     copy_file_name_1
   | copy_file_name_2
   | copy_file_name_3
;
copy_file_name_1: Sconst
copy_file_name_2: STDIN
copy_file_name_3: STDOUT

copy_options  :
     copy_options_1
   | copy_options_2
;
copy_options_1: copy_opt_list
copy_options_2: <LPAREN> copy_generic_opt_list <RPAREN>

# old COPY option syntax
copy_opt_list  : copy_opt_list_1?
copy_opt_list_1: copy_opt_list copy_opt_item  ### WARNING: Recursion; needs refactoring! ###

copy_opt_item   :
     copy_opt_item_1
   | copy_opt_item_2
   | copy_opt_item_3
   | copy_opt_item_4
   | copy_opt_item_5
   | copy_opt_item_6
   | copy_opt_item_7
   | copy_opt_item_8
   | copy_opt_item_9
   | copy_opt_item_10
   | copy_opt_item_11
   | copy_opt_item_12
;
copy_opt_item_1 : BINARY
copy_opt_item_2 : OIDS
copy_opt_item_3 : DELIMITER opt_as Sconst
copy_opt_item_4 : NULL opt_as Sconst
copy_opt_item_5 : CSV
copy_opt_item_6 : HEADER
copy_opt_item_7 : QUOTE opt_as Sconst
copy_opt_item_8 : ESCAPE opt_as Sconst
copy_opt_item_9 : FORCE QUOTE columnList
copy_opt_item_10: FORCE QUOTE <STAR>
copy_opt_item_11: FORCE NOT NULL columnList
copy_opt_item_12: ENCODING Sconst

# The following exist for backward compatibility with very old versions
opt_binary  : opt_binary_1?
opt_binary_1: BINARY

opt_oids  : opt_oids_1?
opt_oids_1: WITH OIDS

copy_delimiter  : copy_delimiter_1?
copy_delimiter_1: opt_using DELIMITERS Sconst

opt_using  : opt_using_1?
opt_using_1: USING

# new COPY option syntax
copy_generic_opt_list  :
     copy_generic_opt_list_1
   | copy_generic_opt_list_2
;
copy_generic_opt_list_1: copy_generic_opt_elem
copy_generic_opt_list_2: copy_generic_opt_list <COMMA> copy_generic_opt_elem  ### WARNING: Recursion; needs refactoring! ###

copy_generic_opt_elem: ColLabel copy_generic_opt_arg

copy_generic_opt_arg  : (
     copy_generic_opt_arg_1
   | copy_generic_opt_arg_2
   | copy_generic_opt_arg_3
   | copy_generic_opt_arg_4
)?
copy_generic_opt_arg_1: opt_boolean_or_string
copy_generic_opt_arg_2: NumericOnly
copy_generic_opt_arg_3: <STAR>
copy_generic_opt_arg_4: <LPAREN> copy_generic_opt_arg_list <RPAREN>

copy_generic_opt_arg_list  :
     copy_generic_opt_arg_list_1
   | copy_generic_opt_arg_list_2
;
copy_generic_opt_arg_list_1: copy_generic_opt_arg_list_item
copy_generic_opt_arg_list_2: copy_generic_opt_arg_list <COMMA> copy_generic_opt_arg_list_item  ### WARNING: Recursion; needs refactoring! ###

# beware of emitting non-string list elements here; see commands/define.c
copy_generic_opt_arg_list_item: opt_boolean_or_string

#############################################################################
#
#      QUERY :
#            CREATE TABLE relname
#
#############################################################################
CreateStmt  :
     CreateStmt_1
   | CreateStmt_2
   | CreateStmt_3
   | CreateStmt_4
;
CreateStmt_1: CREATE OptTemp TABLE qualified_name <LPAREN> OptTableElementList <RPAREN> OptInherit OptWith OnCommitOption OptTableSpace
CreateStmt_2: CREATE OptTemp TABLE IF NOT EXISTS qualified_name <LPAREN> OptTableElementList <RPAREN> OptInherit OptWith OnCommitOption OptTableSpace
CreateStmt_3: CREATE OptTemp TABLE qualified_name OF any_name OptTypedTableElementList OptWith OnCommitOption OptTableSpace
CreateStmt_4: CREATE OptTemp TABLE IF NOT EXISTS qualified_name OF any_name OptTypedTableElementList OptWith OnCommitOption OptTableSpace

# Redundancy here is needed to avoid shift/reduce conflicts,
# since TEMP is not a reserved word.  See also OptTempTableName.
#
# NOTE: we accept both GLOBAL and LOCAL options; since we have no modules
# the LOCAL keyword is really meaningless.
OptTemp  : (
     OptTemp_1
   | OptTemp_2
   | OptTemp_3
   | OptTemp_4
   | OptTemp_5
   | OptTemp_6
   | OptTemp_7
)?
OptTemp_1: TEMPORARY
OptTemp_2: TEMP
OptTemp_3: LOCAL TEMPORARY
OptTemp_4: LOCAL TEMP
OptTemp_5: GLOBAL TEMPORARY
OptTemp_6: GLOBAL TEMP
OptTemp_7: UNLOGGED

OptTableElementList  : OptTableElementList_1?
OptTableElementList_1: TableElementList

OptTypedTableElementList  : OptTypedTableElementList_1?
OptTypedTableElementList_1: <LPAREN> TypedTableElementList <RPAREN>

TableElementList  :
     TableElementList_1
   | TableElementList_2
;
TableElementList_1: TableElement
TableElementList_2: TableElementList <COMMA> TableElement  ### WARNING: Recursion; needs refactoring! ###

TypedTableElementList  :
     TypedTableElementList_1
   | TypedTableElementList_2
;
TypedTableElementList_1: TypedTableElement
TypedTableElementList_2: TypedTableElementList <COMMA> TypedTableElement  ### WARNING: Recursion; needs refactoring! ###

TableElement  :
     TableElement_1
   | TableElement_2
   | TableElement_3
;
TableElement_1: columnDef
TableElement_2: TableLikeClause
TableElement_3: TableConstraint

TypedTableElement  :
     TypedTableElement_1
   | TypedTableElement_2
;
TypedTableElement_1: columnOptions
TypedTableElement_2: TableConstraint

columnDef: ColId Typename create_generic_options ColQualList

columnOptions: ColId WITH OPTIONS ColQualList

ColQualList  : ColQualList_1?
ColQualList_1: ColQualList ColConstraint  ### WARNING: Recursion; needs refactoring! ###

ColConstraint  :
     ColConstraint_1
   | ColConstraint_2
   | ColConstraint_3
   | ColConstraint_4
;
ColConstraint_1: CONSTRAINT name ColConstraintElem
ColConstraint_2: ColConstraintElem
ColConstraint_3: ConstraintAttr
ColConstraint_4: COLLATE any_name

# DEFAULT NULL is already the default for Postgres.
# But define it here and carry it forward into the system
# to make it explicit.
# - thomas 1998-09-13
#
# WITH NULL and NULL are not SQL92-standard syntax elements,
# so leave them out. Use DEFAULT NULL to explicitly indicate
# that a column may have that value. WITH NULL leads to
# shift/reduce conflicts with WITH TIME ZONE anyway.
# - thomas 1999-01-08
#
# DEFAULT expression must be b_expr not a_expr to prevent shift/reduce
# conflict on NOT (since NOT might start a subsequent NOT NULL constraint,
# or be part of a_expr NOT LIKE or similar constructs).
ColConstraintElem  :
     ColConstraintElem_1
   | ColConstraintElem_2
   | ColConstraintElem_3
   | ColConstraintElem_4
   | ColConstraintElem_5
   | ColConstraintElem_6
   | ColConstraintElem_7
;
ColConstraintElem_1: NOT NULL
ColConstraintElem_2: NULL
ColConstraintElem_3: UNIQUE opt_definition OptConsTableSpace
ColConstraintElem_4: PRIMARY KEY opt_definition OptConsTableSpace
ColConstraintElem_5: CHECK <LPAREN> a_expr <RPAREN> opt_no_inherit
ColConstraintElem_6: DEFAULT b_expr
ColConstraintElem_7: REFERENCES qualified_name opt_column_list key_match key_actions

# ConstraintAttr represents constraint attributes, which we parse as if
# they were independent constraint clauses, in order to avoid shift/reduce
# conflicts (since NOT might start either an independent NOT NULL clause
# or an attribute).  parse_utilcmd.c is responsible for attaching the
# attribute information to the preceding "real" constraint node, and for
# complaining if attribute clauses appear in the wrong place or wrong
# combinations.
#
# See also ConstraintAttributeSpec, which can be used in places where
# there is no parsing conflict.  (Note: currently, NOT VALID and NO INHERIT
# are allowed clauses in ConstraintAttributeSpec, but not here.  Someday we
# might need to allow them here too, but for the moment it doesn't seem
# useful in the statements that use ConstraintAttr.)
ConstraintAttr  :
     ConstraintAttr_1
   | ConstraintAttr_2
   | ConstraintAttr_3
   | ConstraintAttr_4
;
ConstraintAttr_1: DEFERRABLE
ConstraintAttr_2: NOT DEFERRABLE
ConstraintAttr_3: INITIALLY DEFERRED
ConstraintAttr_4: INITIALLY IMMEDIATE

TableLikeClause: LIKE qualified_name TableLikeOptionList

TableLikeOptionList  : (
     TableLikeOptionList_1
   | TableLikeOptionList_2
)?
TableLikeOptionList_1: TableLikeOptionList INCLUDING TableLikeOption  ### WARNING: Recursion; needs refactoring! ###
TableLikeOptionList_2: TableLikeOptionList EXCLUDING TableLikeOption  ### WARNING: Recursion; needs refactoring! ###

TableLikeOption  :
     TableLikeOption_1
   | TableLikeOption_2
   | TableLikeOption_3
   | TableLikeOption_4
   | TableLikeOption_5
   | TableLikeOption_6
;
TableLikeOption_1: DEFAULTS
TableLikeOption_2: CONSTRAINTS
TableLikeOption_3: INDEXES
TableLikeOption_4: STORAGE
TableLikeOption_5: COMMENTS
TableLikeOption_6: ALL

# ConstraintElem specifies constraint syntax which is not embedded into
#   a column definition. ColConstraintElem specifies the embedded form.
# - thomas 1997-12-03
TableConstraint  :
     TableConstraint_1
   | TableConstraint_2
;
TableConstraint_1: CONSTRAINT name ConstraintElem
TableConstraint_2: ConstraintElem

ConstraintElem  :
     ConstraintElem_1
   | ConstraintElem_2
   | ConstraintElem_3
   | ConstraintElem_4
   | ConstraintElem_5
   | ConstraintElem_6
   | ConstraintElem_7
;
ConstraintElem_1: CHECK <LPAREN> a_expr <RPAREN> ConstraintAttributeSpec
ConstraintElem_2: UNIQUE <LPAREN> columnList <RPAREN> opt_definition OptConsTableSpace ConstraintAttributeSpec
ConstraintElem_3: UNIQUE ExistingIndex ConstraintAttributeSpec
ConstraintElem_4: PRIMARY KEY <LPAREN> columnList <RPAREN> opt_definition OptConsTableSpace ConstraintAttributeSpec
ConstraintElem_5: PRIMARY KEY ExistingIndex ConstraintAttributeSpec
ConstraintElem_6: EXCLUDE access_method_clause <LPAREN> ExclusionConstraintList <RPAREN> opt_definition OptConsTableSpace ExclusionWhereClause ConstraintAttributeSpec
ConstraintElem_7: FOREIGN KEY <LPAREN> columnList <RPAREN> REFERENCES qualified_name opt_column_list key_match key_actions ConstraintAttributeSpec

opt_no_inherit  : opt_no_inherit_1?
opt_no_inherit_1: NO INHERIT

opt_column_list  : opt_column_list_1?
opt_column_list_1: <LPAREN> columnList <RPAREN>

columnList  :
     columnList_1
   | columnList_2
;
columnList_1: columnElem
columnList_2: columnList <COMMA> columnElem  ### WARNING: Recursion; needs refactoring! ###

columnElem: ColId

key_match  : (
     key_match_1
   | key_match_2
   | key_match_3
)?
key_match_1: MATCH FULL
key_match_2: MATCH PARTIAL
key_match_3: MATCH SIMPLE

ExclusionConstraintList  :
     ExclusionConstraintList_1
   | ExclusionConstraintList_2
;
ExclusionConstraintList_1: ExclusionConstraintElem
ExclusionConstraintList_2: ExclusionConstraintList <COMMA> ExclusionConstraintElem  ### WARNING: Recursion; needs refactoring! ###

ExclusionConstraintElem  :
     ExclusionConstraintElem_1
   | ExclusionConstraintElem_2
;
ExclusionConstraintElem_1: index_elem WITH any_operator
ExclusionConstraintElem_2: index_elem WITH OPERATOR <LPAREN> any_operator <RPAREN>

ExclusionWhereClause  : ExclusionWhereClause_1?
ExclusionWhereClause_1: WHERE <LPAREN> a_expr <RPAREN>

# We combine the update and delete actions into one value temporarily
# for simplicity of parsing, and then break them down again in the
# calling production.  update is in the left 8 bits, delete in the right.
# Note that NOACTION is the default.
key_actions  : (
     key_actions_1
   | key_actions_2
   | key_actions_3
   | key_actions_4
)?
key_actions_1: key_update
key_actions_2: key_delete
key_actions_3: key_update key_delete
key_actions_4: key_delete key_update

key_update: ON UPDATE key_action

key_delete: ON DELETE key_action

key_action  :
     key_action_1
   | key_action_2
   | key_action_3
   | key_action_4
   | key_action_5
;
key_action_1: NO ACTION
key_action_2: RESTRICT
key_action_3: CASCADE
key_action_4: SET NULL
key_action_5: SET DEFAULT

OptInherit  : OptInherit_1?
OptInherit_1: INHERITS <LPAREN> qualified_name_list <RPAREN>

# WITH (options) is preferred, WITH OIDS and WITHOUT OIDS are legacy forms
OptWith  : (
     OptWith_1
   | OptWith_2
   | OptWith_3
)?
OptWith_1: WITH reloptions
OptWith_2: WITH OIDS
OptWith_3: WITHOUT OIDS

OnCommitOption  : (
     OnCommitOption_1
   | OnCommitOption_2
   | OnCommitOption_3
)?
OnCommitOption_1: ON COMMIT DROP
OnCommitOption_2: ON COMMIT DELETE ROWS
OnCommitOption_3: ON COMMIT PRESERVE ROWS

OptTableSpace  : OptTableSpace_1?
OptTableSpace_1: TABLESPACE name

OptConsTableSpace  : OptConsTableSpace_1?
OptConsTableSpace_1: USING INDEX TABLESPACE name

ExistingIndex: USING INDEX index_name

#############################################################################
#
#		QUERY :
#				CREATE TABLE relname AS SelectStmt [ WITH [NO] DATA ]
#
#
# Note: SELECT ... INTO is a now-deprecated alternative for this.
#
#############################################################################
CreateAsStmt: CREATE OptTemp TABLE create_as_target AS SelectStmt opt_with_data

create_as_target: qualified_name opt_column_list OptWith OnCommitOption OptTableSpace

opt_with_data  : (
     opt_with_data_1
   | opt_with_data_2
)?
opt_with_data_1: WITH DATA
opt_with_data_2: WITH NO DATA

#############################################################################
#
#      QUERY :
#            CREATE SEQUENCE seqname
#            ALTER SEQUENCE seqname
#
#############################################################################
CreateSeqStmt: CREATE OptTemp SEQUENCE qualified_name OptSeqOptList

AlterSeqStmt: ALTER SEQUENCE qualified_name SeqOptList

OptSeqOptList  : OptSeqOptList_1?
OptSeqOptList_1: SeqOptList

SeqOptList  :
     SeqOptList_1
   | SeqOptList_2
;
SeqOptList_1: SeqOptElem
SeqOptList_2: SeqOptList SeqOptElem  ### WARNING: Recursion; needs refactoring! ###

SeqOptElem   :
     SeqOptElem_1
   | SeqOptElem_2
   | SeqOptElem_3
   | SeqOptElem_4
   | SeqOptElem_5
   | SeqOptElem_6
   | SeqOptElem_7
   | SeqOptElem_8
   | SeqOptElem_9
   | SeqOptElem_10
   | SeqOptElem_11
   | SeqOptElem_12
;
SeqOptElem_1 : CACHE NumericOnly
SeqOptElem_2 : CYCLE
SeqOptElem_3 : NO CYCLE
SeqOptElem_4 : INCREMENT opt_by NumericOnly
SeqOptElem_5 : MAXVALUE NumericOnly
SeqOptElem_6 : MINVALUE NumericOnly
SeqOptElem_7 : NO MAXVALUE
SeqOptElem_8 : NO MINVALUE
SeqOptElem_9 : OWNED BY any_name
SeqOptElem_10: START opt_with NumericOnly
SeqOptElem_11: RESTART
SeqOptElem_12: RESTART opt_with NumericOnly

opt_by  : opt_by_1?
opt_by_1: BY

NumericOnly  :
     NumericOnly_1
   | NumericOnly_2
   | NumericOnly_3
;
NumericOnly_1: FCONST
NumericOnly_2: <DASH> FCONST
NumericOnly_3: SignedIconst

NumericOnly_list  :
     NumericOnly_list_1
   | NumericOnly_list_2
;
NumericOnly_list_1: NumericOnly
NumericOnly_list_2: NumericOnly_list <COMMA> NumericOnly  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
#
#      QUERIES :
#            CREATE [OR REPLACE] [TRUSTED] [PROCEDURAL] LANGUAGE ...
#            DROP [PROCEDURAL] LANGUAGE ...
#
#############################################################################
CreatePLangStmt  :
     CreatePLangStmt_1
   | CreatePLangStmt_2
;
CreatePLangStmt_1: CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst
CreatePLangStmt_2: CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst HANDLER handler_name opt_inline_handler opt_validator

opt_trusted  : opt_trusted_1?
opt_trusted_1: TRUSTED

# This ought to be just func_name, but that causes reduce/reduce conflicts
# (CREATE LANGUAGE is the only place where func_name isn't followed by '(').
# Work around by using simple names, instead.
handler_name  :
     handler_name_1
   | handler_name_2
;
handler_name_1: name
handler_name_2: name attrs

opt_inline_handler  : opt_inline_handler_1?
opt_inline_handler_1: INLINE handler_name

validator_clause  :
     validator_clause_1
   | validator_clause_2
;
validator_clause_1: VALIDATOR handler_name
validator_clause_2: NO VALIDATOR

opt_validator  : opt_validator_1?
opt_validator_1: validator_clause

DropPLangStmt  :
     DropPLangStmt_1
   | DropPLangStmt_2
;
DropPLangStmt_1: DROP opt_procedural LANGUAGE ColId_or_Sconst opt_drop_behavior
DropPLangStmt_2: DROP opt_procedural LANGUAGE IF EXISTS ColId_or_Sconst opt_drop_behavior

opt_procedural  : opt_procedural_1?
opt_procedural_1: PROCEDURAL

#############################################################################
#
#       QUERY:
#             CREATE TABLESPACE tablespace LOCATION '/path/to/tablespace/''
#
#############################################################################
CreateTableSpaceStmt: CREATE TABLESPACE name OptTableSpaceOwner LOCATION Sconst

OptTableSpaceOwner  : OptTableSpaceOwner_1?
OptTableSpaceOwner_1: OWNER name

#############################################################################
#
#       QUERY :
#            DROP TABLESPACE <tablespace>
#
#      No need for drop behaviour as we cannot implement dependencies for
#      objects in other databases; we can only support RESTRICT.
#
############################################################################
DropTableSpaceStmt  :
     DropTableSpaceStmt_1
   | DropTableSpaceStmt_2
;
DropTableSpaceStmt_1: DROP TABLESPACE name
DropTableSpaceStmt_2: DROP TABLESPACE IF EXISTS name

#############################################################################
#
#       QUERY:
#             CREATE EXTENSION extension
#             [ WITH ] [ SCHEMA schema ] [ VERSION version ] [ FROM oldversion ]
#
#############################################################################
CreateExtensionStmt  :
     CreateExtensionStmt_1
   | CreateExtensionStmt_2
;
CreateExtensionStmt_1: CREATE EXTENSION name opt_with create_extension_opt_list
CreateExtensionStmt_2: CREATE EXTENSION IF NOT EXISTS name opt_with create_extension_opt_list

create_extension_opt_list  : create_extension_opt_list_1?
create_extension_opt_list_1: create_extension_opt_list create_extension_opt_item  ### WARNING: Recursion; needs refactoring! ###

create_extension_opt_item  :
     create_extension_opt_item_1
   | create_extension_opt_item_2
   | create_extension_opt_item_3
;
create_extension_opt_item_1: SCHEMA name
create_extension_opt_item_2: VERSION ColId_or_Sconst
create_extension_opt_item_3: FROM ColId_or_Sconst

#############################################################################
#
# ALTER EXTENSION name UPDATE [ TO version ]
#
#############################################################################
AlterExtensionStmt: ALTER EXTENSION name UPDATE alter_extension_opt_list

alter_extension_opt_list  : alter_extension_opt_list_1?
alter_extension_opt_list_1: alter_extension_opt_list alter_extension_opt_item  ### WARNING: Recursion; needs refactoring! ###

alter_extension_opt_item: TO ColId_or_Sconst

#############################################################################
#
# ALTER EXTENSION name ADD/DROP object-identifier
#
#############################################################################
AlterExtensionContentsStmt   :
     AlterExtensionContentsStmt_1
   | AlterExtensionContentsStmt_2
   | AlterExtensionContentsStmt_3
   | AlterExtensionContentsStmt_4
   | AlterExtensionContentsStmt_5
   | AlterExtensionContentsStmt_6
   | AlterExtensionContentsStmt_7
   | AlterExtensionContentsStmt_8
   | AlterExtensionContentsStmt_9
   | AlterExtensionContentsStmt_10
   | AlterExtensionContentsStmt_11
   | AlterExtensionContentsStmt_12
   | AlterExtensionContentsStmt_13
   | AlterExtensionContentsStmt_14
   | AlterExtensionContentsStmt_15
   | AlterExtensionContentsStmt_16
   | AlterExtensionContentsStmt_17
   | AlterExtensionContentsStmt_18
   | AlterExtensionContentsStmt_19
   | AlterExtensionContentsStmt_20
   | AlterExtensionContentsStmt_21
   | AlterExtensionContentsStmt_22
;
AlterExtensionContentsStmt_1 : ALTER EXTENSION name add_drop AGGREGATE func_name aggr_args
AlterExtensionContentsStmt_2 : ALTER EXTENSION name add_drop CAST <LPAREN> Typename AS Typename <RPAREN>
AlterExtensionContentsStmt_3 : ALTER EXTENSION name add_drop COLLATION any_name
AlterExtensionContentsStmt_4 : ALTER EXTENSION name add_drop CONVERSION any_name
AlterExtensionContentsStmt_5 : ALTER EXTENSION name add_drop DOMAIN any_name
AlterExtensionContentsStmt_6 : ALTER EXTENSION name add_drop FUNCTION function_with_argtypes
AlterExtensionContentsStmt_7 : ALTER EXTENSION name add_drop opt_procedural LANGUAGE name
AlterExtensionContentsStmt_8 : ALTER EXTENSION name add_drop OPERATOR any_operator oper_argtypes
AlterExtensionContentsStmt_9 : ALTER EXTENSION name add_drop OPERATOR CLASS any_name USING access_method
AlterExtensionContentsStmt_10: ALTER EXTENSION name add_drop OPERATOR FAMILY any_name USING access_method
AlterExtensionContentsStmt_11: ALTER EXTENSION name add_drop SCHEMA name
AlterExtensionContentsStmt_12: ALTER EXTENSION name add_drop TABLE any_name
AlterExtensionContentsStmt_13: ALTER EXTENSION name add_drop TEXT SEARCH PARSER any_name
AlterExtensionContentsStmt_14: ALTER EXTENSION name add_drop TEXT SEARCH DICTIONARY any_name
AlterExtensionContentsStmt_15: ALTER EXTENSION name add_drop TEXT SEARCH TEMPLATE any_name
AlterExtensionContentsStmt_16: ALTER EXTENSION name add_drop TEXT SEARCH CONFIGURATION any_name
AlterExtensionContentsStmt_17: ALTER EXTENSION name add_drop SEQUENCE any_name
AlterExtensionContentsStmt_18: ALTER EXTENSION name add_drop VIEW any_name
AlterExtensionContentsStmt_19: ALTER EXTENSION name add_drop FOREIGN TABLE any_name
AlterExtensionContentsStmt_20: ALTER EXTENSION name add_drop FOREIGN DATA WRAPPER name
AlterExtensionContentsStmt_21: ALTER EXTENSION name add_drop SERVER name
AlterExtensionContentsStmt_22: ALTER EXTENSION name add_drop TYPE any_name

#############################################################################
#
#       QUERY:
#             CREATE FOREIGN DATA WRAPPER name options
#
#############################################################################
CreateFdwStmt: CREATE FOREIGN DATA WRAPPER name opt_fdw_options create_generic_options

fdw_option  :
     fdw_option_1
   | fdw_option_2
   | fdw_option_3
   | fdw_option_4
;
fdw_option_1: HANDLER handler_name
fdw_option_2: NO HANDLER
fdw_option_3: VALIDATOR handler_name
fdw_option_4: NO VALIDATOR

fdw_options  :
     fdw_options_1
   | fdw_options_2
;
fdw_options_1: fdw_option
fdw_options_2: fdw_options fdw_option  ### WARNING: Recursion; needs refactoring! ###

opt_fdw_options  : opt_fdw_options_1?
opt_fdw_options_1: fdw_options

#############################################################################
#
#       QUERY :
#            DROP FOREIGN DATA WRAPPER name
#
############################################################################
DropFdwStmt  :
     DropFdwStmt_1
   | DropFdwStmt_2
;
DropFdwStmt_1: DROP FOREIGN DATA WRAPPER name opt_drop_behavior
DropFdwStmt_2: DROP FOREIGN DATA WRAPPER IF EXISTS name opt_drop_behavior

#############################################################################
#
#       QUERY :
#            ALTER FOREIGN DATA WRAPPER name options
#
############################################################################
AlterFdwStmt  :
     AlterFdwStmt_1
   | AlterFdwStmt_2
;
AlterFdwStmt_1: ALTER FOREIGN DATA WRAPPER name opt_fdw_options alter_generic_options
AlterFdwStmt_2: ALTER FOREIGN DATA WRAPPER name fdw_options

# Options definition for CREATE FDW, SERVER and USER MAPPING
create_generic_options  : create_generic_options_1?
create_generic_options_1: OPTIONS <LPAREN> generic_option_list <RPAREN>

generic_option_list  :
     generic_option_list_1
   | generic_option_list_2
;
generic_option_list_1: generic_option_elem
generic_option_list_2: generic_option_list <COMMA> generic_option_elem  ### WARNING: Recursion; needs refactoring! ###

# Options definition for ALTER FDW, SERVER and USER MAPPING
alter_generic_options: OPTIONS <LPAREN> alter_generic_option_list <RPAREN>

alter_generic_option_list  :
     alter_generic_option_list_1
   | alter_generic_option_list_2
;
alter_generic_option_list_1: alter_generic_option_elem
alter_generic_option_list_2: alter_generic_option_list <COMMA> alter_generic_option_elem  ### WARNING: Recursion; needs refactoring! ###

alter_generic_option_elem  :
     alter_generic_option_elem_1
   | alter_generic_option_elem_2
   | alter_generic_option_elem_3
   | alter_generic_option_elem_4
;
alter_generic_option_elem_1: generic_option_elem
alter_generic_option_elem_2: SET generic_option_elem
alter_generic_option_elem_3: ADD generic_option_elem
alter_generic_option_elem_4: DROP generic_option_name

generic_option_elem: generic_option_name generic_option_arg

generic_option_name: ColLabel

# We could use def_arg here, but the spec only requires string literals
generic_option_arg: Sconst

#############################################################################
#
#       QUERY:
#             CREATE SERVER name [TYPE] [VERSION] [OPTIONS]
#
#############################################################################
CreateForeignServerStmt: CREATE SERVER name opt_type opt_foreign_server_version FOREIGN DATA WRAPPER name create_generic_options

opt_type  : opt_type_1?
opt_type_1: TYPE Sconst

foreign_server_version  :
     foreign_server_version_1
   | foreign_server_version_2
;
foreign_server_version_1: VERSION Sconst
foreign_server_version_2: VERSION NULL

opt_foreign_server_version  : opt_foreign_server_version_1?
opt_foreign_server_version_1: foreign_server_version

#############################################################################
#
#       QUERY :
#            DROP SERVER name
#
############################################################################
DropForeignServerStmt  :
     DropForeignServerStmt_1
   | DropForeignServerStmt_2
;
DropForeignServerStmt_1: DROP SERVER name opt_drop_behavior
DropForeignServerStmt_2: DROP SERVER IF EXISTS name opt_drop_behavior

#############################################################################
#
#       QUERY :
#            ALTER SERVER name [VERSION] [OPTIONS]
#
############################################################################
AlterForeignServerStmt  :
     AlterForeignServerStmt_1
   | AlterForeignServerStmt_2
   | AlterForeignServerStmt_3
;
AlterForeignServerStmt_1: ALTER SERVER name foreign_server_version alter_generic_options
AlterForeignServerStmt_2: ALTER SERVER name foreign_server_version
AlterForeignServerStmt_3: ALTER SERVER name alter_generic_options

#############################################################################
#
#       QUERY:
#             CREATE FOREIGN TABLE relname (...) SERVER name (...)
#
#############################################################################
CreateForeignTableStmt  :
     CreateForeignTableStmt_1
   | CreateForeignTableStmt_2
;
CreateForeignTableStmt_1: CREATE FOREIGN TABLE qualified_name OptForeignTableElementList SERVER name create_generic_options
CreateForeignTableStmt_2: CREATE FOREIGN TABLE IF NOT EXISTS qualified_name OptForeignTableElementList SERVER name create_generic_options

OptForeignTableElementList  :
     OptForeignTableElementList_1
   | OptForeignTableElementList_2
;
OptForeignTableElementList_1: <LPAREN> ForeignTableElementList <RPAREN>
OptForeignTableElementList_2: <LPAREN> <RPAREN>

ForeignTableElementList  :
     ForeignTableElementList_1
   | ForeignTableElementList_2
;
ForeignTableElementList_1: ForeignTableElement
ForeignTableElementList_2: ForeignTableElementList <COMMA> ForeignTableElement  ### WARNING: Recursion; needs refactoring! ###

ForeignTableElement: columnDef

#############################################################################
#
#       QUERY:
#             ALTER FOREIGN TABLE relname [...]
#
#############################################################################
AlterForeignTableStmt: ALTER FOREIGN TABLE relation_expr alter_table_cmds

#############################################################################
#
#       QUERY:
#             CREATE USER MAPPING FOR auth_ident SERVER name [OPTIONS]
#
#############################################################################
CreateUserMappingStmt: CREATE USER MAPPING FOR auth_ident SERVER name create_generic_options

# User mapping authorization identifier
auth_ident  :
     auth_ident_1
   | auth_ident_2
   | auth_ident_3
;
auth_ident_1: CURRENT_USER
auth_ident_2: USER
auth_ident_3: RoleId

#############################################################################
#
#       QUERY :
#            DROP USER MAPPING FOR auth_ident SERVER name
#
############################################################################
DropUserMappingStmt  :
     DropUserMappingStmt_1
   | DropUserMappingStmt_2
;
DropUserMappingStmt_1: DROP USER MAPPING FOR auth_ident SERVER name
DropUserMappingStmt_2: DROP USER MAPPING IF EXISTS FOR auth_ident SERVER name

#############################################################################
#
#       QUERY :
#            ALTER USER MAPPING FOR auth_ident SERVER name OPTIONS
#
############################################################################
AlterUserMappingStmt: ALTER USER MAPPING FOR auth_ident SERVER name alter_generic_options

#############################################################################
#
#      QUERIES :
#            CREATE TRIGGER ...
#            DROP TRIGGER ...
#
#############################################################################
CreateTrigStmt  :
     CreateTrigStmt_1
   | CreateTrigStmt_2
;
CreateTrigStmt_1: CREATE TRIGGER name TriggerActionTime TriggerEvents ON qualified_name TriggerForSpec TriggerWhen EXECUTE PROCEDURE func_name <LPAREN> TriggerFuncArgs <RPAREN>
CreateTrigStmt_2: CREATE CONSTRAINT TRIGGER name AFTER TriggerEvents ON qualified_name OptConstrFromTable ConstraintAttributeSpec FOR EACH ROW TriggerWhen EXECUTE PROCEDURE func_name <LPAREN> TriggerFuncArgs <RPAREN>

TriggerActionTime  :
     TriggerActionTime_1
   | TriggerActionTime_2
   | TriggerActionTime_3
;
TriggerActionTime_1: BEFORE
TriggerActionTime_2: AFTER
TriggerActionTime_3: INSTEAD OF

TriggerEvents  :
     TriggerEvents_1
   | TriggerEvents_2
;
TriggerEvents_1: TriggerOneEvent
TriggerEvents_2: TriggerEvents OR TriggerOneEvent  ### WARNING: Recursion; needs refactoring! ###

TriggerOneEvent  :
     TriggerOneEvent_1
   | TriggerOneEvent_2
   | TriggerOneEvent_3
   | TriggerOneEvent_4
   | TriggerOneEvent_5
;
TriggerOneEvent_1: INSERT
TriggerOneEvent_2: DELETE
TriggerOneEvent_3: UPDATE
TriggerOneEvent_4: UPDATE OF columnList
TriggerOneEvent_5: TRUNCATE

TriggerForSpec  : TriggerForSpec_1?
TriggerForSpec_1: FOR TriggerForOptEach TriggerForType

TriggerForOptEach  : TriggerForOptEach_1?
TriggerForOptEach_1: EACH

TriggerForType  :
     TriggerForType_1
   | TriggerForType_2
;
TriggerForType_1: ROW
TriggerForType_2: STATEMENT

TriggerWhen  : TriggerWhen_1?
TriggerWhen_1: WHEN <LPAREN> a_expr <RPAREN>

TriggerFuncArgs  : (
     TriggerFuncArgs_1
   | TriggerFuncArgs_2
)?
TriggerFuncArgs_1: TriggerFuncArg
TriggerFuncArgs_2: TriggerFuncArgs <COMMA> TriggerFuncArg  ### WARNING: Recursion; needs refactoring! ###

TriggerFuncArg  :
     TriggerFuncArg_1
   | TriggerFuncArg_2
   | TriggerFuncArg_3
   | TriggerFuncArg_4
;
TriggerFuncArg_1: Iconst
TriggerFuncArg_2: FCONST
TriggerFuncArg_3: Sconst
TriggerFuncArg_4: ColLabel

OptConstrFromTable  : OptConstrFromTable_1?
OptConstrFromTable_1: FROM qualified_name

ConstraintAttributeSpec  : ConstraintAttributeSpec_1?
ConstraintAttributeSpec_1: ConstraintAttributeSpec ConstraintAttributeElem  ### WARNING: Recursion; needs refactoring! ###

ConstraintAttributeElem  :
     ConstraintAttributeElem_1
   | ConstraintAttributeElem_2
   | ConstraintAttributeElem_3
   | ConstraintAttributeElem_4
   | ConstraintAttributeElem_5
   | ConstraintAttributeElem_6
;
ConstraintAttributeElem_1: NOT DEFERRABLE
ConstraintAttributeElem_2: DEFERRABLE
ConstraintAttributeElem_3: INITIALLY IMMEDIATE
ConstraintAttributeElem_4: INITIALLY DEFERRED
ConstraintAttributeElem_5: NOT VALID
ConstraintAttributeElem_6: NO INHERIT

DropTrigStmt  :
     DropTrigStmt_1
   | DropTrigStmt_2
;
DropTrigStmt_1: DROP TRIGGER name ON qualified_name opt_drop_behavior
DropTrigStmt_2: DROP TRIGGER IF EXISTS name ON qualified_name opt_drop_behavior

#############################################################################
#
#      QUERIES :
#            CREATE ASSERTION ...
#            DROP ASSERTION ...
#
#############################################################################
CreateAssertStmt: CREATE ASSERTION name CHECK <LPAREN> a_expr <RPAREN> ConstraintAttributeSpec

DropAssertStmt: DROP ASSERTION name opt_drop_behavior

#############################################################################
#
#      QUERY :
#            define (aggregate,operator,type)
#
#############################################################################
DefineStmt   :
     DefineStmt_1
   | DefineStmt_2
   | DefineStmt_3
   | DefineStmt_4
   | DefineStmt_5
   | DefineStmt_6
   | DefineStmt_7
   | DefineStmt_8
   | DefineStmt_9
   | DefineStmt_10
   | DefineStmt_11
   | DefineStmt_12
   | DefineStmt_13
;
DefineStmt_1 : CREATE AGGREGATE func_name aggr_args definition
DefineStmt_2 : CREATE AGGREGATE func_name old_aggr_definition
DefineStmt_3 : CREATE OPERATOR any_operator definition
DefineStmt_4 : CREATE TYPE any_name definition
DefineStmt_5 : CREATE TYPE any_name
DefineStmt_6 : CREATE TYPE any_name AS <LPAREN> OptTableFuncElementList <RPAREN>
DefineStmt_7 : CREATE TYPE any_name AS ENUM <LPAREN> opt_enum_val_list <RPAREN>
DefineStmt_8 : CREATE TEXT SEARCH PARSER any_name definition
DefineStmt_9 : CREATE TEXT SEARCH DICTIONARY any_name definition
DefineStmt_10: CREATE TEXT SEARCH TEMPLATE any_name definition
DefineStmt_11: CREATE TEXT SEARCH CONFIGURATION any_name definition
DefineStmt_12: CREATE COLLATION any_name definition
DefineStmt_13: CREATE COLLATION any_name FROM any_name

definition: <LPAREN> def_list <RPAREN>

def_list  :
     def_list_1
   | def_list_2
;
def_list_1: def_elem
def_list_2: def_list <COMMA> def_elem  ### WARNING: Recursion; needs refactoring! ###

def_elem  :
     def_elem_1
   | def_elem_2
;
def_elem_1: ColLabel <EQUAL> def_arg
def_elem_2: ColLabel

# Note: any simple identifier will be returned as a type name!
def_arg  :
     def_arg_1
   | def_arg_2
   | def_arg_3
   | def_arg_4
   | def_arg_5
;
def_arg_1: func_type
def_arg_2: reserved_keyword
def_arg_3: qual_all_Op
def_arg_4: NumericOnly
def_arg_5: Sconst

aggr_args  :
     aggr_args_1
   | aggr_args_2
;
aggr_args_1: <LPAREN> type_list <RPAREN>
aggr_args_2: <LPAREN> <STAR> <RPAREN>

old_aggr_definition: <LPAREN> old_aggr_list <RPAREN>

old_aggr_list  :
     old_aggr_list_1
   | old_aggr_list_2
;
old_aggr_list_1: old_aggr_elem
old_aggr_list_2: old_aggr_list <COMMA> old_aggr_elem  ### WARNING: Recursion; needs refactoring! ###

# Must use IDENT here to avoid reduce/reduce conflicts; fortunately none of
# the item names needed in old aggregate definitions are likely to become
# SQL keywords.
old_aggr_elem: IDENT <EQUAL> def_arg

opt_enum_val_list  : opt_enum_val_list_1?
opt_enum_val_list_1: enum_val_list

enum_val_list  :
     enum_val_list_1
   | enum_val_list_2
;
enum_val_list_1: Sconst
enum_val_list_2: enum_val_list <COMMA> Sconst  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
#
#   ALTER TYPE enumtype ADD ...
#
#############################################################################
AlterEnumStmt  :
     AlterEnumStmt_1
   | AlterEnumStmt_2
   | AlterEnumStmt_3
;
AlterEnumStmt_1: ALTER TYPE any_name ADD VALUE Sconst
AlterEnumStmt_2: ALTER TYPE any_name ADD VALUE Sconst BEFORE Sconst
AlterEnumStmt_3: ALTER TYPE any_name ADD VALUE Sconst AFTER Sconst

#############################################################################
#
#      QUERIES :
#            CREATE OPERATOR CLASS ...
#            CREATE OPERATOR FAMILY ...
#            ALTER OPERATOR FAMILY ...
#            DROP OPERATOR CLASS ...
#            DROP OPERATOR FAMILY ...
#
#############################################################################
CreateOpClassStmt: CREATE OPERATOR CLASS any_name opt_default FOR TYPE Typename USING access_method opt_opfamily AS opclass_item_list

opclass_item_list  :
     opclass_item_list_1
   | opclass_item_list_2
;
opclass_item_list_1: opclass_item
opclass_item_list_2: opclass_item_list <COMMA> opclass_item  ### WARNING: Recursion; needs refactoring! ###

opclass_item  :
     opclass_item_1
   | opclass_item_2
   | opclass_item_3
   | opclass_item_4
   | opclass_item_5
;
opclass_item_1: OPERATOR Iconst any_operator opclass_purpose opt_recheck
opclass_item_2: OPERATOR Iconst any_operator oper_argtypes opclass_purpose opt_recheck
opclass_item_3: FUNCTION Iconst func_name func_args
opclass_item_4: FUNCTION Iconst <LPAREN> type_list <RPAREN> func_name func_args
opclass_item_5: STORAGE Typename

opt_default  : opt_default_1?
opt_default_1: DEFAULT

opt_opfamily  : opt_opfamily_1?
opt_opfamily_1: FAMILY any_name

opclass_purpose  : (
     opclass_purpose_1
   | opclass_purpose_2
)?
opclass_purpose_1: FOR SEARCH
opclass_purpose_2: FOR ORDER BY any_name

# RECHECK no longer does anything in opclass definitions,
# but we still accept it to ease porting of old database
# dumps.
opt_recheck  : opt_recheck_1?
opt_recheck_1: RECHECK

CreateOpFamilyStmt: CREATE OPERATOR FAMILY any_name USING access_method

AlterOpFamilyStmt  :
     AlterOpFamilyStmt_1
   | AlterOpFamilyStmt_2
;
AlterOpFamilyStmt_1: ALTER OPERATOR FAMILY any_name USING access_method ADD opclass_item_list
AlterOpFamilyStmt_2: ALTER OPERATOR FAMILY any_name USING access_method DROP opclass_drop_list

opclass_drop_list  :
     opclass_drop_list_1
   | opclass_drop_list_2
;
opclass_drop_list_1: opclass_drop
opclass_drop_list_2: opclass_drop_list <COMMA> opclass_drop  ### WARNING: Recursion; needs refactoring! ###

opclass_drop  :
     opclass_drop_1
   | opclass_drop_2
;
opclass_drop_1: OPERATOR Iconst <LPAREN> type_list <RPAREN>
opclass_drop_2: FUNCTION Iconst <LPAREN> type_list <RPAREN>

DropOpClassStmt  :
     DropOpClassStmt_1
   | DropOpClassStmt_2
;
DropOpClassStmt_1: DROP OPERATOR CLASS any_name USING access_method opt_drop_behavior
DropOpClassStmt_2: DROP OPERATOR CLASS IF EXISTS any_name USING access_method opt_drop_behavior

DropOpFamilyStmt  :
     DropOpFamilyStmt_1
   | DropOpFamilyStmt_2
;
DropOpFamilyStmt_1: DROP OPERATOR FAMILY any_name USING access_method opt_drop_behavior
DropOpFamilyStmt_2: DROP OPERATOR FAMILY IF EXISTS any_name USING access_method opt_drop_behavior

#############################################################################
#
#      QUERY:
#
#      DROP OWNED BY username [, username ...] [ RESTRICT | CASCADE ]
#      REASSIGN OWNED BY username [, username ...] TO username
#
#############################################################################
DropOwnedStmt: DROP OWNED BY name_list opt_drop_behavior

ReassignOwnedStmt: REASSIGN OWNED BY name_list TO name

#############################################################################
#
#      QUERY:
#
#      DROP itemtype [ IF EXISTS ] itemname [, itemname ...]
#           [ RESTRICT | CASCADE ]
#
#############################################################################
DropStmt  :
     DropStmt_1
   | DropStmt_2
   | DropStmt_3
   | DropStmt_4
;
DropStmt_1: DROP drop_type IF EXISTS any_name_list opt_drop_behavior
DropStmt_2: DROP drop_type any_name_list opt_drop_behavior
DropStmt_3: DROP INDEX CONCURRENTLY any_name_list opt_drop_behavior
DropStmt_4: DROP INDEX CONCURRENTLY IF EXISTS any_name_list opt_drop_behavior

drop_type   :
     drop_type_1
   | drop_type_2
   | drop_type_3
   | drop_type_4
   | drop_type_5
   | drop_type_6
   | drop_type_7
   | drop_type_8
   | drop_type_9
   | drop_type_10
   | drop_type_11
   | drop_type_12
   | drop_type_13
   | drop_type_14
   | drop_type_15
   | drop_type_16
;
drop_type_1 : TABLE
drop_type_2 : SEQUENCE
drop_type_3 : VIEW
drop_type_4 : INDEX
drop_type_5 : FOREIGN TABLE
drop_type_6 : EVENT_TRIGGER
drop_type_7 : TYPE
drop_type_8 : DOMAIN
drop_type_9 : COLLATION
drop_type_10: CONVERSION
drop_type_11: SCHEMA
drop_type_12: EXTENSION
drop_type_13: TEXT SEARCH PARSER
drop_type_14: TEXT SEARCH DICTIONARY
drop_type_15: TEXT SEARCH TEMPLATE
drop_type_16: TEXT SEARCH CONFIGURATION

any_name_list  :
     any_name_list_1
   | any_name_list_2
;
any_name_list_1: any_name
any_name_list_2: any_name_list <COMMA> any_name  ### WARNING: Recursion; needs refactoring! ###

any_name  :
     any_name_1
   | any_name_2
;
any_name_1: ColId
any_name_2: ColId attrs

attrs  :
     attrs_1
   | attrs_2
;
attrs_1: <DOT> attr_name
attrs_2: attrs <DOT> attr_name  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
#
#      QUERY:
#            truncate table relname1, relname2, ...
#
#############################################################################
TruncateStmt: TRUNCATE opt_table relation_expr_list opt_restart_seqs opt_drop_behavior

opt_restart_seqs  : (
     opt_restart_seqs_1
   | opt_restart_seqs_2
)?
opt_restart_seqs_1: CONTINUE IDENTITY
opt_restart_seqs_2: RESTART IDENTITY

#############################################################################
#
#   The COMMENT ON statement can take different forms based upon the type of
#   the object associated with the comment. The form of the statement is:
#
#   COMMENT ON [ [ DATABASE | DOMAIN | INDEX | SEQUENCE | TABLE | TYPE | VIEW |
#               COLLATION | CONVERSION | LANGUAGE | OPERATOR CLASS |
#               LARGE OBJECT | CAST | COLUMN | SCHEMA | TABLESPACE |
#               EXTENSION | ROLE | TEXT SEARCH PARSER |
#               TEXT SEARCH DICTIONARY | TEXT SEARCH TEMPLATE |
#               TEXT SEARCH CONFIGURATION | FOREIGN TABLE |
#               FOREIGN DATA WRAPPER | SERVER | EVENT TRIGGER ] <objname> |
#             AGGREGATE <aggname> (arg1, ...) |
#             FUNCTION <funcname> (arg1, arg2, ...) |
#             OPERATOR <op> (leftoperand_typ, rightoperand_typ) |
#             TRIGGER <triggername> ON <relname> |
#             CONSTRAINT <constraintname> ON <relname> |
#             RULE <rulename> ON <relname> ]
#            IS 'text'
#
#############################################################################
CommentStmt   :
     CommentStmt_1
   | CommentStmt_2
   | CommentStmt_3
   | CommentStmt_4
   | CommentStmt_5
   | CommentStmt_6
   | CommentStmt_7
   | CommentStmt_8
   | CommentStmt_9
   | CommentStmt_10
   | CommentStmt_11
   | CommentStmt_12
   | CommentStmt_13
   | CommentStmt_14
   | CommentStmt_15
   | CommentStmt_16
   | CommentStmt_17
;
CommentStmt_1 : COMMENT ON comment_type any_name IS comment_text
CommentStmt_2 : COMMENT ON AGGREGATE func_name aggr_args IS comment_text
CommentStmt_3 : COMMENT ON FUNCTION func_name func_args IS comment_text
CommentStmt_4 : COMMENT ON OPERATOR any_operator oper_argtypes IS comment_text
CommentStmt_5 : COMMENT ON CONSTRAINT name ON any_name IS comment_text
CommentStmt_6 : COMMENT ON RULE name ON any_name IS comment_text
CommentStmt_7 : COMMENT ON RULE name IS comment_text
CommentStmt_8 : COMMENT ON TRIGGER name ON any_name IS comment_text
CommentStmt_9 : COMMENT ON OPERATOR CLASS any_name USING access_method IS comment_text
CommentStmt_10: COMMENT ON OPERATOR FAMILY any_name USING access_method IS comment_text
CommentStmt_11: COMMENT ON LARGE OBJECT NumericOnly IS comment_text
CommentStmt_12: COMMENT ON CAST <LPAREN> Typename AS Typename <RPAREN> IS comment_text
CommentStmt_13: COMMENT ON opt_procedural LANGUAGE any_name IS comment_text
CommentStmt_14: COMMENT ON TEXT SEARCH PARSER any_name IS comment_text
CommentStmt_15: COMMENT ON TEXT SEARCH DICTIONARY any_name IS comment_text
CommentStmt_16: COMMENT ON TEXT SEARCH TEMPLATE any_name IS comment_text
CommentStmt_17: COMMENT ON TEXT SEARCH CONFIGURATION any_name IS comment_text

comment_type   :
     comment_type_1
   | comment_type_2
   | comment_type_3
   | comment_type_4
   | comment_type_5
   | comment_type_6
   | comment_type_7
   | comment_type_8
   | comment_type_9
   | comment_type_10
   | comment_type_11
   | comment_type_12
   | comment_type_13
   | comment_type_14
   | comment_type_15
   | comment_type_16
   | comment_type_17
   | comment_type_18
;
comment_type_1 : COLUMN
comment_type_2 : DATABASE
comment_type_3 : SCHEMA
comment_type_4 : INDEX
comment_type_5 : SEQUENCE
comment_type_6 : TABLE
comment_type_7 : DOMAIN
comment_type_8 : TYPE
comment_type_9 : VIEW
comment_type_10: COLLATION
comment_type_11: CONVERSION
comment_type_12: TABLESPACE
comment_type_13: EXTENSION
comment_type_14: ROLE
comment_type_15: FOREIGN TABLE
comment_type_16: SERVER
comment_type_17: FOREIGN DATA WRAPPER
comment_type_18: EVENT TRIGGER

comment_text  :
     comment_text_1
   | comment_text_2
;
comment_text_1: Sconst
comment_text_2: NULL

#############################################################################
#
#  SECURITY LABEL [FOR <provider>] ON <object> IS <label>
#
#  As with COMMENT ON, <object> can refer to various types of database
#  objects (e.g. TABLE, COLUMN, etc.).
#
#############################################################################
SecLabelStmt  :
     SecLabelStmt_1
   | SecLabelStmt_2
   | SecLabelStmt_3
   | SecLabelStmt_4
   | SecLabelStmt_5
;
SecLabelStmt_1: SECURITY LABEL opt_provider ON security_label_type any_name IS security_label
SecLabelStmt_2: SECURITY LABEL opt_provider ON AGGREGATE func_name aggr_args IS security_label
SecLabelStmt_3: SECURITY LABEL opt_provider ON FUNCTION func_name func_args IS security_label
SecLabelStmt_4: SECURITY LABEL opt_provider ON LARGE OBJECT NumericOnly IS security_label
SecLabelStmt_5: SECURITY LABEL opt_provider ON opt_procedural LANGUAGE any_name IS security_label

opt_provider  : opt_provider_1?
opt_provider_1: FOR ColId_or_Sconst

security_label_type   :
     security_label_type_1
   | security_label_type_2
   | security_label_type_3
   | security_label_type_4
   | security_label_type_5
   | security_label_type_6
   | security_label_type_7
   | security_label_type_8
   | security_label_type_9
   | security_label_type_10
   | security_label_type_11
   | security_label_type_12
   | security_label_type_13
;
security_label_type_1 : COLUMN
security_label_type_2 : DATABASE
security_label_type_3 : EVENT TRIGGER
security_label_type_4 : SCHEMA
security_label_type_5 : FOREIGN TABLE
security_label_type_6 : SCHEMA
security_label_type_7 : SEQUENCE
security_label_type_8 : TABLE
security_label_type_9 : DOMAIN
security_label_type_10: ROLE
security_label_type_11: TABLESPACE
security_label_type_12: TYPE
security_label_type_13: VIEW

security_label  :
     security_label_1
   | security_label_2
;
security_label_1: Sconst
security_label_2: NULL

#############################################################################
#
#      QUERY:
#         fetch/move
#
#############################################################################
FetchStmt  :
     FetchStmt_1
   | FetchStmt_2
;
FetchStmt_1: FETCH fetch_args
FetchStmt_2: MOVE fetch_args

fetch_args   :
     fetch_args_1
   | fetch_args_2
   | fetch_args_3
   | fetch_args_4
   | fetch_args_5
   | fetch_args_6
   | fetch_args_7
   | fetch_args_8
   | fetch_args_9
   | fetch_args_10
   | fetch_args_11
   | fetch_args_12
   | fetch_args_13
   | fetch_args_14
   | fetch_args_15
   | fetch_args_16
;
fetch_args_1 : cursor_name
fetch_args_2 : from_in cursor_name
fetch_args_3 : NEXT opt_from_in cursor_name
fetch_args_4 : PRIOR opt_from_in cursor_name
fetch_args_5 : FIRST opt_from_in cursor_name
fetch_args_6 : LAST opt_from_in cursor_name
fetch_args_7 : ABSOLUTE SignedIconst opt_from_in cursor_name
fetch_args_8 : RELATIVE SignedIconst opt_from_in cursor_name
fetch_args_9 : SignedIconst opt_from_in cursor_name
fetch_args_10: ALL opt_from_in cursor_name
fetch_args_11: FORWARD opt_from_in cursor_name
fetch_args_12: FORWARD SignedIconst opt_from_in cursor_name
fetch_args_13: FORWARD ALL opt_from_in cursor_name
fetch_args_14: BACKWARD opt_from_in cursor_name
fetch_args_15: BACKWARD SignedIconst opt_from_in cursor_name
fetch_args_16: BACKWARD ALL opt_from_in cursor_name

from_in  :
     from_in_1
   | from_in_2
;
from_in_1: FROM
from_in_2: IN

opt_from_in  : opt_from_in_1?
opt_from_in_1: from_in

#############################################################################
#
# GRANT and REVOKE statements
#
#############################################################################
GrantStmt: GRANT privileges ON privilege_target TO grantee_list opt_grant_grant_option

RevokeStmt  :
     RevokeStmt_1
   | RevokeStmt_2
;
RevokeStmt_1: REVOKE privileges ON privilege_target FROM grantee_list opt_drop_behavior
RevokeStmt_2: REVOKE GRANT OPTION FOR privileges ON privilege_target FROM grantee_list opt_drop_behavior

# Privilege names are represented as strings; the validity of the privilege
# names gets checked at execution.  This is a bit annoying but we have little
# choice because of the syntactic conflict with lists of role names in
# GRANT/REVOKE.  What's more, we have to call out in the "privilege"
# production any reserved keywords that need to be usable as privilege names.

# either ALL [PRIVILEGES] or a list of individual privileges
privileges  :
     privileges_1
   | privileges_2
   | privileges_3
   | privileges_4
   | privileges_5
;
privileges_1: privilege_list
privileges_2: ALL
privileges_3: ALL PRIVILEGES
privileges_4: ALL <LPAREN> columnList <RPAREN>
privileges_5: ALL PRIVILEGES <LPAREN> columnList <RPAREN>

privilege_list  :
     privilege_list_1
   | privilege_list_2
;
privilege_list_1: privilege
privilege_list_2: privilege_list <COMMA> privilege  ### WARNING: Recursion; needs refactoring! ###

privilege  :
     privilege_1
   | privilege_2
   | privilege_3
   | privilege_4
;
privilege_1: SELECT opt_column_list
privilege_2: REFERENCES opt_column_list
privilege_3: CREATE opt_column_list
privilege_4: ColId opt_column_list

# Don't bother trying to fold the first two rules into one using
# opt_table.  You're going to get conflicts.
privilege_target   :
     privilege_target_1
   | privilege_target_2
   | privilege_target_3
   | privilege_target_4
   | privilege_target_5
   | privilege_target_6
   | privilege_target_7
   | privilege_target_8
   | privilege_target_9
   | privilege_target_10
   | privilege_target_11
   | privilege_target_12
   | privilege_target_13
   | privilege_target_14
;
privilege_target_1 : qualified_name_list
privilege_target_2 : TABLE qualified_name_list
privilege_target_3 : SEQUENCE qualified_name_list
privilege_target_4 : FOREIGN DATA WRAPPER name_list
privilege_target_5 : FOREIGN SERVER name_list
privilege_target_6 : FUNCTION function_with_argtypes_list
privilege_target_7 : DATABASE name_list
privilege_target_8 : LANGUAGE name_list
privilege_target_9 : LARGE OBJECT NumericOnly_list
privilege_target_10: SCHEMA name_list
privilege_target_11: TABLESPACE name_list
privilege_target_12: ALL TABLES IN SCHEMA name_list
privilege_target_13: ALL SEQUENCES IN SCHEMA name_list
privilege_target_14: ALL FUNCTIONS IN SCHEMA name_list

grantee_list  :
     grantee_list_1
   | grantee_list_2
;
grantee_list_1: grantee
grantee_list_2: grantee_list <COMMA> grantee  ### WARNING: Recursion; needs refactoring! ###

grantee  :
     grantee_1
   | grantee_2
;
grantee_1: RoleId
grantee_2: GROUP RoleId

opt_grant_grant_option  : opt_grant_grant_option_1?
opt_grant_grant_option_1: WITH GRANT OPTION

function_with_argtypes_list  :
     function_with_argtypes_list_1
   | function_with_argtypes_list_2
;
function_with_argtypes_list_1: function_with_argtypes
function_with_argtypes_list_2: function_with_argtypes_list <COMMA> function_with_argtypes  ### WARNING: Recursion; needs refactoring! ###

function_with_argtypes: func_name func_args

#############################################################################
#
# GRANT and REVOKE ROLE statements
#
#############################################################################
GrantRoleStmt: GRANT privilege_list TO name_list opt_grant_admin_option opt_granted_by

RevokeRoleStmt  :
     RevokeRoleStmt_1
   | RevokeRoleStmt_2
;
RevokeRoleStmt_1: REVOKE privilege_list FROM name_list opt_granted_by opt_drop_behavior
RevokeRoleStmt_2: REVOKE ADMIN OPTION FOR privilege_list FROM name_list opt_granted_by opt_drop_behavior

opt_grant_admin_option  : opt_grant_admin_option_1?
opt_grant_admin_option_1: WITH ADMIN OPTION

opt_granted_by  : opt_granted_by_1?
opt_granted_by_1: GRANTED BY RoleId

#############################################################################
#
# ALTER DEFAULT PRIVILEGES statement
#
#############################################################################
AlterDefaultPrivilegesStmt: ALTER DEFAULT PRIVILEGES DefACLOptionList DefACLAction

DefACLOptionList  : DefACLOptionList_1?
DefACLOptionList_1: DefACLOptionList DefACLOption  ### WARNING: Recursion; needs refactoring! ###

DefACLOption  :
     DefACLOption_1
   | DefACLOption_2
   | DefACLOption_3
;
DefACLOption_1: IN SCHEMA name_list
DefACLOption_2: FOR ROLE name_list
DefACLOption_3: FOR USER name_list

# This should match GRANT/REVOKE, except that individual target objects
# are not mentioned and we only allow a subset of object types.
DefACLAction  :
     DefACLAction_1
   | DefACLAction_2
   | DefACLAction_3
;
DefACLAction_1: GRANT privileges ON defacl_privilege_target TO grantee_list opt_grant_grant_option
DefACLAction_2: REVOKE privileges ON defacl_privilege_target FROM grantee_list opt_drop_behavior
DefACLAction_3: REVOKE GRANT OPTION FOR privileges ON defacl_privilege_target FROM grantee_list opt_drop_behavior

defacl_privilege_target  :
     defacl_privilege_target_1
   | defacl_privilege_target_2
   | defacl_privilege_target_3
   | defacl_privilege_target_4
;
defacl_privilege_target_1: TABLES
defacl_privilege_target_2: FUNCTIONS
defacl_privilege_target_3: SEQUENCES
defacl_privilege_target_4: TYPES

#############################################################################
#
#      QUERY: CREATE INDEX
#
# Note: we cannot put TABLESPACE clause after WHERE clause unless we are
# willing to make TABLESPACE a fully reserved word.
#############################################################################
IndexStmt: CREATE opt_unique INDEX opt_concurrently opt_index_name ON qualified_name access_method_clause <LPAREN> index_params <RPAREN> opt_reloptions OptTableSpace where_clause

opt_unique  : opt_unique_1?
opt_unique_1: UNIQUE

opt_concurrently  : opt_concurrently_1?
opt_concurrently_1: CONCURRENTLY

opt_index_name  : opt_index_name_1?
opt_index_name_1: index_name

access_method_clause  : access_method_clause_1?
access_method_clause_1: USING access_method

index_params  :
     index_params_1
   | index_params_2
;
index_params_1: index_elem
index_params_2: index_params <COMMA> index_elem  ### WARNING: Recursion; needs refactoring! ###

# Index attributes can be either simple column references, or arbitrary
# expressions in parens.  For backwards-compatibility reasons, we allow
# an expression that's just a function call to be written without parens.
index_elem  :
     index_elem_1
   | index_elem_2
   | index_elem_3
;
index_elem_1: ColId opt_collate opt_class opt_asc_desc opt_nulls_order
index_elem_2: func_expr opt_collate opt_class opt_asc_desc opt_nulls_order
index_elem_3: <LPAREN> a_expr <RPAREN> opt_collate opt_class opt_asc_desc opt_nulls_order

opt_collate  : opt_collate_1?
opt_collate_1: COLLATE any_name

opt_class  : (
     opt_class_1
   | opt_class_2
)?
opt_class_1: any_name
opt_class_2: USING any_name

opt_asc_desc  : (
     opt_asc_desc_1
   | opt_asc_desc_2
)?
opt_asc_desc_1: ASC
opt_asc_desc_2: DESC

opt_nulls_order  : (
     opt_nulls_order_1
   | opt_nulls_order_2
)?
opt_nulls_order_1: NULLS_FIRST
opt_nulls_order_2: NULLS_LAST

#############################################################################
#
#      QUERY:
#            create [or replace] function <fname>
#                  [(<type-1> { , <type-n>})]
#                  returns <type-r>
#                  as <filename or code in language as appropriate>
#                  language <lang> [with parameters]
#
#############################################################################
CreateFunctionStmt  :
     CreateFunctionStmt_1
   | CreateFunctionStmt_2
   | CreateFunctionStmt_3
;
CreateFunctionStmt_1: CREATE opt_or_replace FUNCTION func_name func_args_with_defaults RETURNS func_return createfunc_opt_list opt_definition
CreateFunctionStmt_2: CREATE opt_or_replace FUNCTION func_name func_args_with_defaults RETURNS TABLE <LPAREN> table_func_column_list <RPAREN> createfunc_opt_list opt_definition
CreateFunctionStmt_3: CREATE opt_or_replace FUNCTION func_name func_args_with_defaults createfunc_opt_list opt_definition

opt_or_replace  : opt_or_replace_1?
opt_or_replace_1: OR REPLACE

func_args  :
     func_args_1
   | func_args_2
;
func_args_1: <LPAREN> func_args_list <RPAREN>
func_args_2: <LPAREN> <RPAREN>

func_args_list  :
     func_args_list_1
   | func_args_list_2
;
func_args_list_1: func_arg
func_args_list_2: func_args_list <COMMA> func_arg  ### WARNING: Recursion; needs refactoring! ###

# func_args_with_defaults is separate because we only want to accept
# defaults in CREATE FUNCTION, not in ALTER etc.
func_args_with_defaults  :
     func_args_with_defaults_1
   | func_args_with_defaults_2
;
func_args_with_defaults_1: <LPAREN> func_args_with_defaults_list <RPAREN>
func_args_with_defaults_2: <LPAREN> <RPAREN>

func_args_with_defaults_list  :
     func_args_with_defaults_list_1
   | func_args_with_defaults_list_2
;
func_args_with_defaults_list_1: func_arg_with_default
func_args_with_defaults_list_2: func_args_with_defaults_list <COMMA> func_arg_with_default  ### WARNING: Recursion; needs refactoring! ###

# The style with arg_class first is SQL99 standard, but Oracle puts
# param_name first; accept both since it's likely people will try both
# anyway.  Don't bother trying to save productions by letting arg_class
# have an empty alternative ... you'll get shift/reduce conflicts.
#
# We can catch over-specified arguments here if we want to,
# but for now better to silently swallow typmod, etc.
# - thomas 2000-03-22
func_arg  :
     func_arg_1
   | func_arg_2
   | func_arg_3
   | func_arg_4
   | func_arg_5
;
func_arg_1: arg_class param_name func_type
func_arg_2: param_name arg_class func_type
func_arg_3: param_name func_type
func_arg_4: arg_class func_type
func_arg_5: func_type

# INOUT is SQL99 standard, IN OUT is for Oracle compatibility
arg_class  :
     arg_class_1
   | arg_class_2
   | arg_class_3
   | arg_class_4
   | arg_class_5
;
arg_class_1: IN
arg_class_2: OUT
arg_class_3: INOUT
arg_class_4: IN OUT
arg_class_5: VARIADIC

# Ideally param_name should be ColId, but that causes too many conflicts.
param_name: type_function_name

func_return: func_type

# We would like to make the %TYPE productions here be ColId attrs etc,
# but that causes reduce/reduce conflicts.  type_function_name
# is next best choice.
func_type  :
     func_type_1
   | func_type_2
   | func_type_3
;
func_type_1: Typename
func_type_2: type_function_name attrs <PERCENT> TYPE
func_type_3: SETOF type_function_name attrs <PERCENT> TYPE

func_arg_with_default  :
     func_arg_with_default_1
   | func_arg_with_default_2
   | func_arg_with_default_3
;
func_arg_with_default_1: func_arg
func_arg_with_default_2: func_arg DEFAULT a_expr
func_arg_with_default_3: func_arg <EQUAL> a_expr

createfunc_opt_list  :
     createfunc_opt_list_1
   | createfunc_opt_list_2
;
createfunc_opt_list_1: 
# Must be at least one to prevent conflict
    createfunc_opt_item
createfunc_opt_list_2: createfunc_opt_list createfunc_opt_item  ### WARNING: Recursion; needs refactoring! ###

# Options common to both CREATE FUNCTION and ALTER FUNCTION
common_func_opt_item   :
     common_func_opt_item_1
   | common_func_opt_item_2
   | common_func_opt_item_3
   | common_func_opt_item_4
   | common_func_opt_item_5
   | common_func_opt_item_6
   | common_func_opt_item_7
   | common_func_opt_item_8
   | common_func_opt_item_9
   | common_func_opt_item_10
   | common_func_opt_item_11
   | common_func_opt_item_12
   | common_func_opt_item_13
;
common_func_opt_item_1 : CALLED ON NULL INPUT
common_func_opt_item_2 : RETURNS NULL ON NULL INPUT
common_func_opt_item_3 : STRICT
common_func_opt_item_4 : IMMUTABLE
common_func_opt_item_5 : STABLE
common_func_opt_item_6 : VOLATILE
common_func_opt_item_7 : EXTERNAL SECURITY DEFINER
common_func_opt_item_8 : EXTERNAL SECURITY INVOKER
common_func_opt_item_9 : SECURITY DEFINER
common_func_opt_item_10: SECURITY INVOKER
common_func_opt_item_11: COST NumericOnly
common_func_opt_item_12: ROWS NumericOnly
common_func_opt_item_13: FunctionSetResetClause

createfunc_opt_item  :
     createfunc_opt_item_1
   | createfunc_opt_item_2
   | createfunc_opt_item_3
   | createfunc_opt_item_4
;
createfunc_opt_item_1: AS func_as
createfunc_opt_item_2: LANGUAGE ColId_or_Sconst
createfunc_opt_item_3: WINDOW
createfunc_opt_item_4: common_func_opt_item

func_as  :
     func_as_1
   | func_as_2
;
func_as_1: Sconst
func_as_2: Sconst <COMMA> Sconst

opt_definition  : opt_definition_1?
opt_definition_1: WITH definition

table_func_column: param_name func_type

table_func_column_list  :
     table_func_column_list_1
   | table_func_column_list_2
;
table_func_column_list_1: table_func_column
table_func_column_list_2: table_func_column_list <COMMA> table_func_column  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
# ALTER FUNCTION
#
# RENAME and OWNER subcommands are already provided by the generic
# ALTER infrastructure, here we just specify alterations that can
# only be applied to functions.
#
#############################################################################
AlterFunctionStmt: ALTER FUNCTION function_with_argtypes alterfunc_opt_list opt_restrict

alterfunc_opt_list  :
     alterfunc_opt_list_1
   | alterfunc_opt_list_2
;
alterfunc_opt_list_1: 
# At least one option must be specified
    common_func_opt_item
alterfunc_opt_list_2: alterfunc_opt_list common_func_opt_item  ### WARNING: Recursion; needs refactoring! ###

# Ignored, merely for SQL compliance
opt_restrict: RESTRICT?

#############################################################################
#
#      QUERY:
#
#      DROP FUNCTION funcname (arg1, arg2, ...) [ RESTRICT | CASCADE ]
#      DROP AGGREGATE aggname (arg1, ...) [ RESTRICT | CASCADE ]
#      DROP OPERATOR opname (leftoperand_typ, rightoperand_typ) [ RESTRICT | CASCADE ]
#
#############################################################################
RemoveFuncStmt  :
     RemoveFuncStmt_1
   | RemoveFuncStmt_2
;
RemoveFuncStmt_1: DROP FUNCTION func_name func_args opt_drop_behavior
RemoveFuncStmt_2: DROP FUNCTION IF EXISTS func_name func_args opt_drop_behavior

RemoveAggrStmt  :
     RemoveAggrStmt_1
   | RemoveAggrStmt_2
;
RemoveAggrStmt_1: DROP AGGREGATE func_name aggr_args opt_drop_behavior
RemoveAggrStmt_2: DROP AGGREGATE IF EXISTS func_name aggr_args opt_drop_behavior

RemoveOperStmt  :
     RemoveOperStmt_1
   | RemoveOperStmt_2
;
RemoveOperStmt_1: DROP OPERATOR any_operator oper_argtypes opt_drop_behavior
RemoveOperStmt_2: DROP OPERATOR IF EXISTS any_operator oper_argtypes opt_drop_behavior

oper_argtypes  :
     oper_argtypes_1
   | oper_argtypes_2
   | oper_argtypes_3
   | oper_argtypes_4
;
oper_argtypes_1: <LPAREN> Typename <RPAREN>
oper_argtypes_2: <LPAREN> Typename <COMMA> Typename <RPAREN>
oper_argtypes_3: <LPAREN> NONE <COMMA> Typename <RPAREN>
oper_argtypes_4: <LPAREN> Typename <COMMA> NONE <RPAREN>

any_operator  :
     any_operator_1
   | any_operator_2
;
any_operator_1: all_Op
any_operator_2: ColId <DOT> any_operator  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
#
#      DO <anonymous code block> [ LANGUAGE language ]
#
# We use a DefElem list for future extensibility, and to allow flexibility
# in the clause order.
#
#############################################################################
DoStmt: DO dostmt_opt_list

dostmt_opt_list  :
     dostmt_opt_list_1
   | dostmt_opt_list_2
;
dostmt_opt_list_1: dostmt_opt_item
dostmt_opt_list_2: dostmt_opt_list dostmt_opt_item  ### WARNING: Recursion; needs refactoring! ###

dostmt_opt_item  :
     dostmt_opt_item_1
   | dostmt_opt_item_2
;
dostmt_opt_item_1: Sconst
dostmt_opt_item_2: LANGUAGE ColId_or_Sconst

#############################################################################
#
#      CREATE CAST / DROP CAST
#
#############################################################################
CreateCastStmt  :
     CreateCastStmt_1
   | CreateCastStmt_2
   | CreateCastStmt_3
;
CreateCastStmt_1: CREATE CAST <LPAREN> Typename AS Typename <RPAREN> WITH FUNCTION function_with_argtypes cast_context
CreateCastStmt_2: CREATE CAST <LPAREN> Typename AS Typename <RPAREN> WITHOUT FUNCTION cast_context
CreateCastStmt_3: CREATE CAST <LPAREN> Typename AS Typename <RPAREN> WITH INOUT cast_context

cast_context  : (
     cast_context_1
   | cast_context_2
)?
cast_context_1: AS IMPLICIT
cast_context_2: AS ASSIGNMENT

DropCastStmt: DROP CAST opt_if_exists <LPAREN> Typename AS Typename <RPAREN> opt_drop_behavior

opt_if_exists  : opt_if_exists_1?
opt_if_exists_1: IF EXISTS

#############################################################################
#
#      QUERY:
#
#      REINDEX type <name> [FORCE]
#
# FORCE no longer does anything, but we accept it for backwards compatibility
#############################################################################
ReindexStmt  :
     ReindexStmt_1
   | ReindexStmt_2
   | ReindexStmt_3
;
ReindexStmt_1: REINDEX reindex_type qualified_name opt_force
ReindexStmt_2: REINDEX SYSTEM name opt_force
ReindexStmt_3: REINDEX DATABASE name opt_force

reindex_type  :
     reindex_type_1
   | reindex_type_2
;
reindex_type_1: INDEX
reindex_type_2: TABLE

opt_force  : opt_force_1?
opt_force_1: FORCE

#############################################################################
#
# ALTER THING name RENAME TO newname
#
#############################################################################
RenameStmt   :
     RenameStmt_1
   | RenameStmt_2
   | RenameStmt_3
   | RenameStmt_4
   | RenameStmt_5
   | RenameStmt_6
   | RenameStmt_7
   | RenameStmt_8
   | RenameStmt_9
   | RenameStmt_10
   | RenameStmt_11
   | RenameStmt_12
   | RenameStmt_13
   | RenameStmt_14
   | RenameStmt_15
   | RenameStmt_16
   | RenameStmt_17
   | RenameStmt_18
   | RenameStmt_19
   | RenameStmt_20
   | RenameStmt_21
   | RenameStmt_22
   | RenameStmt_23
   | RenameStmt_24
   | RenameStmt_25
   | RenameStmt_26
   | RenameStmt_27
   | RenameStmt_28
   | RenameStmt_29
;
RenameStmt_1 : ALTER AGGREGATE func_name aggr_args RENAME TO name
RenameStmt_2 : ALTER COLLATION any_name RENAME TO name
RenameStmt_3 : ALTER CONVERSION any_name RENAME TO name
RenameStmt_4 : ALTER DATABASE database_name RENAME TO database_name
RenameStmt_5 : ALTER FUNCTION function_with_argtypes RENAME TO name
RenameStmt_6 : ALTER GROUP RoleId RENAME TO RoleId
RenameStmt_7 : ALTER opt_procedural LANGUAGE name RENAME TO name
RenameStmt_8 : ALTER OPERATOR CLASS any_name USING access_method RENAME TO name
RenameStmt_9 : ALTER OPERATOR FAMILY any_name USING access_method RENAME TO name
RenameStmt_10: ALTER SCHEMA name RENAME TO name
RenameStmt_11: ALTER TABLE relation_expr RENAME TO name
RenameStmt_12: ALTER SEQUENCE qualified_name RENAME TO name
RenameStmt_13: ALTER VIEW qualified_name RENAME TO name
RenameStmt_14: ALTER INDEX qualified_name RENAME TO name
RenameStmt_15: ALTER FOREIGN TABLE relation_expr RENAME TO name
RenameStmt_16: ALTER TABLE relation_expr RENAME opt_column name TO name
RenameStmt_17: ALTER FOREIGN TABLE relation_expr RENAME opt_column name TO name
RenameStmt_18: ALTER TRIGGER name ON qualified_name RENAME TO name
RenameStmt_19: ALTER ROLE RoleId RENAME TO RoleId
RenameStmt_20: ALTER USER RoleId RENAME TO RoleId
RenameStmt_21: ALTER TABLESPACE name RENAME TO name
RenameStmt_22: ALTER TABLESPACE name SET reloptions
RenameStmt_23: ALTER TABLESPACE name RESET reloptions
RenameStmt_24: ALTER TEXT SEARCH PARSER any_name RENAME TO name
RenameStmt_25: ALTER TEXT SEARCH DICTIONARY any_name RENAME TO name
RenameStmt_26: ALTER TEXT SEARCH TEMPLATE any_name RENAME TO name
RenameStmt_27: ALTER TEXT SEARCH CONFIGURATION any_name RENAME TO name
RenameStmt_28: ALTER TYPE any_name RENAME TO name
RenameStmt_29: ALTER TYPE any_name RENAME ATTRIBUTE name TO name opt_drop_behavior

opt_column  : opt_column_1?
opt_column_1: COLUMN

opt_set_data  : opt_set_data_1?
opt_set_data_1: SET DATA

#############################################################################
#
# ALTER THING name SET SCHEMA name
#
#############################################################################
AlterObjectSchemaStmt   :
     AlterObjectSchemaStmt_1
   | AlterObjectSchemaStmt_2
   | AlterObjectSchemaStmt_3
   | AlterObjectSchemaStmt_4
   | AlterObjectSchemaStmt_5
   | AlterObjectSchemaStmt_6
   | AlterObjectSchemaStmt_7
   | AlterObjectSchemaStmt_8
   | AlterObjectSchemaStmt_9
   | AlterObjectSchemaStmt_10
   | AlterObjectSchemaStmt_11
   | AlterObjectSchemaStmt_12
   | AlterObjectSchemaStmt_13
   | AlterObjectSchemaStmt_14
   | AlterObjectSchemaStmt_15
   | AlterObjectSchemaStmt_16
   | AlterObjectSchemaStmt_17
   | AlterObjectSchemaStmt_18
;
AlterObjectSchemaStmt_1 : ALTER AGGREGATE func_name aggr_args SET SCHEMA name
AlterObjectSchemaStmt_2 : ALTER COLLATION any_name SET SCHEMA name
AlterObjectSchemaStmt_3 : ALTER CONVERSION any_name SET SCHEMA name
AlterObjectSchemaStmt_4 : ALTER DOMAIN any_name SET SCHEMA name
AlterObjectSchemaStmt_5 : ALTER EXTENSION any_name SET SCHEMA name
AlterObjectSchemaStmt_6 : ALTER FUNCTION function_with_argtypes SET SCHEMA name
AlterObjectSchemaStmt_7 : ALTER OPERATOR any_operator oper_argtypes SET SCHEMA name
AlterObjectSchemaStmt_8 : ALTER OPERATOR CLASS any_name USING access_method SET SCHEMA name
AlterObjectSchemaStmt_9 : ALTER OPERATOR FAMILY any_name USING access_method SET SCHEMA name
AlterObjectSchemaStmt_10: ALTER TABLE relation_expr SET SCHEMA name
AlterObjectSchemaStmt_11: ALTER TEXT SEARCH PARSER any_name SET SCHEMA name
AlterObjectSchemaStmt_12: ALTER TEXT SEARCH DICTIONARY any_name SET SCHEMA name
AlterObjectSchemaStmt_13: ALTER TEXT SEARCH TEMPLATE any_name SET SCHEMA name
AlterObjectSchemaStmt_14: ALTER TEXT SEARCH CONFIGURATION any_name SET SCHEMA name
AlterObjectSchemaStmt_15: ALTER SEQUENCE qualified_name SET SCHEMA name
AlterObjectSchemaStmt_16: ALTER VIEW qualified_name SET SCHEMA name
AlterObjectSchemaStmt_17: ALTER FOREIGN TABLE relation_expr SET SCHEMA name
AlterObjectSchemaStmt_18: ALTER TYPE any_name SET SCHEMA name

#############################################################################
#
# ALTER THING name OWNER TO newname
#
#############################################################################
AlterOwnerStmt   :
     AlterOwnerStmt_1
   | AlterOwnerStmt_2
   | AlterOwnerStmt_3
   | AlterOwnerStmt_4
   | AlterOwnerStmt_5
   | AlterOwnerStmt_6
   | AlterOwnerStmt_7
   | AlterOwnerStmt_8
   | AlterOwnerStmt_9
   | AlterOwnerStmt_10
   | AlterOwnerStmt_11
   | AlterOwnerStmt_12
   | AlterOwnerStmt_13
   | AlterOwnerStmt_14
   | AlterOwnerStmt_15
   | AlterOwnerStmt_16
   | AlterOwnerStmt_17
   | AlterOwnerStmt_18
;
AlterOwnerStmt_1 : ALTER AGGREGATE func_name aggr_args OWNER TO RoleId
AlterOwnerStmt_2 : ALTER COLLATION any_name OWNER TO RoleId
AlterOwnerStmt_3 : ALTER CONVERSION any_name OWNER TO RoleId
AlterOwnerStmt_4 : ALTER DATABASE database_name OWNER TO RoleId
AlterOwnerStmt_5 : ALTER DOMAIN any_name OWNER TO RoleId
AlterOwnerStmt_6 : ALTER FUNCTION function_with_argtypes OWNER TO RoleId
AlterOwnerStmt_7 : ALTER opt_procedural LANGUAGE name OWNER TO RoleId
AlterOwnerStmt_8 : ALTER LARGE OBJECT NumericOnly OWNER TO RoleId
AlterOwnerStmt_9 : ALTER OPERATOR any_operator oper_argtypes OWNER TO RoleId
AlterOwnerStmt_10: ALTER OPERATOR CLASS any_name USING access_method OWNER TO RoleId
AlterOwnerStmt_11: ALTER OPERATOR FAMILY any_name USING access_method OWNER TO RoleId
AlterOwnerStmt_12: ALTER SCHEMA name OWNER TO RoleId
AlterOwnerStmt_13: ALTER TYPE any_name OWNER TO RoleId
AlterOwnerStmt_14: ALTER TABLESPACE name OWNER TO RoleId
AlterOwnerStmt_15: ALTER TEXT SEARCH DICTIONARY any_name OWNER TO RoleId
AlterOwnerStmt_16: ALTER TEXT SEARCH CONFIGURATION any_name OWNER TO RoleId
AlterOwnerStmt_17: ALTER FOREIGN DATA WRAPPER name OWNER TO RoleId
AlterOwnerStmt_18: ALTER SERVER name OWNER TO RoleId

#############################################################################
#
#      QUERY:   Define Rewrite Rule
#
#############################################################################
RuleStmt: CREATE opt_or_replace RULE name AS ON event TO qualified_name where_clause DO opt_instead RuleActionList

RuleActionList  :
     RuleActionList_1
   | RuleActionList_2
   | RuleActionList_3
;
RuleActionList_1: NOTHING
RuleActionList_2: RuleActionStmt
RuleActionList_3: <LPAREN> RuleActionMulti <RPAREN>

# the thrashing around here is to discard "empty" statements...
RuleActionMulti  :
     RuleActionMulti_1
   | RuleActionMulti_2
;
RuleActionMulti_1: RuleActionMulti <SEMI> RuleActionStmtOrEmpty  ### WARNING: Recursion; needs refactoring! ###
RuleActionMulti_2: RuleActionStmtOrEmpty

RuleActionStmt:
     SelectStmt
   | InsertStmt
   | UpdateStmt
   | DeleteStmt
   | NotifyStmt
;

RuleActionStmtOrEmpty  : RuleActionStmtOrEmpty_1?
RuleActionStmtOrEmpty_1: RuleActionStmt

event  :
     event_1
   | event_2
   | event_3
   | event_4
;
event_1: SELECT
event_2: UPDATE
event_3: DELETE
event_4: INSERT

opt_instead  : (
     opt_instead_1
   | opt_instead_2
)?
opt_instead_1: INSTEAD
opt_instead_2: ALSO

DropRuleStmt  :
     DropRuleStmt_1
   | DropRuleStmt_2
;
DropRuleStmt_1: DROP RULE name ON qualified_name opt_drop_behavior
DropRuleStmt_2: DROP RULE IF EXISTS name ON qualified_name opt_drop_behavior

#############################################################################
#
#      QUERY:
#            NOTIFY <identifier> can appear both in rule bodies and
#            as a query-level command
#
#############################################################################
NotifyStmt: NOTIFY ColId notify_payload

notify_payload  : notify_payload_1?
notify_payload_1: <COMMA> Sconst

ListenStmt: LISTEN ColId

UnlistenStmt  :
     UnlistenStmt_1
   | UnlistenStmt_2
;
UnlistenStmt_1: UNLISTEN ColId
UnlistenStmt_2: UNLISTEN <STAR>

#############################################################################
#
#      Transactions:
#
#      BEGIN / COMMIT / ROLLBACK
#      (also older versions END / ABORT)
#
#############################################################################
TransactionStmt   :
     TransactionStmt_1
   | TransactionStmt_2
   | TransactionStmt_3
   | TransactionStmt_4
   | TransactionStmt_5
   | TransactionStmt_6
   | TransactionStmt_7
   | TransactionStmt_8
   | TransactionStmt_9
   | TransactionStmt_10
   | TransactionStmt_11
   | TransactionStmt_12
   | TransactionStmt_13
   | TransactionStmt_14
;
TransactionStmt_1 : ABORT opt_transaction
TransactionStmt_2 : BEGIN opt_transaction transaction_mode_list_or_empty
TransactionStmt_3 : START TRANSACTION transaction_mode_list_or_empty
TransactionStmt_4 : COMMIT opt_transaction
TransactionStmt_5 : END opt_transaction
TransactionStmt_6 : ROLLBACK opt_transaction
TransactionStmt_7 : SAVEPOINT ColId
TransactionStmt_8 : RELEASE SAVEPOINT ColId
TransactionStmt_9 : RELEASE ColId
TransactionStmt_10: ROLLBACK opt_transaction TO SAVEPOINT ColId
TransactionStmt_11: ROLLBACK opt_transaction TO ColId
TransactionStmt_12: PREPARE TRANSACTION Sconst
TransactionStmt_13: COMMIT PREPARED Sconst
TransactionStmt_14: ROLLBACK PREPARED Sconst

opt_transaction  : (
     opt_transaction_1
   | opt_transaction_2
)?
opt_transaction_1: WORK
opt_transaction_2: TRANSACTION

transaction_mode_item  :
     transaction_mode_item_1
   | transaction_mode_item_2
   | transaction_mode_item_3
   | transaction_mode_item_4
   | transaction_mode_item_5
;
transaction_mode_item_1: ISOLATION LEVEL iso_level
transaction_mode_item_2: READ ONLY
transaction_mode_item_3: READ WRITE
transaction_mode_item_4: DEFERRABLE
transaction_mode_item_5: NOT DEFERRABLE

# Syntax with commas is SQL-spec, without commas is Postgres historical
transaction_mode_list  :
     transaction_mode_list_1
   | transaction_mode_list_2
   | transaction_mode_list_3
;
transaction_mode_list_1: transaction_mode_item
transaction_mode_list_2: transaction_mode_list <COMMA> transaction_mode_item  ### WARNING: Recursion; needs refactoring! ###
transaction_mode_list_3: transaction_mode_list transaction_mode_item  ### WARNING: Recursion; needs refactoring! ###

transaction_mode_list_or_empty: transaction_mode_list?

#############################################################################
#
#   QUERY:
#      CREATE [ OR REPLACE ] [ TEMP ] VIEW <viewname> '('target-list ')'
#         AS <query> [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
#
#############################################################################
ViewStmt  :
     ViewStmt_1
   | ViewStmt_2
;
ViewStmt_1: CREATE OptTemp VIEW qualified_name opt_column_list AS SelectStmt opt_check_option
ViewStmt_2: CREATE OR REPLACE OptTemp VIEW qualified_name opt_column_list AS SelectStmt opt_check_option

opt_check_option  : (
     opt_check_option_1
   | opt_check_option_2
   | opt_check_option_3
)?
opt_check_option_1: WITH CHECK OPTION
opt_check_option_2: WITH CASCADED CHECK OPTION
opt_check_option_3: WITH LOCAL CHECK OPTION

#############################################################################
#
#      QUERY:
#            LOAD "filename"
#
#############################################################################
LoadStmt: LOAD file_name

#############################################################################
#
#      CREATE DATABASE
#
#############################################################################
CreatedbStmt: CREATE DATABASE database_name opt_with createdb_opt_list

createdb_opt_list  : createdb_opt_list_1?
createdb_opt_list_1: createdb_opt_list createdb_opt_item  ### WARNING: Recursion; needs refactoring! ###

createdb_opt_item   :
     createdb_opt_item_1
   | createdb_opt_item_2
   | createdb_opt_item_3
   | createdb_opt_item_4
   | createdb_opt_item_5
   | createdb_opt_item_6
   | createdb_opt_item_7
   | createdb_opt_item_8
   | createdb_opt_item_9
   | createdb_opt_item_10
   | createdb_opt_item_11
   | createdb_opt_item_12
   | createdb_opt_item_13
   | createdb_opt_item_14
   | createdb_opt_item_15
   | createdb_opt_item_16
;
createdb_opt_item_1 : TABLESPACE opt_equal name
createdb_opt_item_2 : TABLESPACE opt_equal DEFAULT
createdb_opt_item_3 : LOCATION opt_equal Sconst
createdb_opt_item_4 : LOCATION opt_equal DEFAULT
createdb_opt_item_5 : TEMPLATE opt_equal name
createdb_opt_item_6 : TEMPLATE opt_equal DEFAULT
createdb_opt_item_7 : ENCODING opt_equal Sconst
createdb_opt_item_8 : ENCODING opt_equal Iconst
createdb_opt_item_9 : ENCODING opt_equal DEFAULT
createdb_opt_item_10: LC_COLLATE opt_equal Sconst
createdb_opt_item_11: LC_COLLATE opt_equal DEFAULT
createdb_opt_item_12: LC_CTYPE opt_equal Sconst
createdb_opt_item_13: LC_CTYPE opt_equal DEFAULT
createdb_opt_item_14: CONNECTION LIMIT opt_equal SignedIconst
createdb_opt_item_15: OWNER opt_equal name
createdb_opt_item_16: OWNER opt_equal DEFAULT

#   Though the equals sign doesn't match other WITH options, pg_dump uses
#   equals for backward compatibility, and it doesn't seem worth removing it.
opt_equal  : opt_equal_1?
opt_equal_1: <EQUAL>

#############################################################################
#
#      ALTER DATABASE
#
#############################################################################
AlterDatabaseStmt  :
     AlterDatabaseStmt_1
   | AlterDatabaseStmt_2
;
AlterDatabaseStmt_1: ALTER DATABASE database_name opt_with alterdb_opt_list
AlterDatabaseStmt_2: ALTER DATABASE database_name SET TABLESPACE name

AlterDatabaseSetStmt: ALTER DATABASE database_name SetResetClause

alterdb_opt_list  : alterdb_opt_list_1?
alterdb_opt_list_1: alterdb_opt_list alterdb_opt_item  ### WARNING: Recursion; needs refactoring! ###

alterdb_opt_item: CONNECTION LIMIT opt_equal SignedIconst

#############################################################################
#
#      DROP DATABASE [ IF EXISTS ]
#
# This is implicitly CASCADE, no need for drop behavior
#############################################################################
DropdbStmt  :
     DropdbStmt_1
   | DropdbStmt_2
;
DropdbStmt_1: DROP DATABASE database_name
DropdbStmt_2: DROP DATABASE IF EXISTS database_name

#############################################################################
#
# Manipulate a domain
#
#############################################################################
CreateDomainStmt: CREATE DOMAIN any_name opt_as Typename ColQualList

AlterDomainStmt  :
     AlterDomainStmt_1
   | AlterDomainStmt_2
   | AlterDomainStmt_3
   | AlterDomainStmt_4
   | AlterDomainStmt_5
;
AlterDomainStmt_1: 
# ALTER DOMAIN <domain> {SET DEFAULT <expr>|DROP DEFAULT}
    ALTER DOMAIN any_name alter_column_default
AlterDomainStmt_2: ALTER DOMAIN any_name DROP NOT NULL
AlterDomainStmt_3: ALTER DOMAIN any_name SET NOT NULL
AlterDomainStmt_4: ALTER DOMAIN any_name ADD TableConstraint
AlterDomainStmt_5: ALTER DOMAIN any_name DROP CONSTRAINT name opt_drop_behavior

opt_as  : opt_as_1?
opt_as_1: AS

#############################################################################
#
# Manipulate a text search dictionary or configuration
#
#############################################################################
AlterTSDictionaryStmt: ALTER TEXT SEARCH DICTIONARY any_name definition

AlterTSConfigurationStmt  :
     AlterTSConfigurationStmt_1
   | AlterTSConfigurationStmt_2
   | AlterTSConfigurationStmt_3
   | AlterTSConfigurationStmt_4
   | AlterTSConfigurationStmt_5
   | AlterTSConfigurationStmt_6
;
AlterTSConfigurationStmt_1: ALTER TEXT SEARCH CONFIGURATION any_name ADD MAPPING FOR name_list WITH any_name_list
AlterTSConfigurationStmt_2: ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list WITH any_name_list
AlterTSConfigurationStmt_3: ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING REPLACE any_name WITH any_name
AlterTSConfigurationStmt_4: ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list REPLACE any_name WITH any_name
AlterTSConfigurationStmt_5: ALTER TEXT SEARCH CONFIGURATION any_name DROP MAPPING FOR name_list
AlterTSConfigurationStmt_6: ALTER TEXT SEARCH CONFIGURATION any_name DROP MAPPING IF EXISTS FOR name_list

#############################################################################
#
# Manipulate a conversion
#
#      CREATE [DEFAULT] CONVERSION <conversion_name>
#      FOR <encoding_name> TO <encoding_name> FROM <func_name>
#
#############################################################################
CreateConversionStmt: CREATE opt_default CONVERSION any_name FOR Sconst TO Sconst FROM any_name

#############################################################################
#
#      QUERY:
#            CLUSTER [VERBOSE] <qualified_name> [ USING <index_name> ]
#            CLUSTER [VERBOSE]
#            CLUSTER [VERBOSE] <index_name> ON <qualified_name> (for pre-8.3)
#
#############################################################################
ClusterStmt  :
     ClusterStmt_1
   | ClusterStmt_2
   | ClusterStmt_3
;
ClusterStmt_1: CLUSTER opt_verbose qualified_name cluster_index_specification
ClusterStmt_2: CLUSTER opt_verbose
ClusterStmt_3: CLUSTER opt_verbose index_name ON qualified_name

cluster_index_specification  : cluster_index_specification_1?
cluster_index_specification_1: USING index_name

#############################################################################
#
#      QUERY:
#            VACUUM
#            ANALYZE
#
#############################################################################
VacuumStmt  :
     VacuumStmt_1
   | VacuumStmt_2
   | VacuumStmt_3
   | VacuumStmt_4
   | VacuumStmt_5
;
VacuumStmt_1: VACUUM opt_full opt_freeze opt_verbose
VacuumStmt_2: VACUUM opt_full opt_freeze opt_verbose qualified_name
VacuumStmt_3: VACUUM opt_full opt_freeze opt_verbose AnalyzeStmt
VacuumStmt_4: VACUUM <LPAREN> vacuum_option_list <RPAREN>
VacuumStmt_5: VACUUM <LPAREN> vacuum_option_list <RPAREN> qualified_name opt_name_list

vacuum_option_list  :
     vacuum_option_list_1
   | vacuum_option_list_2
;
vacuum_option_list_1: vacuum_option_elem
vacuum_option_list_2: vacuum_option_list <COMMA> vacuum_option_elem  ### WARNING: Recursion; needs refactoring! ###

vacuum_option_elem  :
     vacuum_option_elem_1
   | vacuum_option_elem_2
   | vacuum_option_elem_3
   | vacuum_option_elem_4
;
vacuum_option_elem_1: analyze_keyword
vacuum_option_elem_2: VERBOSE
vacuum_option_elem_3: FREEZE
vacuum_option_elem_4: FULL

AnalyzeStmt  :
     AnalyzeStmt_1
   | AnalyzeStmt_2
;
AnalyzeStmt_1: analyze_keyword opt_verbose
AnalyzeStmt_2: analyze_keyword opt_verbose qualified_name opt_name_list

analyze_keyword  :
     analyze_keyword_1
   | analyze_keyword_2
;
analyze_keyword_1: ANALYZE
analyze_keyword_2: ANALYSE

opt_verbose  : opt_verbose_1?
opt_verbose_1: VERBOSE

opt_full  : opt_full_1?
opt_full_1: FULL

opt_freeze  : opt_freeze_1?
opt_freeze_1: FREEZE

opt_name_list  : opt_name_list_1?
opt_name_list_1: <LPAREN> name_list <RPAREN>

#############################################################################
#
#      QUERY:
#            EXPLAIN [ANALYZE] [VERBOSE] query
#            EXPLAIN ( options ) query
#
#############################################################################
ExplainStmt  :
     ExplainStmt_1
   | ExplainStmt_2
   | ExplainStmt_3
   | ExplainStmt_4
;
ExplainStmt_1: EXPLAIN ExplainableStmt
ExplainStmt_2: EXPLAIN analyze_keyword opt_verbose ExplainableStmt
ExplainStmt_3: EXPLAIN VERBOSE ExplainableStmt
ExplainStmt_4: EXPLAIN <LPAREN> explain_option_list <RPAREN> ExplainableStmt

ExplainableStmt:
     SelectStmt
   | InsertStmt
   | UpdateStmt
   | DeleteStmt
   | DeclareCursorStmt
   | CreateAsStmt
   | ExecuteStmt 
# by default all are $$=$_[1]
;

explain_option_list  :
     explain_option_list_1
   | explain_option_list_2
;
explain_option_list_1: explain_option_elem
explain_option_list_2: explain_option_list <COMMA> explain_option_elem  ### WARNING: Recursion; needs refactoring! ###

explain_option_elem: explain_option_name explain_option_arg

explain_option_name  :
     explain_option_name_1
   | explain_option_name_2
   | explain_option_name_3
;
explain_option_name_1: ColId
explain_option_name_2: analyze_keyword
explain_option_name_3: VERBOSE

explain_option_arg  : (
     explain_option_arg_1
   | explain_option_arg_2
)?
explain_option_arg_1: opt_boolean_or_string
explain_option_arg_2: NumericOnly

#############################################################################
#
#      QUERY:
#            PREPARE <plan_name> [(args, ...)] AS <query>
#
#############################################################################
PrepareStmt: PREPARE name prep_type_clause AS PreparableStmt

prep_type_clause  : prep_type_clause_1?
prep_type_clause_1: <LPAREN> type_list <RPAREN>

PreparableStmt:
     SelectStmt
   | InsertStmt
   | UpdateStmt
   | DeleteStmt 
# by default all are $$=$_[1]
;

#############################################################################
#
# EXECUTE <plan_name> [(params, ...)]
# CREATE TABLE <name> AS EXECUTE <plan_name> [(params, ...)]
#
#############################################################################
ExecuteStmt  :
     ExecuteStmt_1
   | ExecuteStmt_2
;
ExecuteStmt_1: EXECUTE name execute_param_clause
ExecuteStmt_2: CREATE OptTemp TABLE create_as_target AS EXECUTE name execute_param_clause opt_with_data

execute_param_clause  : execute_param_clause_1?
execute_param_clause_1: <LPAREN> expr_list <RPAREN>

#############################################################################
#
#      QUERY:
#            DEALLOCATE [PREPARE] <plan_name>
#
#############################################################################
DeallocateStmt  :
     DeallocateStmt_1
   | DeallocateStmt_2
   | DeallocateStmt_3
   | DeallocateStmt_4
;
DeallocateStmt_1: DEALLOCATE name
DeallocateStmt_2: DEALLOCATE PREPARE name
DeallocateStmt_3: DEALLOCATE ALL
DeallocateStmt_4: DEALLOCATE PREPARE ALL

#############################################################################
#
#      QUERY:
#            INSERT STATEMENTS
#
#############################################################################
InsertStmt: opt_with_clause INSERT INTO qualified_name insert_rest returning_clause

insert_rest  :
     insert_rest_1
   | insert_rest_2
   | insert_rest_3
;
insert_rest_1: SelectStmt
insert_rest_2: <LPAREN> insert_column_list <RPAREN> SelectStmt
insert_rest_3: DEFAULT VALUES

insert_column_list  :
     insert_column_list_1
   | insert_column_list_2
;
insert_column_list_1: insert_column_item
insert_column_list_2: insert_column_list <COMMA> insert_column_item  ### WARNING: Recursion; needs refactoring! ###

insert_column_item: ColId opt_indirection

returning_clause  : returning_clause_1?
returning_clause_1: RETURNING target_list

#############################################################################
#
#      QUERY:
#            DELETE STATEMENTS
#
#############################################################################
DeleteStmt: opt_with_clause DELETE FROM relation_expr_opt_alias using_clause where_or_current_clause returning_clause

using_clause  : using_clause_1?
using_clause_1: USING from_list

#############################################################################
#
#      QUERY:
#            LOCK TABLE
#
#############################################################################
LockStmt: LOCK opt_table relation_expr_list opt_lock opt_nowait

opt_lock  : opt_lock_1?
opt_lock_1: IN lock_type MODE

lock_type  :
     lock_type_1
   | lock_type_2
   | lock_type_3
   | lock_type_4
   | lock_type_5
   | lock_type_6
   | lock_type_7
   | lock_type_8
;
lock_type_1: ACCESS SHARE
lock_type_2: ROW SHARE
lock_type_3: ROW EXCLUSIVE
lock_type_4: SHARE UPDATE EXCLUSIVE
lock_type_5: SHARE
lock_type_6: SHARE ROW EXCLUSIVE
lock_type_7: EXCLUSIVE
lock_type_8: ACCESS EXCLUSIVE

opt_nowait  : opt_nowait_1?
opt_nowait_1: NOWAIT

#############################################################################
#
#      QUERY:
#            UpdateStmt (UPDATE)
#
#############################################################################
UpdateStmt: opt_with_clause UPDATE relation_expr_opt_alias SET set_clause_list from_clause where_or_current_clause returning_clause

set_clause_list  :
     set_clause_list_1
   | set_clause_list_2
;
set_clause_list_1: set_clause
set_clause_list_2: set_clause_list <COMMA> set_clause  ### WARNING: Recursion; needs refactoring! ###

set_clause  :
     set_clause_1
   | set_clause_2
;
set_clause_1: single_set_clause
set_clause_2: multiple_set_clause

single_set_clause: set_target <EQUAL> ctext_expr

multiple_set_clause: <LPAREN> set_target_list <RPAREN> <EQUAL> ctext_row

set_target: ColId opt_indirection

set_target_list  :
     set_target_list_1
   | set_target_list_2
;
set_target_list_1: set_target
set_target_list_2: set_target_list <COMMA> set_target  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
#
#      QUERY:
#            CURSOR STATEMENTS
#
#############################################################################
DeclareCursorStmt: DECLARE cursor_name cursor_options CURSOR opt_hold FOR SelectStmt

cursor_name: name

cursor_options  : (
     cursor_options_1
   | cursor_options_2
   | cursor_options_3
   | cursor_options_4
)?
cursor_options_1: cursor_options NO SCROLL  ### WARNING: Recursion; needs refactoring! ###
cursor_options_2: cursor_options SCROLL  ### WARNING: Recursion; needs refactoring! ###
cursor_options_3: cursor_options BINARY  ### WARNING: Recursion; needs refactoring! ###
cursor_options_4: cursor_options INSENSITIVE  ### WARNING: Recursion; needs refactoring! ###

opt_hold  : (
     opt_hold_1
   | opt_hold_2
)?
opt_hold_1: WITH HOLD
opt_hold_2: WITHOUT HOLD

#############################################################################
#
#      QUERY:
#            SELECT STATEMENTS
#
#############################################################################

# A complete SELECT statement looks like this.
#
# The rule returns either a single SelectStmt node or a tree of them,
# representing a set-operation tree.
#
# There is an ambiguity when a sub-SELECT is within an a_expr and there
# are excess parentheses: do the parentheses belong to the sub-SELECT or
# to the surrounding a_expr?  We don't really care, but bison wants to know.
# To resolve the ambiguity, we are careful to define the grammar so that
# the decision is staved off as long as possible: as long as we can keep
# absorbing parentheses into the sub-SELECT, we will do so, and only when
# it's no longer possible to do that will we decide that parens belong to
# the expression.   For example, in "SELECT (((SELECT 2)) + 3)" the extra
# parentheses are treated as part of the sub-select.  The necessity of doing
# it that way is shown by "SELECT (((SELECT 2)) UNION SELECT 2)".   Had we
# parsed "((SELECT 2))" as an a_expr, it'd be too late to go back to the
# SELECT viewpoint when we see the UNION.
#
# This approach is implemented by defining a nonterminal select_with_parens,
# which represents a SELECT with at least one outer layer of parentheses,
# and being careful to use select_with_parens, never '(' SelectStmt ')',
# in the expression grammar.  We will then have shift-reduce conflicts
# which we can resolve in favor of always treating '(' <select> ')' as
# a select_with_parens.  To resolve the conflicts, the productions that
# conflict with the select_with_parens productions are manually given
# precedences lower than the precedence of ')', thereby ensuring that we
# shift ')' (and then reduce to select_with_parens) rather than trying to
# reduce the inner <select> nonterminal to something else.  We use UMINUS
# precedence for this, which is a fairly arbitrary choice.
#
# To be able to define select_with_parens itself without ambiguity, we need
# a nonterminal select_no_parens that represents a SELECT structure with no
# outermost parentheses.  This is a little bit tedious, but it works.
#
# In non-expression contexts, we use SelectStmt which can represent a SELECT
# with or without outer parentheses.
SelectStmt:
     select_no_parens
   | select_with_parens
;

select_with_parens  :
     select_with_parens_1
   | select_with_parens_2
;
select_with_parens_1: <LPAREN> select_no_parens <RPAREN>
select_with_parens_2: <LPAREN> select_with_parens <RPAREN>  ### WARNING: Recursion; needs refactoring! ###

# This rule parses the equivalent of the standard's <query expression>.
# The duplicative productions are annoying, but hard to get rid of without
# creating shift/reduce conflicts.
#
#   FOR UPDATE/SHARE may be before or after LIMIT/OFFSET.
#   In <=7.2.X, LIMIT/OFFSET had to be after FOR UPDATE
#   We now support both orderings, but prefer LIMIT/OFFSET before FOR UPDATE/SHARE
#   2002-08-28 bjm
select_no_parens  :
     select_no_parens_1
   | select_no_parens_2
   | select_no_parens_3
   | select_no_parens_4
   | select_no_parens_5
   | select_no_parens_6
   | select_no_parens_7
   | select_no_parens_8
;
select_no_parens_1: simple_select
select_no_parens_2: select_clause sort_clause
select_no_parens_3: select_clause opt_sort_clause for_locking_clause opt_select_limit
select_no_parens_4: select_clause opt_sort_clause select_limit opt_for_locking_clause
select_no_parens_5: with_clause select_clause
select_no_parens_6: with_clause select_clause sort_clause
select_no_parens_7: with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit
select_no_parens_8: with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause

select_clause  :
     select_clause_1
   | select_clause_2
;
select_clause_1: simple_select
select_clause_2: select_with_parens

# This rule parses SELECT statements that can appear within set operations,
# including UNION, INTERSECT and EXCEPT.  '(' and ')' can be used to specify
# the ordering of the set operations.   Without '(' and ')' we want the
# operations to be ordered per the precedence specs at the head of this file.
#
# As with select_no_parens, simple_select cannot have outer parentheses,
# but can have parenthesized subclauses.
#
# Note that sort clauses cannot be included at this level --- SQL92 requires
#      SELECT foo UNION SELECT bar ORDER BY baz
# to be parsed as
#      (SELECT foo UNION SELECT bar) ORDER BY baz
# not
#      SELECT foo UNION (SELECT bar ORDER BY baz)
# Likewise for WITH, FOR UPDATE and LIMIT.  Therefore, those clauses are
# described as part of the select_no_parens production, not simple_select.
# This does not limit functionality, because you can reintroduce these
# clauses inside parentheses.
#
# NOTE: only the leftmost component SelectStmt should have INTO.
# However, this is not checked by the grammar; parse analysis must check it.
simple_select  :
     simple_select_1
   | simple_select_2
   | simple_select_3
   | simple_select_4
   | simple_select_5
   | simple_select_6
;
simple_select_1: SELECT opt_distinct target_list into_clause from_clause where_clause group_clause having_clause window_clause
simple_select_2: values_clause
simple_select_3: TABLE relation_expr
simple_select_4: select_clause UNION opt_all select_clause
simple_select_5: select_clause INTERSECT opt_all select_clause
simple_select_6: select_clause EXCEPT opt_all select_clause

# SQL standard WITH clause looks like:
#
# WITH [ RECURSIVE ] <query name> [ (<column>,...) ]
#      AS (query) [ SEARCH or CYCLE clause ]
#
# We don't currently support the SEARCH or CYCLE clause.
with_clause  :
     with_clause_1
   | with_clause_2
;
with_clause_1: WITH cte_list
with_clause_2: WITH RECURSIVE cte_list

cte_list  :
     cte_list_1
   | cte_list_2
;
cte_list_1: common_table_expr
cte_list_2: cte_list <COMMA> common_table_expr  ### WARNING: Recursion; needs refactoring! ###

common_table_expr: name opt_name_list AS <LPAREN> PreparableStmt <RPAREN>

opt_with_clause  : opt_with_clause_1?
opt_with_clause_1: with_clause

into_clause  : into_clause_1?
into_clause_1: INTO OptTempTableName

# Redundancy here is needed to avoid shift/reduce conflicts,
# since TEMP is not a reserved word.  See also OptTemp.
OptTempTableName  :
     OptTempTableName_1
   | OptTempTableName_2
   | OptTempTableName_3
   | OptTempTableName_4
   | OptTempTableName_5
   | OptTempTableName_6
   | OptTempTableName_7
   | OptTempTableName_8
   | OptTempTableName_9
;
OptTempTableName_1: TEMPORARY opt_table qualified_name
OptTempTableName_2: TEMP opt_table qualified_name
OptTempTableName_3: LOCAL TEMPORARY opt_table qualified_name
OptTempTableName_4: LOCAL TEMP opt_table qualified_name
OptTempTableName_5: GLOBAL TEMPORARY opt_table qualified_name
OptTempTableName_6: GLOBAL TEMP opt_table qualified_name
OptTempTableName_7: UNLOGGED opt_table qualified_name
OptTempTableName_8: TABLE qualified_name
OptTempTableName_9: qualified_name

opt_table  : opt_table_1?
opt_table_1: TABLE

opt_all  : (
     opt_all_1
   | opt_all_2
)?
opt_all_1: ALL
opt_all_2: DISTINCT

# We use (NIL) as a placeholder to indicate that all target expressions
# should be placed in the DISTINCT list during parsetree analysis.
opt_distinct  : (
     opt_distinct_1
   | opt_distinct_2
   | opt_distinct_3
)?
opt_distinct_1: DISTINCT
opt_distinct_2: DISTINCT ON <LPAREN> expr_list <RPAREN>
opt_distinct_3: ALL

opt_sort_clause  : opt_sort_clause_1?
opt_sort_clause_1: sort_clause

sort_clause: ORDER BY sortby_list

sortby_list  :
     sortby_list_1
   | sortby_list_2
;
sortby_list_1: sortby
sortby_list_2: sortby_list <COMMA> sortby  ### WARNING: Recursion; needs refactoring! ###

sortby  :
     sortby_1
   | sortby_2
;
sortby_1: a_expr USING qual_all_Op opt_nulls_order
sortby_2: a_expr opt_asc_desc opt_nulls_order

select_limit  :
     select_limit_1
   | select_limit_2
   | select_limit_3
   | select_limit_4
;
select_limit_1: limit_clause offset_clause
select_limit_2: offset_clause limit_clause
select_limit_3: limit_clause
select_limit_4: offset_clause

opt_select_limit  : opt_select_limit_1?
opt_select_limit_1: select_limit

limit_clause  :
     limit_clause_1
   | limit_clause_2
   | limit_clause_3
;
limit_clause_1: LIMIT select_limit_value
limit_clause_2: LIMIT select_limit_value <COMMA> select_offset_value 
# Disabled because it was too confusing, bjm 2002-02-18
    
## SQLite supports this format, so we'll go ahead and re-enable this.
## This would be 'LimitYX' in SQL::Abstract::Limit.
limit_clause_3: FETCH first_or_next opt_select_fetch_first_value row_or_rows ONLY

offset_clause  :
     offset_clause_1
   | offset_clause_2
;
offset_clause_1: OFFSET select_offset_value
offset_clause_2: OFFSET select_offset_value2 row_or_rows

select_limit_value  :
     select_limit_value_1
   | select_limit_value_2
;
select_limit_value_1: a_expr
select_limit_value_2: ALL

select_offset_value: a_expr

# Allowing full expressions without parentheses causes various parsing
# problems with the trailing ROW/ROWS key words.  SQL only calls for
# constants, so we allow the rest only with parentheses.  If omitted,
# default to 1.
opt_select_fetch_first_value  : (
     opt_select_fetch_first_value_1
   | opt_select_fetch_first_value_2
)?
opt_select_fetch_first_value_1: SignedIconst
opt_select_fetch_first_value_2: <LPAREN> a_expr <RPAREN>

# Again, the trailing ROW/ROWS in this case prevent the full expression
# syntax.  c_expr is the best we can do.
select_offset_value2: c_expr

# noise words
row_or_rows  :
     row_or_rows_1
   | row_or_rows_2
;
row_or_rows_1: ROW
row_or_rows_2: ROWS

first_or_next  :
     first_or_next_1
   | first_or_next_2
;
first_or_next_1: FIRST
first_or_next_2: NEXT

group_clause  : group_clause_1?
group_clause_1: GROUP BY expr_list

having_clause  : having_clause_1?
having_clause_1: HAVING a_expr

for_locking_clause  :
     for_locking_clause_1
   | for_locking_clause_2
;
for_locking_clause_1: for_locking_items
for_locking_clause_2: FOR READ ONLY

opt_for_locking_clause  : opt_for_locking_clause_1?
opt_for_locking_clause_1: for_locking_clause

for_locking_items  :
     for_locking_items_1
   | for_locking_items_2
;
for_locking_items_1: for_locking_item
for_locking_items_2: for_locking_items for_locking_item  ### WARNING: Recursion; needs refactoring! ###

for_locking_item  :
     for_locking_item_1
   | for_locking_item_2
;
for_locking_item_1: FOR UPDATE locked_rels_list opt_nowait
for_locking_item_2: FOR SHARE locked_rels_list opt_nowait

locked_rels_list  : locked_rels_list_1?
locked_rels_list_1: OF qualified_name_list

values_clause  :
     values_clause_1
   | values_clause_2
;
values_clause_1: VALUES ctext_row
values_clause_2: values_clause <COMMA> ctext_row  ### WARNING: Recursion; needs refactoring! ###

#############################################################################
#
#   clauses common to all Optimizable Stmts:
#      from_clause    - allow list of both JOIN expressions and table names
#      where_clause   - qualifications for joins or restrictions
#
#############################################################################
from_clause  : from_clause_1?
from_clause_1: FROM from_list

from_list  :
     from_list_1
   | from_list_2
;
from_list_1: table_ref
from_list_2: from_list <COMMA> table_ref  ### WARNING: Recursion; needs refactoring! ###

# table_ref is where an alias clause can be attached.   Note we cannot make
# alias_clause have an empty production because that causes parse conflicts
# between table_ref := '(' joined_table ')' alias_clause
# and joined_table := '(' joined_table ')'.  So, we must have the
# redundant-looking productions here instead.
table_ref   :
     table_ref_1
   | table_ref_2
   | table_ref_3
   | table_ref_4
   | table_ref_5
   | table_ref_6
   | table_ref_7
   | table_ref_8
   | table_ref_9
   | table_ref_10
   | table_ref_11
;
table_ref_1 : relation_expr
table_ref_2 : relation_expr alias_clause
table_ref_3 : func_table
table_ref_4 : func_table alias_clause
table_ref_5 : func_table AS <LPAREN> TableFuncElementList <RPAREN>
table_ref_6 : func_table AS ColId <LPAREN> TableFuncElementList <RPAREN>
table_ref_7 : func_table ColId <LPAREN> TableFuncElementList <RPAREN>
table_ref_8 : select_with_parens
table_ref_9 : select_with_parens alias_clause
table_ref_10: joined_table
table_ref_11: <LPAREN> joined_table <RPAREN> alias_clause

# It may seem silly to separate joined_table from table_ref, but there is
# method in SQL92's madness: if you don't do it this way you get reduce-
# reduce conflicts, because it's not clear to the parser generator whether
# to expect alias_clause after ')' or not.  For the same reason we must
# treat 'JOIN' and 'join_type JOIN' separately, rather than allowing
# join_type to expand to empty; if we try it, the parser generator can't
# figure out when to reduce an empty join_type right after table_ref.
#
# Note that a CROSS JOIN is the same as an unqualified
# INNER JOIN, and an INNER JOIN/ON has the same shape
# but a qualification expression to limit membership.
# A NATURAL JOIN implicitly matches column names between
# tables and the shape is determined by which columns are
# in common. We'll collect columns during the later transformations.
joined_table  :
     joined_table_1
   | joined_table_2
   | joined_table_3
   | joined_table_4
   | joined_table_5
   | joined_table_6
;
joined_table_1: <LPAREN> joined_table <RPAREN>  ### WARNING: Recursion; needs refactoring! ###
joined_table_2: table_ref CROSS JOIN table_ref
joined_table_3: table_ref join_type JOIN table_ref join_qual
joined_table_4: table_ref JOIN table_ref join_qual
joined_table_5: table_ref NATURAL join_type JOIN table_ref
joined_table_6: table_ref NATURAL JOIN table_ref

alias_clause  :
     alias_clause_1
   | alias_clause_2
   | alias_clause_3
   | alias_clause_4
;
alias_clause_1: AS ColId <LPAREN> name_list <RPAREN>
alias_clause_2: AS ColId
alias_clause_3: ColId <LPAREN> name_list <RPAREN>
alias_clause_4: ColId

join_type  :
     join_type_1
   | join_type_2
   | join_type_3
   | join_type_4
;
join_type_1: FULL join_outer
join_type_2: LEFT join_outer
join_type_3: RIGHT join_outer
join_type_4: INNER

# OUTER is just noise...
join_outer  : join_outer_1?
join_outer_1: OUTER

# JOIN qualification clauses
# Possibilities are:
#   USING ( column list ) allows only unqualified column names,
#                    which must match between tables.
#   ON expr allows more general qualifications.
#
# We return USING as a List node, while an ON-expr will not be a List.
join_qual  :
     join_qual_1
   | join_qual_2
;
join_qual_1: USING <LPAREN> name_list <RPAREN>
join_qual_2: ON a_expr

relation_expr  :
     relation_expr_1
   | relation_expr_2
   | relation_expr_3
   | relation_expr_4
;
relation_expr_1: qualified_name
relation_expr_2: qualified_name <STAR>
relation_expr_3: ONLY qualified_name
relation_expr_4: ONLY <LPAREN> qualified_name <RPAREN>

relation_expr_list  :
     relation_expr_list_1
   | relation_expr_list_2
;
relation_expr_list_1: relation_expr
relation_expr_list_2: relation_expr_list <COMMA> relation_expr  ### WARNING: Recursion; needs refactoring! ###

# Given "UPDATE foo set set ...", we have to decide without looking any
# further ahead whether the first "set" is an alias or the UPDATE's SET
# keyword.  Since "set" is allowed as a column name both interpretations
# are feasible.  We resolve the shift/reduce conflict by giving the first
# relation_expr_opt_alias production a higher precedence than the SET token
# has, causing the parser to prefer to reduce, in effect assuming that the
# SET is not an alias.
relation_expr_opt_alias  :
     relation_expr_opt_alias_1
   | relation_expr_opt_alias_2
   | relation_expr_opt_alias_3
;
relation_expr_opt_alias_1: relation_expr
relation_expr_opt_alias_2: relation_expr ColId
relation_expr_opt_alias_3: relation_expr AS ColId

func_table: func_expr

where_clause  : where_clause_1?
where_clause_1: WHERE a_expr

# variant for UPDATE and DELETE
where_or_current_clause  : (
     where_or_current_clause_1
   | where_or_current_clause_2
)?
where_or_current_clause_1: WHERE a_expr
where_or_current_clause_2: WHERE CURRENT OF cursor_name

OptTableFuncElementList  : OptTableFuncElementList_1?
OptTableFuncElementList_1: TableFuncElementList

TableFuncElementList  :
     TableFuncElementList_1
   | TableFuncElementList_2
;
TableFuncElementList_1: TableFuncElement
TableFuncElementList_2: TableFuncElementList <COMMA> TableFuncElement  ### WARNING: Recursion; needs refactoring! ###

TableFuncElement: ColId Typename opt_collate_clause

#############################################################################
#
#   Type syntax
#      SQL92 introduces a large amount of type-specific syntax.
#      Define individual clauses to handle these cases, and use
#       the generic case to handle regular type-extensible Postgres syntax.
#      - thomas 1997-10-10
#
#############################################################################
Typename  :
     Typename_1
   | Typename_2
   | Typename_3
   | Typename_4
   | Typename_5
   | Typename_6
;
Typename_1: SimpleTypename opt_array_bounds
Typename_2: SETOF SimpleTypename opt_array_bounds
Typename_3: SimpleTypename ARRAY <LSQUARE> Iconst <RSQUARE>
Typename_4: SETOF SimpleTypename ARRAY <LSQUARE> Iconst <RSQUARE>
Typename_5: SimpleTypename ARRAY
Typename_6: SETOF SimpleTypename ARRAY

opt_array_bounds  : (
     opt_array_bounds_1
   | opt_array_bounds_2
)?
opt_array_bounds_1: opt_array_bounds <LSQUARE> <RSQUARE>  ### WARNING: Recursion; needs refactoring! ###
opt_array_bounds_2: opt_array_bounds <LSQUARE> Iconst <RSQUARE>  ### WARNING: Recursion; needs refactoring! ###

SimpleTypename  :
     SimpleTypename_1
   | SimpleTypename_2
   | SimpleTypename_3
   | SimpleTypename_4
   | SimpleTypename_5
   | SimpleTypename_6
   | SimpleTypename_7
;
SimpleTypename_1: GenericType
SimpleTypename_2: Numeric
SimpleTypename_3: Bit
SimpleTypename_4: Character
SimpleTypename_5: ConstDatetime
SimpleTypename_6: ConstInterval opt_interval
SimpleTypename_7: ConstInterval <LPAREN> Iconst <RPAREN> opt_interval

# We have a separate ConstTypename to allow defaulting fixed-length
# types such as CHAR() and BIT() to an unspecified length.
# SQL9x requires that these default to a length of one, but this
# makes no sense for constructs like CHAR 'hi' and BIT '0101',
# where there is an obvious better choice to make.
# Note that ConstInterval is not included here since it must
# be pushed up higher in the rules to accomodate the postfix
# options (e.g. INTERVAL '1' YEAR). Likewise, we have to handle
# the generic-type-name case in AExprConst to avoid premature
# reduce/reduce conflicts against function names.
ConstTypename  :
     ConstTypename_1
   | ConstTypename_2
   | ConstTypename_3
   | ConstTypename_4
;
ConstTypename_1: Numeric
ConstTypename_2: ConstBit
ConstTypename_3: ConstCharacter
ConstTypename_4: ConstDatetime

# GenericType covers all type names that don't have special syntax mandated
# by the standard, including qualified names.  We also allow type modifiers.
# To avoid parsing conflicts against function invocations, the modifiers
# have to be shown as expr_list here, but parse analysis will only accept
# constants for them.
GenericType  :
     GenericType_1
   | GenericType_2
;
GenericType_1: type_function_name opt_type_modifiers
GenericType_2: type_function_name attrs opt_type_modifiers

opt_type_modifiers  : opt_type_modifiers_1?
opt_type_modifiers_1: <LPAREN> expr_list <RPAREN>

# SQL92 numeric data types
Numeric   :
     Numeric_1
   | Numeric_2
   | Numeric_3
   | Numeric_4
   | Numeric_5
   | Numeric_6
   | Numeric_7
   | Numeric_8
   | Numeric_9
   | Numeric_10
   | Numeric_11
;
Numeric_1 : INT
Numeric_2 : INTEGER
Numeric_3 : SMALLINT
Numeric_4 : BIGINT
Numeric_5 : REAL
Numeric_6 : FLOAT opt_float
Numeric_7 : DOUBLE PRECISION
Numeric_8 : DECIMAL opt_type_modifiers
Numeric_9 : DEC opt_type_modifiers
Numeric_10: NUMERIC opt_type_modifiers
Numeric_11: BOOLEAN

# Check FLOAT() precision limits assuming IEEE floating
# types - thomas 1997-09-18
opt_float  : opt_float_1?
opt_float_1: <LPAREN> Iconst <RPAREN>

# SQL92 bit-field data types
# The following implements BIT() and BIT VARYING().
Bit  :
     Bit_1
   | Bit_2
;
Bit_1: BitWithLength
Bit_2: BitWithoutLength

# ConstBit is like Bit except "BIT" defaults to unspecified length

# See notes for ConstCharacter, which addresses same issue for "CHAR"
ConstBit  :
     ConstBit_1
   | ConstBit_2
;
ConstBit_1: BitWithLength
ConstBit_2: BitWithoutLength

BitWithLength: BIT opt_varying <LPAREN> expr_list <RPAREN>

BitWithoutLength: BIT opt_varying

# SQL92 character data types
# The following implements CHAR() and VARCHAR().
Character  :
     Character_1
   | Character_2
;
Character_1: CharacterWithLength
Character_2: CharacterWithoutLength

ConstCharacter  :
     ConstCharacter_1
   | ConstCharacter_2
;
ConstCharacter_1: CharacterWithLength
ConstCharacter_2: CharacterWithoutLength

CharacterWithLength: character <LPAREN> Iconst <RPAREN> opt_charset

CharacterWithoutLength: character opt_charset

character  :
     character_1
   | character_2
   | character_3
   | character_4
   | character_5
   | character_6
;
character_1: CHARACTER opt_varying
character_2: CHAR opt_varying
character_3: VARCHAR
character_4: NATIONAL CHARACTER opt_varying
character_5: NATIONAL CHAR opt_varying
character_6: NCHAR opt_varying

opt_varying  : opt_varying_1?
opt_varying_1: VARYING

opt_charset  : opt_charset_1?
opt_charset_1: CHARACTER SET ColId

# SQL92 date/time types
ConstDatetime  :
     ConstDatetime_1
   | ConstDatetime_2
   | ConstDatetime_3
   | ConstDatetime_4
;
ConstDatetime_1: TIMESTAMP <LPAREN> Iconst <RPAREN> opt_timezone
ConstDatetime_2: TIMESTAMP opt_timezone
ConstDatetime_3: TIME <LPAREN> Iconst <RPAREN> opt_timezone
ConstDatetime_4: TIME opt_timezone

ConstInterval: INTERVAL

opt_timezone  : (
     opt_timezone_1
   | opt_timezone_2
)?
opt_timezone_1: WITH_TIME ZONE
opt_timezone_2: WITHOUT TIME ZONE

opt_interval   : (
     opt_interval_1
   | opt_interval_2
   | opt_interval_3
   | opt_interval_4
   | opt_interval_5
   | opt_interval_6
   | opt_interval_7
   | opt_interval_8
   | opt_interval_9
   | opt_interval_10
   | opt_interval_11
   | opt_interval_12
   | opt_interval_13
)?
opt_interval_1 : YEAR
opt_interval_2 : MONTH
opt_interval_3 : DAY
opt_interval_4 : HOUR
opt_interval_5 : MINUTE
opt_interval_6 : interval_second
opt_interval_7 : YEAR TO MONTH
opt_interval_8 : DAY TO HOUR
opt_interval_9 : DAY TO MINUTE
opt_interval_10: DAY TO interval_second
opt_interval_11: HOUR TO MINUTE
opt_interval_12: HOUR TO interval_second
opt_interval_13: MINUTE TO interval_second

interval_second  :
     interval_second_1
   | interval_second_2
;
interval_second_1: SECOND
interval_second_2: SECOND <LPAREN> Iconst <RPAREN>

#############################################################################
#
#   expression grammar
#
#############################################################################

# General expressions
# This is the heart of the expression syntax.
#
# We have two expression types: a_expr is the unrestricted kind, and
# b_expr is a subset that must be used in some places to avoid shift/reduce
# conflicts.  For example, we can't do BETWEEN as "BETWEEN a_expr AND a_expr"
# because that use of AND conflicts with AND as a boolean operator.  So,
# b_expr is used in BETWEEN and we remove boolean keywords from b_expr.
#
# Note that '(' a_expr ')' is a b_expr, so an unrestricted expression can
# always be used by surrounding it with parens.
#
# c_expr is all the productions that are common to a_expr and b_expr;
# it's factored out just to eliminate redundant coding.
a_expr   :
     a_expr_1
   | a_expr_2
   | a_expr_3
   | a_expr_4
   | a_expr_5
   | a_expr_6
   | a_expr_7
   | a_expr_8
   | a_expr_9
   | a_expr_10
   | a_expr_11
   | a_expr_12
   | a_expr_13
   | a_expr_14
   | a_expr_15
   | a_expr_16
   | a_expr_17
   | a_expr_18
   | a_expr_19
   | a_expr_20
   | a_expr_21
   | a_expr_22
   | a_expr_23
   | a_expr_24
   | a_expr_25
   | a_expr_26
   | a_expr_27
   | a_expr_28
   | a_expr_29
   | a_expr_30
   | a_expr_31
   | a_expr_32
   | a_expr_33
   | a_expr_34
   | a_expr_35
   | a_expr_36
   | a_expr_37
   | a_expr_38
   | a_expr_39
   | a_expr_40
   | a_expr_41
   | a_expr_42
   | a_expr_43
   | a_expr_44
   | a_expr_45
   | a_expr_46
   | a_expr_47
   | a_expr_48
   | a_expr_49
   | a_expr_50
   | a_expr_51
   | a_expr_52
   | a_expr_53
   | a_expr_54
   | a_expr_55
   | a_expr_56
   | a_expr_57
   | a_expr_58
   | a_expr_59
;
a_expr_1 : c_expr
a_expr_2 : a_expr TYPECAST Typename  ### WARNING: Recursion; needs refactoring! ###
a_expr_3 : a_expr COLLATE any_name  ### WARNING: Recursion; needs refactoring! ###
a_expr_4 : a_expr AT TIME ZONE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_5 : <PLUS> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_6 : <DASH> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_7 : a_expr <PLUS> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_8 : a_expr <DASH> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_9 : a_expr <STAR> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_10: a_expr <SLASH> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_11: a_expr <PERCENT> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_12: a_expr <CARET> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_13: a_expr <LANGLE> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_14: a_expr <RANGLE> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_15: a_expr <EQUAL> a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_16: a_expr qual_Op a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_17: qual_Op a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_18: a_expr qual_Op  ### WARNING: Recursion; needs refactoring! ###
a_expr_19: a_expr AND a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_20: a_expr OR a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_21: NOT a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_22: a_expr LIKE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_23: a_expr LIKE a_expr ESCAPE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_24: a_expr NOT LIKE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_25: a_expr NOT LIKE a_expr ESCAPE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_26: a_expr ILIKE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_27: a_expr ILIKE a_expr ESCAPE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_28: a_expr NOT ILIKE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_29: a_expr NOT ILIKE a_expr ESCAPE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_30: a_expr SIMILAR TO a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_31: a_expr SIMILAR TO a_expr ESCAPE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_32: a_expr NOT SIMILAR TO a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_33: a_expr NOT SIMILAR TO a_expr ESCAPE a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_34: a_expr IS NULL  ### WARNING: Recursion; needs refactoring! ###
a_expr_35: a_expr ISNULL  ### WARNING: Recursion; needs refactoring! ###
a_expr_36: a_expr IS NOT NULL  ### WARNING: Recursion; needs refactoring! ###
a_expr_37: a_expr NOTNULL  ### WARNING: Recursion; needs refactoring! ###
a_expr_38: row OVERLAPS row
a_expr_39: a_expr IS TRUE  ### WARNING: Recursion; needs refactoring! ###
a_expr_40: a_expr IS NOT TRUE  ### WARNING: Recursion; needs refactoring! ###
a_expr_41: a_expr IS FALSE  ### WARNING: Recursion; needs refactoring! ###
a_expr_42: a_expr IS NOT FALSE  ### WARNING: Recursion; needs refactoring! ###
a_expr_43: a_expr IS UNKNOWN  ### WARNING: Recursion; needs refactoring! ###
a_expr_44: a_expr IS NOT UNKNOWN  ### WARNING: Recursion; needs refactoring! ###
a_expr_45: a_expr IS DISTINCT FROM a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_46: a_expr IS NOT DISTINCT FROM a_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_47: a_expr IS OF <LPAREN> type_list <RPAREN>  ### WARNING: Recursion; needs refactoring! ###
a_expr_48: a_expr IS NOT OF <LPAREN> type_list <RPAREN>  ### WARNING: Recursion; needs refactoring! ###
a_expr_49: a_expr BETWEEN opt_asymmetric b_expr AND b_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_50: a_expr NOT BETWEEN opt_asymmetric b_expr AND b_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_51: a_expr BETWEEN SYMMETRIC b_expr AND b_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_52: a_expr NOT BETWEEN SYMMETRIC b_expr AND b_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_53: a_expr IN in_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_54: a_expr NOT IN in_expr  ### WARNING: Recursion; needs refactoring! ###
a_expr_55: a_expr subquery_Op sub_type select_with_parens  ### WARNING: Recursion; needs refactoring! ###
a_expr_56: a_expr subquery_Op sub_type <LPAREN> a_expr <RPAREN>  ### WARNING: Recursion; needs refactoring! ###
a_expr_57: UNIQUE select_with_parens
a_expr_58: a_expr IS DOCUMENT  ### WARNING: Recursion; needs refactoring! ###
a_expr_59: a_expr IS NOT DOCUMENT  ### WARNING: Recursion; needs refactoring! ###

# Restricted expressions
#
# b_expr is a subset of the complete expression syntax defined by a_expr.
#
# Presently, AND, NOT, IS, and IN are the a_expr keywords that would
# cause trouble in the places where b_expr is used.  For simplicity, we
# just eliminate all the boolean-keyword-operator productions from b_expr.
b_expr   :
     b_expr_1
   | b_expr_2
   | b_expr_3
   | b_expr_4
   | b_expr_5
   | b_expr_6
   | b_expr_7
   | b_expr_8
   | b_expr_9
   | b_expr_10
   | b_expr_11
   | b_expr_12
   | b_expr_13
   | b_expr_14
   | b_expr_15
   | b_expr_16
   | b_expr_17
   | b_expr_18
   | b_expr_19
   | b_expr_20
   | b_expr_21
   | b_expr_22
;
b_expr_1 : c_expr
b_expr_2 : b_expr TYPECAST Typename  ### WARNING: Recursion; needs refactoring! ###
b_expr_3 : <PLUS> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_4 : <DASH> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_5 : b_expr <PLUS> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_6 : b_expr <DASH> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_7 : b_expr <STAR> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_8 : b_expr <SLASH> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_9 : b_expr <PERCENT> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_10: b_expr <CARET> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_11: b_expr <LANGLE> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_12: b_expr <RANGLE> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_13: b_expr <EQUAL> b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_14: b_expr qual_Op b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_15: qual_Op b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_16: b_expr qual_Op  ### WARNING: Recursion; needs refactoring! ###
b_expr_17: b_expr IS DISTINCT FROM b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_18: b_expr IS NOT DISTINCT FROM b_expr  ### WARNING: Recursion; needs refactoring! ###
b_expr_19: b_expr IS OF <LPAREN> type_list <RPAREN>  ### WARNING: Recursion; needs refactoring! ###
b_expr_20: b_expr IS NOT OF <LPAREN> type_list <RPAREN>  ### WARNING: Recursion; needs refactoring! ###
b_expr_21: b_expr IS DOCUMENT  ### WARNING: Recursion; needs refactoring! ###
b_expr_22: b_expr IS NOT DOCUMENT  ### WARNING: Recursion; needs refactoring! ###

# Productions that can be used in both a_expr and b_expr.
#
# Note: productions that refer recursively to a_expr or b_expr mostly
# cannot appear here.   However, it's OK to refer to a_exprs that occur
# inside parentheses, such as function arguments; that cannot introduce
# ambiguity to the b_expr syntax.
c_expr   :
     c_expr_1
   | c_expr_2
   | c_expr_3
   | c_expr_4
   | c_expr_5
   | c_expr_6
   | c_expr_7
   | c_expr_8
   | c_expr_9
   | c_expr_10
   | c_expr_11
;
c_expr_1 : columnref
c_expr_2 : AexprConst
c_expr_3 : PARAM opt_indirection
c_expr_4 : <LPAREN> a_expr <RPAREN> opt_indirection
c_expr_5 : case_expr
c_expr_6 : func_expr
c_expr_7 : select_with_parens
c_expr_8 : EXISTS select_with_parens
c_expr_9 : ARRAY select_with_parens
c_expr_10: ARRAY array_expr
c_expr_11: row

# func_expr is split out from c_expr just so that we have a classification
# for "everything that is a function call or looks like one".  This isn't
# very important, but it saves us having to document which variants are
# legal in the backwards-compatible functional-index syntax for CREATE INDEX.
# (Note that many of the special SQL functions wouldn't actually make any
# sense as functional index entries, but we ignore that consideration here.)
func_expr   :
     func_expr_1
   | func_expr_2
   | func_expr_3
   | func_expr_4
   | func_expr_5
   | func_expr_6
   | func_expr_7
   | func_expr_8
   | func_expr_9
   | func_expr_10
   | func_expr_11
   | func_expr_12
   | func_expr_13
   | func_expr_14
   | func_expr_15
   | func_expr_16
   | func_expr_17
   | func_expr_18
   | func_expr_19
   | func_expr_20
   | func_expr_21
   | func_expr_22
   | func_expr_23
   | func_expr_24
   | func_expr_25
   | func_expr_26
   | func_expr_27
   | func_expr_28
   | func_expr_29
   | func_expr_30
   | func_expr_31
   | func_expr_32
   | func_expr_33
   | func_expr_34
   | func_expr_35
   | func_expr_36
   | func_expr_37
   | func_expr_38
   | func_expr_39
   | func_expr_40
   | func_expr_41
   | func_expr_42
   | func_expr_43
   | func_expr_44
   | func_expr_45
   | func_expr_46
   | func_expr_47
   | func_expr_48
   | func_expr_49
;
func_expr_1 : func_name <LPAREN> <RPAREN> over_clause
func_expr_2 : func_name <LPAREN> func_arg_list <RPAREN> over_clause
func_expr_3 : func_name <LPAREN> VARIADIC func_arg_expr <RPAREN> over_clause
func_expr_4 : func_name <LPAREN> func_arg_list <COMMA> VARIADIC func_arg_expr <RPAREN> over_clause
func_expr_5 : func_name <LPAREN> func_arg_list sort_clause <RPAREN> over_clause
func_expr_6 : func_name <LPAREN> ALL func_arg_list opt_sort_clause <RPAREN> over_clause
func_expr_7 : func_name <LPAREN> DISTINCT func_arg_list opt_sort_clause <RPAREN> over_clause
func_expr_8 : func_name <LPAREN> <STAR> <RPAREN> over_clause
func_expr_9 : CURRENT_DATE
func_expr_10: CURRENT_TIME
func_expr_11: CURRENT_TIME <LPAREN> Iconst <RPAREN>
func_expr_12: CURRENT_TIMESTAMP
func_expr_13: CURRENT_TIMESTAMP <LPAREN> Iconst <RPAREN>
func_expr_14: LOCALTIME
func_expr_15: LOCALTIME <LPAREN> Iconst <RPAREN>
func_expr_16: LOCALTIMESTAMP
func_expr_17: LOCALTIMESTAMP <LPAREN> Iconst <RPAREN>
func_expr_18: CURRENT_ROLE
func_expr_19: CURRENT_USER
func_expr_20: SESSION_USER
func_expr_21: USER
func_expr_22: CURRENT_CATALOG
func_expr_23: CURRENT_SCHEMA
func_expr_24: CAST <LPAREN> a_expr AS Typename <RPAREN>
func_expr_25: EXTRACT <LPAREN> extract_list <RPAREN>
func_expr_26: OVERLAY <LPAREN> overlay_list <RPAREN>
func_expr_27: POSITION <LPAREN> position_list <RPAREN>
func_expr_28: SUBSTRING <LPAREN> substr_list <RPAREN>
func_expr_29: TREAT <LPAREN> a_expr AS Typename <RPAREN>
func_expr_30: TRIM <LPAREN> BOTH trim_list <RPAREN>
func_expr_31: TRIM <LPAREN> LEADING trim_list <RPAREN>
func_expr_32: TRIM <LPAREN> TRAILING trim_list <RPAREN>
func_expr_33: TRIM <LPAREN> trim_list <RPAREN>
func_expr_34: NULLIF <LPAREN> a_expr <COMMA> a_expr <RPAREN>
func_expr_35: COALESCE <LPAREN> expr_list <RPAREN>
func_expr_36: GREATEST <LPAREN> expr_list <RPAREN>
func_expr_37: LEAST <LPAREN> expr_list <RPAREN>
func_expr_38: XMLCONCAT <LPAREN> expr_list <RPAREN>
func_expr_39: XMLELEMENT <LPAREN> NAME ColLabel <RPAREN>
func_expr_40: XMLELEMENT <LPAREN> NAME ColLabel <COMMA> xml_attributes <RPAREN>
func_expr_41: XMLELEMENT <LPAREN> NAME ColLabel <COMMA> expr_list <RPAREN>
func_expr_42: XMLELEMENT <LPAREN> NAME ColLabel <COMMA> xml_attributes <COMMA> expr_list <RPAREN>
func_expr_43: XMLEXISTS <LPAREN> c_expr xmlexists_argument <RPAREN>
func_expr_44: XMLFOREST <LPAREN> xml_attribute_list <RPAREN>
func_expr_45: XMLPARSE <LPAREN> document_or_content a_expr xml_whitespace_option <RPAREN>
func_expr_46: XMLPI <LPAREN> NAME ColLabel <RPAREN>
func_expr_47: XMLPI <LPAREN> NAME ColLabel <COMMA> a_expr <RPAREN>
func_expr_48: XMLROOT <LPAREN> a_expr <COMMA> xml_root_version opt_xml_root_standalone <RPAREN>
func_expr_49: XMLSERIALIZE <LPAREN> document_or_content a_expr AS SimpleTypename <RPAREN>

# SQL/XML support
xml_root_version  :
     xml_root_version_1
   | xml_root_version_2
;
xml_root_version_1: VERSION a_expr
xml_root_version_2: VERSION NO VALUE

opt_xml_root_standalone  : (
     opt_xml_root_standalone_1
   | opt_xml_root_standalone_2
   | opt_xml_root_standalone_3
)?
opt_xml_root_standalone_1: <COMMA> STANDALONE YES
opt_xml_root_standalone_2: <COMMA> STANDALONE NO
opt_xml_root_standalone_3: <COMMA> STANDALONE NO VALUE

xml_attributes: XMLATTRIBUTES <LPAREN> xml_attribute_list <RPAREN>

xml_attribute_list  :
     xml_attribute_list_1
   | xml_attribute_list_2
;
xml_attribute_list_1: xml_attribute_el
xml_attribute_list_2: xml_attribute_list <COMMA> xml_attribute_el  ### WARNING: Recursion; needs refactoring! ###

xml_attribute_el  :
     xml_attribute_el_1
   | xml_attribute_el_2
;
xml_attribute_el_1: a_expr AS ColLabel
xml_attribute_el_2: a_expr

document_or_content  :
     document_or_content_1
   | document_or_content_2
;
document_or_content_1: DOCUMENT
document_or_content_2: CONTENT

xml_whitespace_option  : (
     xml_whitespace_option_1
   | xml_whitespace_option_2
)?
xml_whitespace_option_1: PRESERVE WHITESPACE
xml_whitespace_option_2: STRIP WHITESPACE

# We allow several variants for SQL and other compatibility.
xmlexists_argument  :
     xmlexists_argument_1
   | xmlexists_argument_2
   | xmlexists_argument_3
   | xmlexists_argument_4
;
xmlexists_argument_1: PASSING c_expr
xmlexists_argument_2: PASSING c_expr BY REF
xmlexists_argument_3: PASSING BY REF c_expr
xmlexists_argument_4: PASSING BY REF c_expr BY REF

# Window Definitions
window_clause  : window_clause_1?
window_clause_1: WINDOW window_definition_list

window_definition_list  :
     window_definition_list_1
   | window_definition_list_2
;
window_definition_list_1: window_definition
window_definition_list_2: window_definition_list <COMMA> window_definition  ### WARNING: Recursion; needs refactoring! ###

window_definition: ColId AS window_specification

over_clause  : (
     over_clause_1
   | over_clause_2
)?
over_clause_1: OVER window_specification
over_clause_2: OVER ColId

window_specification: <LPAREN> opt_existing_window_name opt_partition_clause opt_sort_clause opt_frame_clause <RPAREN>

# If we see PARTITION, RANGE, or ROWS as the first token after the '('
# of a window_specification, we want the assumption to be that there is
# no existing_window_name; but those keywords are unreserved and so could
# be ColIds.  We fix this by making them have the same precedence as IDENT
# and giving the empty production here a slightly higher precedence, so
# that the shift/reduce conflict is resolved in favor of reducing the rule.
# These keywords are thus precluded from being an existing_window_name but
# are not reserved for any other purpose.
opt_existing_window_name  : opt_existing_window_name_1?
opt_existing_window_name_1: ColId

opt_partition_clause  : opt_partition_clause_1?
opt_partition_clause_1: PARTITION BY expr_list

# For frame clauses, we return a WindowDef, but only some fields are used:
# frameOptions, startOffset, and endOffset.
#
# This is only a subset of the full SQL:2008 frame_clause grammar.
# We don't support <window frame exclusion> yet.
opt_frame_clause  : (
     opt_frame_clause_1
   | opt_frame_clause_2
)?
opt_frame_clause_1: RANGE frame_extent
opt_frame_clause_2: ROWS frame_extent

frame_extent  :
     frame_extent_1
   | frame_extent_2
;
frame_extent_1: frame_bound
frame_extent_2: BETWEEN frame_bound AND frame_bound

# This is used for both frame start and frame end, with output set up on
# the assumption it's frame start; the frame_extent productions must reject
# invalid cases.
frame_bound  :
     frame_bound_1
   | frame_bound_2
   | frame_bound_3
   | frame_bound_4
   | frame_bound_5
;
frame_bound_1: UNBOUNDED PRECEDING
frame_bound_2: UNBOUNDED FOLLOWING
frame_bound_3: CURRENT ROW
frame_bound_4: a_expr PRECEDING
frame_bound_5: a_expr FOLLOWING

# Supporting nonterminals for expressions.

# Explicit row production.
#
# SQL99 allows an optional ROW keyword, so we can now do single-element rows
# without conflicting with the parenthesized a_expr production.  Without the
# ROW keyword, there must be more than one a_expr inside the parens.
row  :
     row_1
   | row_2
   | row_3
;
row_1: ROW <LPAREN> expr_list <RPAREN>
row_2: ROW <LPAREN> <RPAREN>
row_3: <LPAREN> expr_list <COMMA> a_expr <RPAREN>

sub_type  :
     sub_type_1
   | sub_type_2
   | sub_type_3
;
sub_type_1: ANY
sub_type_2: SOME
sub_type_3: ALL

all_Op  :
     all_Op_1
   | all_Op_2
;
all_Op_1: Op
all_Op_2: MathOp

MathOp  :
     MathOp_1
   | MathOp_2
   | MathOp_3
   | MathOp_4
   | MathOp_5
   | MathOp_6
   | MathOp_7
   | MathOp_8
   | MathOp_9
;
MathOp_1: <PLUS>
MathOp_2: <DASH>
MathOp_3: <STAR>
MathOp_4: <SLASH>
MathOp_5: <PERCENT>
MathOp_6: <CARET>
MathOp_7: <LANGLE>
MathOp_8: <RANGLE>
MathOp_9: <EQUAL>

qual_Op  :
     qual_Op_1
   | qual_Op_2
;
qual_Op_1: Op
qual_Op_2: OPERATOR <LPAREN> any_operator <RPAREN>

qual_all_Op  :
     qual_all_Op_1
   | qual_all_Op_2
;
qual_all_Op_1: all_Op
qual_all_Op_2: OPERATOR <LPAREN> any_operator <RPAREN>

subquery_Op  :
     subquery_Op_1
   | subquery_Op_2
   | subquery_Op_3
   | subquery_Op_4
   | subquery_Op_5
   | subquery_Op_6
;
subquery_Op_1: all_Op
subquery_Op_2: OPERATOR <LPAREN> any_operator <RPAREN>
subquery_Op_3: LIKE
subquery_Op_4: NOT LIKE
subquery_Op_5: ILIKE
subquery_Op_6: NOT ILIKE

expr_list  :
     expr_list_1
   | expr_list_2
;
expr_list_1: a_expr
expr_list_2: expr_list <COMMA> a_expr  ### WARNING: Recursion; needs refactoring! ###

# function arguments can have names
func_arg_list  :
     func_arg_list_1
   | func_arg_list_2
;
func_arg_list_1: func_arg_expr
func_arg_list_2: func_arg_list <COMMA> func_arg_expr  ### WARNING: Recursion; needs refactoring! ###

func_arg_expr  :
     func_arg_expr_1
   | func_arg_expr_2
;
func_arg_expr_1: a_expr
func_arg_expr_2: param_name COLON_EQUALS a_expr

type_list  :
     type_list_1
   | type_list_2
;
type_list_1: Typename
type_list_2: type_list <COMMA> Typename  ### WARNING: Recursion; needs refactoring! ###

array_expr  :
     array_expr_1
   | array_expr_2
   | array_expr_3
;
array_expr_1: <LSQUARE> expr_list <RSQUARE>
array_expr_2: <LSQUARE> array_expr_list <RSQUARE>
array_expr_3: <LSQUARE> <RSQUARE>

array_expr_list  :
     array_expr_list_1
   | array_expr_list_2
;
array_expr_list_1: array_expr
array_expr_list_2: array_expr_list <COMMA> array_expr  ### WARNING: Recursion; needs refactoring! ###

extract_list  : extract_list_1?
extract_list_1: extract_arg FROM a_expr

# Allow delimited string Sconst in extract_arg as an SQL extension.
# - thomas 2001-04-12
extract_arg  :
     extract_arg_1
   | extract_arg_2
   | extract_arg_3
   | extract_arg_4
   | extract_arg_5
   | extract_arg_6
   | extract_arg_7
   | extract_arg_8
;
extract_arg_1: IDENT
extract_arg_2: YEAR
extract_arg_3: MONTH
extract_arg_4: DAY
extract_arg_5: HOUR
extract_arg_6: MINUTE
extract_arg_7: SECOND
extract_arg_8: Sconst

# OVERLAY() arguments
# SQL99 defines the OVERLAY() function:
# o overlay(text placing text from int for int)
# o overlay(text placing text from int)
# and similarly for binary strings
overlay_list  :
     overlay_list_1
   | overlay_list_2
;
overlay_list_1: a_expr overlay_placing substr_from substr_for
overlay_list_2: a_expr overlay_placing substr_from

overlay_placing: PLACING a_expr

# position_list uses b_expr not a_expr to avoid conflict with general IN
position_list  : position_list_1?
position_list_1: b_expr IN b_expr

# SUBSTRING() arguments
# SQL9x defines a specific syntax for arguments to SUBSTRING():
# o substring(text from int for int)
# o substring(text from int) get entire string from starting point "int"
# o substring(text for int) get first "int" characters of string
# o substring(text from pattern) get entire string matching pattern
# o substring(text from pattern for escape) same with specified escape char
# We also want to support generic substring functions which accept
# the usual generic list of arguments. So we will accept both styles
# here, and convert the SQL9x style to the generic list for further
# processing. - thomas 2000-11-28
substr_list  : (
     substr_list_1
   | substr_list_2
   | substr_list_3
   | substr_list_4
   | substr_list_5
)?
substr_list_1: a_expr substr_from substr_for
substr_list_2: a_expr substr_for substr_from
substr_list_3: a_expr substr_from
substr_list_4: a_expr substr_for
substr_list_5: expr_list

substr_from: FROM a_expr

substr_for: FOR a_expr

trim_list  :
     trim_list_1
   | trim_list_2
   | trim_list_3
;
trim_list_1: a_expr FROM expr_list
trim_list_2: FROM expr_list
trim_list_3: expr_list

in_expr  :
     in_expr_1
   | in_expr_2
;
in_expr_1: select_with_parens
in_expr_2: <LPAREN> expr_list <RPAREN>

# Define SQL92-style case clause.
# - Full specification
#   CASE WHEN a = b THEN c ... ELSE d END
# - Implicit argument
#   CASE a WHEN b THEN c ... ELSE d END
case_expr: CASE case_arg when_clause_list case_default END

when_clause_list  :
     when_clause_list_1
   | when_clause_list_2
;
when_clause_list_1: 
# There must be at least one
    when_clause
when_clause_list_2: when_clause_list when_clause  ### WARNING: Recursion; needs refactoring! ###

when_clause: WHEN a_expr THEN a_expr

case_default  : case_default_1?
case_default_1: ELSE a_expr

case_arg  : case_arg_1?
case_arg_1: a_expr

columnref  :
     columnref_1
   | columnref_2
;
columnref_1: ColId
columnref_2: ColId indirection

indirection_el  :
     indirection_el_1
   | indirection_el_2
   | indirection_el_3
   | indirection_el_4
;
indirection_el_1: <DOT> attr_name
indirection_el_2: <DOT> <STAR>
indirection_el_3: <LSQUARE> a_expr <RSQUARE>
indirection_el_4: <LSQUARE> a_expr <COLON> a_expr <RSQUARE>

indirection  :
     indirection_1
   | indirection_2
;
indirection_1: indirection_el
indirection_2: indirection indirection_el  ### WARNING: Recursion; needs refactoring! ###

opt_indirection  : opt_indirection_1?
opt_indirection_1: opt_indirection indirection_el  ### WARNING: Recursion; needs refactoring! ###

opt_asymmetric: ASYMMETRIC?

# The SQL spec defines "contextually typed value expressions" and
# "contextually typed row value constructors", which for our purposes
# are the same as "a_expr" and "row" except that DEFAULT can appear at
# the top level.
ctext_expr  :
     ctext_expr_1
   | ctext_expr_2
;
ctext_expr_1: a_expr
ctext_expr_2: DEFAULT

ctext_expr_list  :
     ctext_expr_list_1
   | ctext_expr_list_2
;
ctext_expr_list_1: ctext_expr
ctext_expr_list_2: ctext_expr_list <COMMA> ctext_expr  ### WARNING: Recursion; needs refactoring! ###

# We should allow ROW '(' ctext_expr_list ')' too, but that seems to require
# making VALUES a fully reserved word, which will probably break more apps
# than allowing the noise-word is worth.
ctext_row: <LPAREN> ctext_expr_list <RPAREN>

#############################################################################
#
#   target list for SELECT
#
#############################################################################
target_list  :
     target_list_1
   | target_list_2
;
target_list_1: target_el
target_list_2: target_list <COMMA> target_el  ### WARNING: Recursion; needs refactoring! ###

target_el  :
     target_el_1
   | target_el_2
   | target_el_3
   | target_el_4
;
target_el_1: a_expr AS ColLabel
target_el_2: a_expr IDENT
target_el_3: a_expr
target_el_4: <STAR>

#############################################################################
#
#   Names and constants
#
#############################################################################
qualified_name_list  :
     qualified_name_list_1
   | qualified_name_list_2
;
qualified_name_list_1: qualified_name
qualified_name_list_2: qualified_name_list <COMMA> qualified_name  ### WARNING: Recursion; needs refactoring! ###

# The production for a qualified relation name has to exactly match the
# production for a qualified func_name, because in a FROM clause we cannot
# tell which we are parsing until we see what comes after it ('(' for a
# func_name, something else for a relation). Therefore we allow 'indirection'
# which may contain subscripts, and reject that case in the C code.
qualified_name  :
     qualified_name_1
   | qualified_name_2
;
qualified_name_1: ColId
qualified_name_2: ColId indirection

name_list  :
     name_list_1
   | name_list_2
;
name_list_1: name
name_list_2: name_list <COMMA> name  ### WARNING: Recursion; needs refactoring! ###

name: ColId

database_name: ColId

access_method: ColId

attr_name: ColLabel

index_name: ColId

file_name: Sconst

# The production for a qualified func_name has to exactly match the
# production for a qualified columnref, because we cannot tell which we
# are parsing until we see what comes after it ('(' or Sconst for a func_name,
# anything else for a columnref).  Therefore we allow 'indirection' which
# may contain subscripts, and reject that case in the C code.  (If we
# ever implement SQL99-like methods, such syntax may actually become legal!)
func_name  :
     func_name_1
   | func_name_2
;
func_name_1: type_function_name
func_name_2: ColId indirection

# Constants
AexprConst   :
     AexprConst_1
   | AexprConst_2
   | AexprConst_3
   | AexprConst_4
   | AexprConst_5
   | AexprConst_6
   | AexprConst_7
   | AexprConst_8
   | AexprConst_9
   | AexprConst_10
   | AexprConst_11
   | AexprConst_12
   | AexprConst_13
;
AexprConst_1 : Iconst
AexprConst_2 : FCONST
AexprConst_3 : Sconst
AexprConst_4 : BCONST
AexprConst_5 : XCONST
AexprConst_6 : func_name Sconst
AexprConst_7 : func_name <LPAREN> func_arg_list <RPAREN> Sconst
AexprConst_8 : ConstTypename Sconst
AexprConst_9 : ConstInterval Sconst opt_interval
AexprConst_10: ConstInterval <LPAREN> Iconst <RPAREN> Sconst opt_interval
AexprConst_11: TRUE
AexprConst_12: FALSE
AexprConst_13: NULL

Iconst: ICONST

Sconst: SCONST

RoleId: ColId

SignedIconst  :
     SignedIconst_1
   | SignedIconst_2
   | SignedIconst_3
;
SignedIconst_1: Iconst
SignedIconst_2: <PLUS> Iconst
SignedIconst_3: <DASH> Iconst

# Name classification hierarchy.
#
# IDENT is the lexeme returned by the lexer for identifiers that match
# no known keyword.  In most cases, we can accept certain keywords as
# names, not only IDENTs.   We prefer to accept as many such keywords
# as possible to minimize the impact of "reserved words" on programmers.
# So, we divide names into several possible classes.  The classification
# is chosen in part to make keywords acceptable as names wherever possible.

# Column identifier --- names that can be column, table, etc names.
ColId  :
     ColId_1
   | ColId_2
   | ColId_3
;
ColId_1: IDENT
ColId_2: unreserved_keyword
ColId_3: col_name_keyword

# Type/function identifier --- names that can be type or function names.
type_function_name  :
     type_function_name_1
   | type_function_name_2
   | type_function_name_3
;
type_function_name_1: IDENT
type_function_name_2: unreserved_keyword
type_function_name_3: type_func_name_keyword

# Column label --- allowed labels in "AS" clauses.
# This presently includes *all* Postgres keywords.
ColLabel  :
     ColLabel_1
   | ColLabel_2
   | ColLabel_3
   | ColLabel_4
   | ColLabel_5
;
ColLabel_1: IDENT
ColLabel_2: unreserved_keyword
ColLabel_3: col_name_keyword
ColLabel_4: type_func_name_keyword
ColLabel_5: reserved_keyword

# Keyword category lists.  Generally, every keyword present in
# the Postgres grammar should appear in exactly one of these lists.
#
# Put a new keyword into the first list that it can go into without causing
# shift or reduce conflicts.  The earlier lists define "less reserved"
# categories of keywords.
#
# Make sure that each keyword's category in kwlist.h matches where
# it is listed here.  (Someday we may be able to generate these lists and
# kwlist.h's table from a common master list.)

# "Unreserved" keywords --- available for use as any kind of name.
unreserved_keyword:
     ABORT
   | ABSOLUTE
   | ACCESS
   | ACTION
   | ADD
   | ADMIN
   | AFTER
   | AGGREGATE
   | ALSO
   | ALTER
   | ALWAYS
   | ASSERTION
   | ASSIGNMENT
   | AT
   | ATTRIBUTE
   | BACKWARD
   | BEFORE
   | BEGIN
   | BY
   | CACHE
   | CALLED
   | CASCADE
   | CASCADED
   | CATALOG
   | CHAIN
   | CHARACTERISTICS
   | CHECKPOINT
   | CLASS
   | CLOSE
   | CLUSTER
   | COMMENT
   | COMMENTS
   | COMMIT
   | COMMITTED
   | CONFIGURATION
   | CONNECTION
   | CONSTRAINTS
   | CONTENT
   | CONTINUE
   | CONVERSION
   | COPY
   | COST
   | CSV
   | CURRENT
   | CURSOR
   | CYCLE
   | DATA
   | DATABASE
   | DAY
   | DEALLOCATE
   | DECLARE
   | DEFAULTS
   | DEFERRED
   | DEFINER
   | DELETE
   | DELIMITER
   | DELIMITERS
   | DICTIONARY
   | DISABLE
   | DISCARD
   | DOCUMENT
   | DOMAIN
   | DOUBLE
   | DROP
   | EACH
   | ENABLE
   | ENCODING
   | ENCRYPTED
   | ENUM
   | ESCAPE
   | EXCLUDE
   | EXCLUDING
   | EXCLUSIVE
   | EXECUTE
   | EXPLAIN
   | EXTENSION
   | EXTERNAL
   | FAMILY
   | FIRST
   | FOLLOWING
   | FORCE
   | FORWARD
   | FUNCTION
   | FUNCTIONS
   | GLOBAL
   | GRANTED
   | HANDLER
   | HEADER
   | HOLD
   | HOUR
   | IDENTITY
   | IF
   | IMMEDIATE
   | IMMUTABLE
   | IMPLICIT
   | INCLUDING
   | INCREMENT
   | INDEX
   | INDEXES
   | INHERIT
   | INHERITS
   | INLINE
   | INPUT
   | INSENSITIVE
   | INSERT
   | INSTEAD
   | INVOKER
   | ISOLATION
   | KEY
   | LABEL
   | LANGUAGE
   | LARGE
   | LAST
   | LC_COLLATE
   | LC_CTYPE
   | LEAKPROOF
   | LEVEL
   | LISTEN
   | LOAD
   | LOCAL
   | LOCATION
   | LOCK
   | MAPPING
   | MATCH
   | MAXVALUE
   | MINUTE
   | MINVALUE
   | MODE
   | MONTH
   | MOVE
   | NAME
   | NAMES
   | NEXT
   | NO
   | NOTHING
   | NOTIFY
   | NOWAIT
   | NULLS
   | OBJECT
   | OF
   | OFF
   | OIDS
   | OPERATOR
   | OPTION
   | OPTIONS
   | OWNED
   | OWNER
   | PARSER
   | PARTIAL
   | PARTITION
   | PASSING
   | PASSWORD
   | PLANS
   | PRECEDING
   | PREPARE
   | PREPARED
   | PRESERVE
   | PRIOR
   | PRIVILEGES
   | PROCEDURAL
   | PROCEDURE
   | QUOTE
   | RANGE
   | READ
   | REASSIGN
   | RECHECK
   | RECURSIVE
   | REF
   | REINDEX
   | RELATIVE
   | RELEASE
   | RENAME
   | REPEATABLE
   | REPLACE
   | REPLICA
   | RESET
   | RESTART
   | RESTRICT
   | RETURNS
   | REVOKE
   | ROLE
   | ROLLBACK
   | ROWS
   | RULE
   | SAVEPOINT
   | SCHEMA
   | SCROLL
   | SEARCH
   | SECOND
   | SECURITY
   | SEQUENCE
   | SEQUENCES
   | SERIALIZABLE
   | SERVER
   | SESSION
   | SET
   | SHARE
   | SHOW
   | SIMPLE
   | SNAPSHOT
   | STABLE
   | STANDALONE
   | START
   | STATEMENT
   | STATISTICS
   | STDIN
   | STDOUT
   | STORAGE
   | STRICT
   | STRIP
   | SYSID
   | SYSTEM
   | TABLES
   | TABLESPACE
   | TEMP
   | TEMPLATE
   | TEMPORARY
   | TEXT
   | TRANSACTION
   | TRIGGER
   | TRUNCATE
   | TRUSTED
   | TYPE
   | TYPES
   | UNBOUNDED
   | UNCOMMITTED
   | UNENCRYPTED
   | UNKNOWN
   | UNLISTEN
   | UNLOGGED
   | UNTIL
   | UPDATE
   | VACUUM
   | VALID
   | VALIDATE
   | VALIDATOR
   | VALUE
   | VARYING
   | VERSION
   | VIEW
   | VOLATILE
   | WHITESPACE
   | WITHOUT
   | WORK
   | WRAPPER
   | WRITE
   | XML
   | YEAR
   | YES
   | ZONE
;

# Column identifier --- keywords that can be column, table, etc names.
#
# Many of these keywords will in fact be recognized as type or function
# names too; but they have special productions for the purpose, and so
# can't be treated as "generic" type or function names.
#
# The type names appearing here are not usable as function names
# because they can be followed by '(' in typename productions, which
# looks too much like a function call for an LR(1) parser.
col_name_keyword:
     BETWEEN
   | BIGINT
   | BIT
   | BOOLEAN
   | CHAR
   | CHARACTER
   | COALESCE
   | DEC
   | DECIMAL
   | EXISTS
   | EXTRACT
   | FLOAT
   | GREATEST
   | INOUT
   | INT
   | INTEGER
   | INTERVAL
   | LEAST
   | NATIONAL
   | NCHAR
   | NONE
   | NULLIF
   | NUMERIC
   | OUT
   | OVERLAY
   | POSITION
   | PRECISION
   | REAL
   | ROW
   | SETOF
   | SMALLINT
   | SUBSTRING
   | TIME
   | TIMESTAMP
   | TREAT
   | TRIM
   | VALUES
   | VARCHAR
   | XMLATTRIBUTES
   | XMLCONCAT
   | XMLELEMENT
   | XMLEXISTS
   | XMLFOREST
   | XMLPARSE
   | XMLPI
   | XMLROOT
   | XMLSERIALIZE
;

# Type/function identifier --- keywords that can be type or function names.
#
# Most of these are keywords that are used as operators in expressions;
# in general such keywords can't be column names because they would be
# ambiguous with variables, but they are unambiguous as function identifiers.
#
# Do not include POSITION, SUBSTRING, etc here since they have explicit
# productions in a_expr to support the goofy SQL9x argument syntax.
# - thomas 2000-11-28
type_func_name_keyword:
     AUTHORIZATION
   | BINARY
   | COLLATION
   | CONCURRENTLY
   | CROSS
   | CURRENT_SCHEMA
   | FREEZE
   | FULL
   | ILIKE
   | INNER
   | IS
   | ISNULL
   | JOIN
   | LEFT
   | LIKE
   | NATURAL
   | NOTNULL
   | OUTER
   | OVER
   | OVERLAPS
   | RIGHT
   | SIMILAR
   | VERBOSE
;

# Reserved keyword --- these keywords are usable only as a ColLabel.
#
# Keywords appear here if they could not be distinguished from variable,
# type, or function names in some contexts.  Don't put things here unless
# forced to.
reserved_keyword:
     ALL
   | ANALYSE
   | ANALYZE
   | AND
   | ANY
   | ARRAY
   | AS
   | ASC
   | ASYMMETRIC
   | BOTH
   | CASE
   | CAST
   | CHECK
   | COLLATE
   | COLUMN
   | CONSTRAINT
   | CREATE
   | CURRENT_CATALOG
   | CURRENT_DATE
   | CURRENT_ROLE
   | CURRENT_TIME
   | CURRENT_TIMESTAMP
   | CURRENT_USER
   | DEFAULT
   | DEFERRABLE
   | DESC
   | DISTINCT
   | DO
   | ELSE
   | END
   | EXCEPT
   | FALSE
   | FETCH
   | FOR
   | FOREIGN
   | FROM
   | GRANT
   | GROUP
   | HAVING
   | IN
   | INITIALLY
   | INTERSECT
   | INTO
   | LATERAL
   | LEADING
   | LIMIT
   | LOCALTIME
   | LOCALTIMESTAMP
   | NOT
   | NULL
   | OFFSET
   | ON
   | ONLY
   | OR
   | ORDER
   | PLACING
   | PRIMARY
   | REFERENCES
   | RETURNING
   | SELECT
   | SESSION_USER
   | SOME
   | SYMMETRIC
   | TABLE
   | THEN
   | TO
   | TRAILING
   | TRUE
   | UNION
   | UNIQUE
   | USER
   | USING
   | VARIADIC
   | WHEN
   | WHERE
   | WINDOW
   | WITH
;

