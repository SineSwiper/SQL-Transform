***************
*** 3083,3090 ****
--- 3144,3161 ----
  					AlterSeqStmt *n = makeNode(AlterSeqStmt);
  					n->sequence = $3;
  					n->options = $4;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER SEQUENCE IF_P EXISTS qualified_name SeqOptList
+ 				{
+ 					AlterSeqStmt *n = makeNode(AlterSeqStmt);
+ 					n->sequence = $5;
+ 					n->options = $6;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
+ 
  		;
  
  OptSeqOptList: SeqOptList							{ $$ = $1; }
***************
*** 3487,3492 ****
--- 3563,3577 ----
  					n->objname = list_make1(makeString($6));
  					$$ = (Node *)n;
  				}
+ 			| ALTER EXTENSION name add_drop EVENT TRIGGER name
+ 				{
+ 					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
+ 					n->extname = $3;
+ 					n->action = $4;
+ 					n->objtype = OBJECT_EVENT_TRIGGER;
+ 					n->objname = list_make1(makeString($7));
+ 					$$ = (Node *)n;
+ 				}
  			| ALTER EXTENSION name add_drop TABLE any_name
  				{
  					AlterExtensionContentsStmt *n = makeNode(AlterExtensionContentsStmt);
***************
*** 3910,3915 ****
--- 4007,4022 ----
  					n->relation = $4;
  					n->cmds = $5;
  					n->relkind = OBJECT_FOREIGN_TABLE;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr alter_table_cmds
+ 				{
+ 					AlterTableStmt *n = makeNode(AlterTableStmt);
+ 					n->relation = $6;
+ 					n->cmds = $7;
+ 					n->relkind = OBJECT_FOREIGN_TABLE;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  		;
***************
*** 4027,4033 ****
  					n->isconstraint  = TRUE;
  					processCASbits($10, @10, "TRIGGER",
  								   &n->deferrable, &n->initdeferred, NULL,
! 								   yyscanner);
  					n->constrrel = $9;
  					$$ = (Node *)n;
  				}
--- 4134,4140 ----
  					n->isconstraint  = TRUE;
  					processCASbits($10, @10, "TRIGGER",
  								   &n->deferrable, &n->initdeferred, NULL,
! 								   NULL, yyscanner);
  					n->constrrel = $9;
  					$$ = (Node *)n;
  				}
***************
*** 4164,4195 ****
--- 4271,4374 ----
  DropTrigStmt:
! 			DROP TRIGGER name ON any_name opt_drop_behavior
  				{
! 					DropStmt *n = makeNode(DropStmt);
  					n->removeType = OBJECT_TRIGGER;
+ 					n->objects = list_make1(lappend($5, makeString($3)));
+ 					n->arguments = NIL;
+ 					n->behavior = $6;
  					n->missing_ok = false;
+ 					n->concurrent = false;
  					$$ = (Node *) n;
  				}
! 			| DROP TRIGGER IF_P EXISTS name ON any_name opt_drop_behavior
  				{
! 					DropStmt *n = makeNode(DropStmt);
  					n->removeType = OBJECT_TRIGGER;
+ 					n->objects = list_make1(lappend($7, makeString($5)));
+ 					n->arguments = NIL;
+ 					n->behavior = $8;
  					n->missing_ok = true;
+ 					n->concurrent = false;
+ 					$$ = (Node *) n;
+ 				}
+ 		;
+ 
+ 
+ /*****************************************************************************
+  *
+  *		QUERIES :
+  *				CREATE EVENT TRIGGER ...
+  *				DROP EVENT TRIGGER ...
+  *				ALTER EVENT TRIGGER ...
+  *
+  *****************************************************************************/
+ 
+ CreateEventTrigStmt:
+ 			CREATE EVENT TRIGGER name ON ColLabel
+ 			EXECUTE PROCEDURE func_name '(' ')'
+ 				{
+ 					CreateEventTrigStmt *n = makeNode(CreateEventTrigStmt);
+ 					n->trigname = $4;
+ 					n->eventname = $6;
+ 					n->whenclause = NULL;
+ 					n->funcname = $9;
+ 					$$ = (Node *)n;
+ 				}
+ 		  | CREATE EVENT TRIGGER name ON ColLabel
+ 			WHEN event_trigger_when_list
+ 			EXECUTE PROCEDURE func_name '(' ')'
+ 				{
+ 					CreateEventTrigStmt *n = makeNode(CreateEventTrigStmt);
+ 					n->trigname = $4;
+ 					n->eventname = $6;
+ 					n->whenclause = $8;
+ 					n->funcname = $11;
+ 					$$ = (Node *)n;
+ 				}
+ 		;
+ 
+ event_trigger_when_list:
+ 		  event_trigger_when_item
+ 			{ $$ = list_make1($1); }
+ 		| event_trigger_when_list AND event_trigger_when_item
+ 			{ $$ = lappend($1, $3); }
+ 		;
+ 
+ event_trigger_when_item:
+ 		ColId IN_P '(' event_trigger_value_list ')'
+ 			{ $$ = makeDefElem($1, (Node *) $4); }
+ 		;
+ 
+ event_trigger_value_list:
+ 		  SCONST
+ 			{ $$ = list_make1(makeString($1)); }
+ 		| event_trigger_value_list ',' SCONST
+ 			{ $$ = lappend($1, makeString($3)); }
+ 		;
+ 
+ AlterEventTrigStmt:
+ 			ALTER EVENT TRIGGER name enable_trigger
+ 				{
+ 					AlterEventTrigStmt *n = makeNode(AlterEventTrigStmt);
+ 					n->trigname = $4;
+ 					n->tgenabled = $5;
  					$$ = (Node *) n;
  				}
  		;
  
+ enable_trigger:
+ 			ENABLE_P					{ $$ = TRIGGER_FIRES_ON_ORIGIN; }
+ 			| ENABLE_P REPLICA			{ $$ = TRIGGER_FIRES_ON_REPLICA; }
+ 			| ENABLE_P ALWAYS			{ $$ = TRIGGER_FIRES_ALWAYS; }
+ 			| DISABLE_P					{ $$ = TRIGGER_DISABLED; }
+ 		;
  
  /*****************************************************************************
   *
***************
*** 4311,4316 ****
--- 4490,4502 ----
  					n->vals = $7;
  					$$ = (Node *)n;
  				}
+ 			| CREATE TYPE_P any_name AS RANGE definition
+ 				{
+ 					CreateRangeStmt *n = makeNode(CreateRangeStmt);
+ 					n->typeName = $3;
+ 					n->params	= $6;
+ 					$$ = (Node *)n;
+ 				}
  			| CREATE TEXT_P SEARCH PARSER any_name definition
  				{
  					DefineStmt *n = makeNode(DefineStmt);
***************
*** 5414,5419 ****
--- 5640,5653 ----
  					n->objs = $2;
  					$$ = n;
  				}
+ 			| DOMAIN_P any_name_list
+ 				{
+ 					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
+ 					n->targtype = ACL_TARGET_OBJECT;
+ 					n->objtype = ACL_OBJECT_DOMAIN;
+ 					n->objs = $2;
+ 					$$ = n;
+ 				}
  			| LANGUAGE name_list
  				{
  					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
***************
*** 5446,5451 ****
--- 5680,5693 ----
  					n->objs = $2;
  					$$ = n;
  				}
+ 			| TYPE_P any_name_list
+ 				{
+ 					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
+ 					n->targtype = ACL_TARGET_OBJECT;
+ 					n->objtype = ACL_OBJECT_TYPE;
+ 					n->objs = $2;
+ 					$$ = n;
+ 				}
  			| ALL TABLES IN_P SCHEMA name_list
  				{
  					PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
***************
*** 6026,6031 ****
--- 6276,6289 ----
  				{
  					$$ = makeDefElem("security", (Node *)makeInteger(FALSE));
  				}
+ 			| LEAKPROOF
+ 				{
+ 					$$ = makeDefElem("leakproof", (Node *)makeInteger(TRUE));
+ 				}
+ 			| NOT LEAKPROOF
+ 				{
+ 					$$ = makeDefElem("leakproof", (Node *)makeInteger(FALSE));
+ 				}
  			| COST NumericOnly
  				{
  					$$ = makeDefElem("cost", (Node *)$2);
***************
*** 6411,6416 ****
--- 6680,6714 ----
  					n->renameType = OBJECT_DATABASE;
  					n->subname = $3;
  					n->newname = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER DOMAIN_P any_name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_DOMAIN;
+ 					n->object = $3;
+ 					n->newname = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER DOMAIN_P any_name RENAME CONSTRAINT name TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_CONSTRAINT;
+ 					n->relationType = OBJECT_DOMAIN;
+ 					n->object = $3;
+ 					n->subname = $6;
+ 					n->newname = $8;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER FOREIGN DATA_P WRAPPER name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_FDW;
+ 					n->subname = $5;
+ 					n->newname = $8;
+ 					n->missing_ok = false;
  					$$ = (Node *)n;
  				}
  			| ALTER FUNCTION function_with_argtypes RENAME TO name
***************
*** 6462,6467 ****
--- 6765,6780 ----
  					n->renameType = OBJECT_SCHEMA;
  					n->subname = $3;
  					n->newname = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER SERVER name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_FOREIGN_SERVER;
+ 					n->subname = $3;
+ 					n->newname = $6;
+ 					n->missing_ok = false;
  					$$ = (Node *)n;
  				}
  			| ALTER TABLE relation_expr RENAME TO name
***************
*** 6471,6485 ****
  					n->relation = $3;
  					n->subname = NULL;
  					n->newname = $6;
  					$$ = (Node *)n;
  				}
! 			| ALTER SEQUENCE qualified_name RENAME TO name
  				{
  					RenameStmt *n = makeNode(RenameStmt);
  					n->renameType = OBJECT_SEQUENCE;
! 					n->relation = $3;
  					n->subname = NULL;
! 					n->newname = $6;
  					$$ = (Node *)n;
  				}
  			| ALTER VIEW qualified_name RENAME TO name
--- 6784,6820 ----
  					n->relation = $3;
  					n->subname = NULL;
  					n->newname = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER TABLE IF_P EXISTS relation_expr RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_TABLE;
+ 					n->relation = $5;
+ 					n->subname = NULL;
+ 					n->newname = $8;
+ 					n->missing_ok = true;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER SEQUENCE qualified_name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_SEQUENCE;
+ 					n->relation = $3;
+ 					n->subname = NULL;
+ 					n->newname = $6;
+ 					n->missing_ok = false;
  					$$ = (Node *)n;
  				}
! 			| ALTER SEQUENCE IF_P EXISTS qualified_name RENAME TO name
  				{
  					RenameStmt *n = makeNode(RenameStmt);
  					n->renameType = OBJECT_SEQUENCE;
! 					n->relation = $5;
  					n->subname = NULL;
! 					n->newname = $8;
! 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER VIEW qualified_name RENAME TO name
***************
*** 6489,6494 ****
--- 6824,6840 ----
  					n->relation = $3;
  					n->subname = NULL;
  					n->newname = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER VIEW IF_P EXISTS qualified_name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_VIEW;
+ 					n->relation = $5;
+ 					n->subname = NULL;
+ 					n->newname = $8;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER INDEX qualified_name RENAME TO name
***************
*** 6498,6503 ****
--- 6844,6860 ----
  					n->relation = $3;
  					n->subname = NULL;
  					n->newname = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER INDEX IF_P EXISTS qualified_name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_INDEX;
+ 					n->relation = $5;
+ 					n->subname = NULL;
+ 					n->newname = $8;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER FOREIGN TABLE relation_expr RENAME TO name
***************
*** 6507,6512 ****
--- 6864,6880 ----
  					n->relation = $4;
  					n->subname = NULL;
  					n->newname = $7;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_FOREIGN_TABLE;
+ 					n->relation = $6;
+ 					n->subname = NULL;
+ 					n->newname = $9;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER TABLE relation_expr RENAME opt_column name TO name
***************
*** 6517,6522 ****
--- 6885,6912 ----
  					n->relation = $3;
  					n->subname = $6;
  					n->newname = $8;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER TABLE IF_P EXISTS relation_expr RENAME opt_column name TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_COLUMN;
+ 					n->relationType = OBJECT_TABLE;
+ 					n->relation = $5;
+ 					n->subname = $8;
+ 					n->newname = $10;
+ 					n->missing_ok = true;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER TABLE relation_expr RENAME CONSTRAINT name TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_CONSTRAINT;
+ 					n->relationType = OBJECT_TABLE;
+ 					n->relation = $3;
+ 					n->subname = $6;
+ 					n->newname = $8;
  					$$ = (Node *)n;
  				}
  			| ALTER FOREIGN TABLE relation_expr RENAME opt_column name TO name
***************
*** 6527,6532 ****
--- 6917,6934 ----
  					n->relation = $4;
  					n->subname = $7;
  					n->newname = $9;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr RENAME opt_column name TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_COLUMN;
+ 					n->relationType = OBJECT_FOREIGN_TABLE;
+ 					n->relation = $6;
+ 					n->subname = $9;
+ 					n->newname = $11;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER TRIGGER name ON qualified_name RENAME TO name
***************
*** 6536,6541 ****
--- 6938,6952 ----
  					n->relation = $5;
  					n->subname = $3;
  					n->newname = $8;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER EVENT TRIGGER name RENAME TO name
+ 				{
+ 					RenameStmt *n = makeNode(RenameStmt);
+ 					n->renameType = OBJECT_EVENT_TRIGGER;
+ 					n->subname = $4;
+ 					n->newname = $7;
  					$$ = (Node *)n;
  				}
  			| ALTER ROLE RoleId RENAME TO RoleId
***************
*** 6731,6736 ****
--- 7160,7175 ----
  					n->objectType = OBJECT_TABLE;
  					n->relation = $3;
  					n->newschema = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER TABLE IF_P EXISTS relation_expr SET SCHEMA name
+ 				{
+ 					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
+ 					n->objectType = OBJECT_TABLE;
+ 					n->relation = $5;
+ 					n->newschema = $8;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER TEXT_P SEARCH PARSER any_name SET SCHEMA name
***************
*** 6771,6776 ****
--- 7214,7229 ----
  					n->objectType = OBJECT_SEQUENCE;
  					n->relation = $3;
  					n->newschema = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER SEQUENCE IF_P EXISTS qualified_name SET SCHEMA name
+ 				{
+ 					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
+ 					n->objectType = OBJECT_SEQUENCE;
+ 					n->relation = $5;
+ 					n->newschema = $8;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER VIEW qualified_name SET SCHEMA name
***************
*** 6779,6784 ****
--- 7232,7247 ----
  					n->objectType = OBJECT_VIEW;
  					n->relation = $3;
  					n->newschema = $6;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER VIEW IF_P EXISTS qualified_name SET SCHEMA name
+ 				{
+ 					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
+ 					n->objectType = OBJECT_VIEW;
+ 					n->relation = $5;
+ 					n->newschema = $8;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER FOREIGN TABLE relation_expr SET SCHEMA name
***************
*** 6787,6792 ****
--- 7250,7265 ----
  					n->objectType = OBJECT_FOREIGN_TABLE;
  					n->relation = $4;
  					n->newschema = $7;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			| ALTER FOREIGN TABLE IF_P EXISTS relation_expr SET SCHEMA name
+ 				{
+ 					AlterObjectSchemaStmt *n = makeNode(AlterObjectSchemaStmt);
+ 					n->objectType = OBJECT_FOREIGN_TABLE;
+ 					n->relation = $6;
+ 					n->newschema = $9;
+ 					n->missing_ok = true;
  					$$ = (Node *)n;
  				}
  			| ALTER TYPE_P any_name SET SCHEMA name
***************
*** 6954,6959 ****
--- 7428,7441 ----
  					n->newowner = $6;
  					$$ = (Node *)n;
  				}
+ 			| ALTER EVENT TRIGGER name OWNER TO RoleId
+ 				{
+ 					AlterOwnerStmt *n = makeNode(AlterOwnerStmt);
+ 					n->objectType = OBJECT_EVENT_TRIGGER;
+ 					n->object = list_make1(makeString($4));
+ 					n->newowner = $7;
+ 					$$ = (Node *)n;
+ 				}
  		;
  
  
***************
*** 7260,7285 ****
   *
   *****************************************************************************/
  
! ViewStmt: CREATE OptTemp VIEW qualified_name opt_column_list
  				AS SelectStmt opt_check_option
  				{
  					ViewStmt *n = makeNode(ViewStmt);
  					n->view = $4;
  					n->view->relpersistence = $2;
  					n->aliases = $5;
! 					n->query = $7;
  					n->replace = false;
  					$$ = (Node *) n;
  				}
! 		| CREATE OR REPLACE OptTemp VIEW qualified_name opt_column_list
  				AS SelectStmt opt_check_option
  				{
  					ViewStmt *n = makeNode(ViewStmt);
  					n->view = $6;
  					n->view->relpersistence = $4;
  					n->aliases = $7;
! 					n->query = $9;
  					n->replace = true;
  					$$ = (Node *) n;
  				}
  		;
--- 7744,7771 ----
   *
   *****************************************************************************/
  
! ViewStmt: CREATE OptTemp VIEW qualified_name opt_column_list opt_reloptions
  				AS SelectStmt opt_check_option
  				{
  					ViewStmt *n = makeNode(ViewStmt);
  					n->view = $4;
  					n->view->relpersistence = $2;
  					n->aliases = $5;
! 					n->query = $8;
  					n->replace = false;
+ 					n->options = $6;
  					$$ = (Node *) n;
  				}
! 		| CREATE OR REPLACE OptTemp VIEW qualified_name opt_column_list opt_reloptions
  				AS SelectStmt opt_check_option
  				{
  					ViewStmt *n = makeNode(ViewStmt);
  					n->view = $6;
  					n->view->relpersistence = $4;
  					n->aliases = $7;
! 					n->query = $10;
  					n->replace = true;
+ 					n->options = $8;
  					$$ = (Node *) n;
  				}
  		;
***************
*** 7552,7557 ****
--- 8038,8064 ----
  					n->typeName = $3;
  					n->name = $6;
  					n->behavior = $7;
+ 					n->missing_ok = false;
+ 					$$ = (Node *)n;
+ 				}
+ 			/* ALTER DOMAIN <domain> DROP CONSTRAINT IF EXISTS <name> [RESTRICT|CASCADE] */
+ 			| ALTER DOMAIN_P any_name DROP CONSTRAINT IF_P EXISTS name opt_drop_behavior
+ 				{
+ 					AlterDomainStmt *n = makeNode(AlterDomainStmt);
+ 					n->subtype = 'X';
+ 					n->typeName = $3;
+ 					n->name = $8;
+ 					n->behavior = $9;
+ 					n->missing_ok = true;
+ 					$$ = (Node *)n;
+ 				}
+ 			/* ALTER DOMAIN <domain> VALIDATE CONSTRAINT <name> */
+ 			| ALTER DOMAIN_P any_name VALIDATE CONSTRAINT name
+ 				{
+ 					AlterDomainStmt *n = makeNode(AlterDomainStmt);
+ 					n->subtype = 'V';
+ 					n->typeName = $3;
+ 					n->name = $6;
  					$$ = (Node *)n;
  				}
  			;
***************
*** 8553,8563 ****
--- 9060,9076 ----
  				}
  			| GLOBAL TEMPORARY opt_table qualified_name
  				{
+ 					ereport(WARNING,
+ 							(errmsg("GLOBAL is deprecated in temporary table creation"),
+ 							 parser_errposition(@1)));
  					$$ = $4;
  					$$->relpersistence = RELPERSISTENCE_TEMP;
  				}
  			| GLOBAL TEMP opt_table qualified_name
  				{
+ 					ereport(WARNING,
+ 							(errmsg("GLOBAL is deprecated in temporary table creation"),
+ 							 parser_errposition(@1)));
  					$$ = $4;
  					$$->relpersistence = RELPERSISTENCE_TEMP;
  				}
***************
*** 8797,8861 ****
  		;
  
  /*
!  * table_ref is where an alias clause can be attached.	Note we cannot make
!  * alias_clause have an empty production because that causes parse conflicts
!  * between table_ref := '(' joined_table ')' alias_clause
!  * and joined_table := '(' joined_table ')'.  So, we must have the
!  * redundant-looking productions here instead.
   */
! table_ref:	relation_expr
! 				{
! 					$$ = (Node *) $1;
! 				}
! 			| relation_expr alias_clause
  				{
  					$1->alias = $2;
  					$$ = (Node *) $1;
  				}
! 			| func_table
! 				{
! 					RangeFunction *n = makeNode(RangeFunction);
! 					n->funccallnode = $1;
! 					n->coldeflist = NIL;
! 					$$ = (Node *) n;
! 				}
! 			| func_table alias_clause
! 				{
! 					RangeFunction *n = makeNode(RangeFunction);
! 					n->funccallnode = $1;
! 					n->alias = $2;
! 					n->coldeflist = NIL;
! 					$$ = (Node *) n;
! 				}
! 			| func_table AS '(' TableFuncElementList ')'
! 				{
! 					RangeFunction *n = makeNode(RangeFunction);
! 					n->funccallnode = $1;
! 					n->coldeflist = $4;
! 					$$ = (Node *) n;
! 				}
! 			| func_table AS ColId '(' TableFuncElementList ')'
  				{
  					RangeFunction *n = makeNode(RangeFunction);
! 					Alias *a = makeNode(Alias);
  					n->funccallnode = $1;
! 					a->aliasname = $3;
! 					n->alias = a;
! 					n->coldeflist = $5;
  					$$ = (Node *) n;
  				}
! 			| func_table ColId '(' TableFuncElementList ')'
  				{
  					RangeFunction *n = makeNode(RangeFunction);
! 					Alias *a = makeNode(Alias);
! 					n->funccallnode = $1;
! 					a->aliasname = $2;
! 					n->alias = a;
! 					n->coldeflist = $4;
  					$$ = (Node *) n;
  				}
! 			| select_with_parens
  				{
  					/*
  					 * The SQL spec does not permit a subselect
  					 * (<derived_table>) without an alias clause,
--- 9310,9346 ----
  		;
  
  /*
!  * table_ref is where an alias clause can be attached.
   */
! table_ref:	relation_expr opt_alias_clause
  				{
  					$1->alias = $2;
  					$$ = (Node *) $1;
  				}
! 			| func_table func_alias_clause
  				{
  					RangeFunction *n = makeNode(RangeFunction);
! 					n->lateral = false;
  					n->funccallnode = $1;
! 					n->alias = linitial($2);
! 					n->coldeflist = lsecond($2);
  					$$ = (Node *) n;
  				}
! 			| LATERAL_P func_table func_alias_clause
  				{
  					RangeFunction *n = makeNode(RangeFunction);
! 					n->lateral = true;
! 					n->funccallnode = $2;
! 					n->alias = linitial($3);
! 					n->coldeflist = lsecond($3);
  					$$ = (Node *) n;
  				}
! 			| select_with_parens opt_alias_clause
  				{
+ 					RangeSubselect *n = makeNode(RangeSubselect);
+ 					n->lateral = false;
+ 					n->subquery = $1;
+ 					n->alias = $2;
  					/*
  					 * The SQL spec does not permit a subselect
  					 * (<derived_table>) without an alias clause,
***************
*** 8867,8872 ****
--- 9352,9359 ----
  					 * However, it does seem like a good idea to emit
  					 * an error message that's better than "syntax error".
  					 */
+ 					if ($2 == NULL)
+ 					{
  						if (IsA($1, SelectStmt) &&
  							((SelectStmt *) $1)->valuesLists)
  							ereport(ERROR,
***************
*** 8880,8892 ****
  								 errmsg("subquery in FROM must have an alias"),
  								 errhint("For example, FROM (SELECT ...) [AS] foo."),
  								 parser_errposition(@1)));
- 					$$ = NULL;
  				}
! 			| select_with_parens alias_clause
  				{
  					RangeSubselect *n = makeNode(RangeSubselect);
! 					n->subquery = $1;
! 					n->alias = $2;
  					$$ = (Node *) n;
  				}
  			| joined_table
--- 9367,9398 ----
  									 errmsg("subquery in FROM must have an alias"),
  									 errhint("For example, FROM (SELECT ...) [AS] foo."),
  									 parser_errposition(@1)));
  					}
! 					$$ = (Node *) n;
! 				}
! 			| LATERAL_P select_with_parens opt_alias_clause
  				{
  					RangeSubselect *n = makeNode(RangeSubselect);
! 					n->lateral = true;
! 					n->subquery = $2;
! 					n->alias = $3;
! 					/* same coment as above */
! 					if ($3 == NULL)
! 					{
! 						if (IsA($2, SelectStmt) &&
! 							((SelectStmt *) $2)->valuesLists)
! 							ereport(ERROR,
! 									(errcode(ERRCODE_SYNTAX_ERROR),
! 									 errmsg("VALUES in FROM must have an alias"),
! 									 errhint("For example, FROM (VALUES ...) [AS] foo."),
! 									 parser_errposition(@2)));
! 						else
! 							ereport(ERROR,
! 									(errcode(ERRCODE_SYNTAX_ERROR),
! 									 errmsg("subquery in FROM must have an alias"),
! 									 errhint("For example, FROM (SELECT ...) [AS] foo."),
! 									 parser_errposition(@2)));
! 					}
  					$$ = (Node *) n;
  				}
  			| joined_table
***************
*** 9012,9017 ****
--- 9518,9558 ----
  				}
  		;
  
+ opt_alias_clause: alias_clause						{ $$ = $1; }
+ 			| /*EMPTY*/								{ $$ = NULL; }
+ 		;
+ 
+ /*
+  * func_alias_clause can include both an Alias and a coldeflist, so we make it
+  * return a 2-element list that gets disassembled by calling production.
+  */
+ func_alias_clause:
+ 			alias_clause
+ 				{
+ 					$$ = list_make2($1, NIL);
+ 				}
+ 			| AS '(' TableFuncElementList ')'
+ 				{
+ 					$$ = list_make2(NULL, $3);
+ 				}
+ 			| AS ColId '(' TableFuncElementList ')'
+ 				{
+ 					Alias *a = makeNode(Alias);
+ 					a->aliasname = $2;
+ 					$$ = list_make2(a, $4);
+ 				}
+ 			| ColId '(' TableFuncElementList ')'
+ 				{
+ 					Alias *a = makeNode(Alias);
+ 					a->aliasname = $1;
+ 					$$ = list_make2(a, $3);
+ 				}
+ 			| /*EMPTY*/
+ 				{
+ 					$$ = list_make2(NULL, NIL);
+ 				}
+ 		;
+ 
  join_type:	FULL join_outer							{ $$ = JOIN_FULL; }
  			| LEFT join_outer						{ $$ = JOIN_LEFT; }
  			| RIGHT join_outer						{ $$ = JOIN_RIGHT; }
***************
*** 10260,10265 ****
--- 10801,10807 ----
  					RowExpr *r = makeNode(RowExpr);
  					r->args = $1;
  					r->row_typeid = InvalidOid;	/* not analyzed yet */
+ 					r->colnames = NIL;	/* to be filled in during analysis */
  					r->location = @1;
  					$$ = (Node *)r;
  				}
***************
*** 10391,10396 ****
--- 10933,10951 ----
  					n->location = @1;
  					$$ = (Node *)n;
  				}
+ 			| COLLATION FOR '(' a_expr ')'
+ 				{
+ 					FuncCall *n = makeNode(FuncCall);
+ 					n->funcname = SystemFuncName("pg_collation_for");
+ 					n->args = list_make1($4);
+ 					n->agg_order = NIL;
+ 					n->agg_star = FALSE;
+ 					n->agg_distinct = FALSE;
+ 					n->func_variadic = FALSE;
+ 					n->over = NULL;
+ 					n->location = @1;
+ 					$$ = (Node *)n;
+ 				}
  			| CURRENT_DATE
  				{
  					/*
