%expect 0
%prefix SQL::Parser::

/*
 * Non-keyword token types.  These are hard-wired into the "flex" lexer.
 * They must be listed first so that their numeric codes do not depend on
 * the set of keywords.  PL/pgsql depends on this so that it can share the
 * same lexer.  If you add/change tokens here, fix PL/pgsql to match!
 */
%token <str>   IDENT FCONST SCONST BCONST XCONST Op
%token <ival>   ICONST PARAM
%token         TYPECAST COLON_EQUALS

/*
 * If you want to make any keyword changes, update the keyword table in
 * src/include/parser/kwlist.h and add new keywords to the appropriate one
 * of the reserved-or-not-so-reserved keyword lists, below; search
 * this file for "Keyword category lists".
 */

/* ordinary key words in alphabetical order */
/**** XXX: This is ugly, but eyapp doesn't seem to support multi-line %tokens ****/
%token <keyword> ABORT ABSOLUTE ACCESS ACTION ADD ADMIN AFTER AGGREGATE ALL ALSO ALTER ALWAYS ANALYSE ANALYZE AND ANY ARRAY AS ASC ASSERTION ASSIGNMENT ASYMMETRIC AT ATTRIBUTE AUTHORIZATION BACKWARD BEFORE BEGIN BETWEEN BIGINT BINARY BIT BOOLEAN BOTH BY CACHE CALLED CASCADE CASCADED CASE CAST CATALOG CHAIN CHAR CHARACTER CHARACTERISTICS CHECK CHECKPOINT CLASS CLOSE CLUSTER COALESCE COLLATE COLLATION COLUMN COMMENT COMMENTS COMMIT COMMITTED CONCURRENTLY CONFIGURATION CONNECTION CONSTRAINT CONSTRAINTS CONTENT CONTINUE CONVERSION COPY COST CREATE CROSS CSV CURRENT CURRENT_CATALOG CURRENT_DATE CURRENT_ROLE CURRENT_SCHEMA CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR CYCLE DATA DATABASE DAY DEALLOCATE DEC DECIMAL DECLARE DEFAULT DEFAULTS DEFERRABLE DEFERRED DEFINER DELETE DELIMITER DELIMITERS DESC DICTIONARY DISABLE DISCARD DISTINCT DO DOCUMENT DOMAIN DOUBLE DROP EACH ELSE ENABLE ENCODING ENCRYPTED END ENUM ESCAPE EXCEPT EXCLUDE EXCLUDING EXCLUSIVE EXECUTE EXISTS EXPLAIN EXTENSION EXTERNAL EXTRACT FALSE FAMILY FETCH FIRST FLOAT FOLLOWING FOR FORCE FOREIGN FORWARD FREEZE FROM FULL FUNCTION FUNCTIONS GLOBAL GRANT GRANTED GREATEST GROUP HANDLER HAVING HEADER HOLD HOUR IDENTITY IF ILIKE IMMEDIATE IMMUTABLE IMPLICIT IN INCLUDING INCREMENT INDEX INDEXES INHERIT INHERITS INITIALLY INLINE INNER INOUT INPUT INSENSITIVE INSERT INSTEAD INT INTEGER INTERSECT INTERVAL INTO INVOKER IS ISNULL ISOLATION JOIN KEY LABEL LANGUAGE LARGE LAST LC_COLLATE LC_CTYPE LEADING LEAST LEFT LEVEL LIKE LIMIT LISTEN LOAD LOCAL LOCALTIME LOCALTIMESTAMP LOCATION LOCK MAPPING MATCH MAXVALUE MINUTE MINVALUE MODE MONTH MOVE NAME NAMES NATIONAL NATURAL NCHAR NEXT NO NONE NOT NOTHING NOTIFY NOTNULL NOWAIT NULL NULLIF NULLS NUMERIC OBJECT OF OFF OFFSET OIDS ON ONLY OPERATOR OPTION OPTIONS OR ORDER OUT OUTER OVER OVERLAPS OVERLAY OWNED OWNER PARSER PARTIAL PARTITION PASSING PASSWORD PLACING PLANS POSITION PRECEDING PRECISION PRESERVE PREPARE PREPARED PRIMARY PRIOR PRIVILEGES PROCEDURAL PROCEDURE QUOTE RANGE READ REAL REASSIGN RECHECK RECURSIVE REF REFERENCES REINDEX RELATIVE RELEASE RENAME REPEATABLE REPLACE REPLICA RESET RESTART RESTRICT RETURNING RETURNS REVOKE RIGHT ROLE ROLLBACK ROW ROWS RULE SAVEPOINT SCHEMA SCROLL SEARCH SECOND SECURITY SELECT SEQUENCE SEQUENCES SERIALIZABLE SERVER SESSION SESSION_USER SET SETOF SHARE SHOW SIMILAR SIMPLE SMALLINT SOME STABLE STANDALONE START STATEMENT STATISTICS STDIN STDOUT STORAGE STRICT STRIP SUBSTRING SYMMETRIC SYSID SYSTEM TABLE TABLES TABLESPACE TEMP TEMPLATE TEMPORARY TEXT THEN TIME TIMESTAMP TO TRAILING TRANSACTION TREAT TRIGGER TRIM TRUE TRUNCATE TRUSTED TYPE UNBOUNDED UNCOMMITTED UNENCRYPTED UNION UNIQUE UNKNOWN UNLISTEN UNLOGGED UNTIL UPDATE USER USING VACUUM VALID VALIDATE VALIDATOR VALUE VALUES VARCHAR VARIADIC VARYING VERBOSE VERSION VIEW VOLATILE WHEN WHERE WHITESPACE WINDOW WITH WITHOUT WORK WRAPPER WRITE YEAR YES ZONE

/*
 * The grammar thinks these are keywords, but they are not in the kwlist.h
 * list and so can never be entered directly.  The filter in parser.c
 * creates these tokens when required.
 */
%token         NULLS_FIRST NULLS_LAST WITH_TIME

/* Precedence: lowest to highest */
%nonassoc   SET            /* see relation_expr_opt_alias */
%left      UNION EXCEPT
%left      INTERSECT
%left      OR
%left      AND
%right      NOT
%right      '='
%nonassoc   '<' '>'
%nonassoc   LIKE ILIKE SIMILAR
%nonassoc   ESCAPE
%nonassoc   OVERLAPS
%nonassoc   BETWEEN
%nonassoc   IN
%left      POSTFIXOP      /* dummy for postfix Op rules */
/*
 * To support target_el without AS, we must give IDENT an explicit priority
 * between POSTFIXOP and Op.  We can safely assign the same priority to
 * various unreserved keywords as needed to resolve ambiguities (this can't
 * have any bad effects since obviously the keywords will still behave the
 * same as if they weren't keywords).  We need to do this for PARTITION,
 * RANGE, ROWS to support opt_existing_window_name; and for RANGE, ROWS
 * so that they can follow a_expr without creating postfix-operator problems;
 * and for NULL so that it can follow b_expr in ColQualList without creating
 * postfix-operator problems.
 *
 * The frame_bound productions UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING
 * are even messier: since UNBOUNDED is an unreserved keyword (per spec!),
 * there is no principled way to distinguish these from the productions
 * a_expr PRECEDING/FOLLOWING.  We hack this up by giving UNBOUNDED slightly
 * lower precedence than PRECEDING and FOLLOWING.  At present this doesn't
 * appear to cause UNBOUNDED to be treated differently from other unreserved
 * keywords anywhere else in the grammar, but it's definitely risky.  We can
 * blame any funny behavior of UNBOUNDED on the SQL standard, though.
 */
%nonassoc   UNBOUNDED      /* ideally should have same precedence as IDENT */
%nonassoc   IDENT NULL PARTITION RANGE ROWS PRECEDING FOLLOWING
%left      Op OPERATOR      /* multi-character ops and user-defined operators */
%nonassoc   NOTNULL
%nonassoc   ISNULL
%nonassoc   IS            /* sets precedence for IS NULL, etc */
%left      '+' '-'
%left      '*' '/' '%'
%left      '^'
/* Unary Operators */
%left      AT            /* sets precedence for AT TIME ZONE */
%left      COLLATE
%right      UMINUS
%left      '[' ']'
%left      '(' ')'
%left      TYPECAST
%left      '.'
/*
 * These might seem to be low-precedence, but actually they are not part
 * of the arithmetic hierarchy at all in their use as JOIN operators.
 * We make them high-precedence to support their use as function names.
 * They wouldn't be given a precedence at all, were it not that we need
 * left-associativity among the JOIN rules themselves.
 */
%left      JOIN CROSS LEFT FULL RIGHT INNER NATURAL
/* kluge to keep xml_whitespace_option from causing shift/reduce conflicts */
%right      PRESERVE STRIP

%%

/*
 *   The target production for the whole parse.
 */
stmtblock:   stmtmulti
         {
            $_[0]->{parsetree} = $_[1];
         }
      ;

/* the thrashing around here is to discard "empty" statements... */
stmtmulti:   stmtmulti ';' stmt
            { defined $_[3] ? lappend($_[1], $_[3]) : $_[1] }
         | stmt
            { defined $_[1] ? lappend($_[1]) : undef }
      ;

stmt:
         AlterDatabaseStmt
         | AlterDatabaseSetStmt
         | AlterDefaultPrivilegesStmt
         | AlterDomainStmt
         | AlterEnumStmt
         | AlterExtensionStmt
         | AlterExtensionContentsStmt
         | AlterFdwStmt
         | AlterForeignServerStmt
         | AlterForeignTableStmt
         | AlterFunctionStmt
         | AlterGroupStmt
         | AlterObjectSchemaStmt
         | AlterOwnerStmt
         | AlterSeqStmt
         | AlterTableStmt
         | AlterCompositeTypeStmt
         | AlterRoleSetStmt
         | AlterRoleStmt
         | AlterTSConfigurationStmt
         | AlterTSDictionaryStmt
         | AlterUserMappingStmt
         | AlterUserSetStmt
         | AlterUserStmt
         | AnalyzeStmt
         | CheckPointStmt
         | ClosePortalStmt
         | ClusterStmt
         | CommentStmt
         | ConstraintsSetStmt
         | CopyStmt
         | CreateAsStmt
         | CreateAssertStmt
         | CreateCastStmt
         | CreateConversionStmt
         | CreateDomainStmt
         | CreateExtensionStmt
         | CreateFdwStmt
         | CreateForeignServerStmt
         | CreateForeignTableStmt
         | CreateFunctionStmt
         | CreateGroupStmt
         | CreateOpClassStmt
         | CreateOpFamilyStmt
         | AlterOpFamilyStmt
         | CreatePLangStmt
         | CreateSchemaStmt
         | CreateSeqStmt
         | CreateStmt
         | CreateTableSpaceStmt
         | CreateTrigStmt
         | CreateRoleStmt
         | CreateUserStmt
         | CreateUserMappingStmt
         | CreatedbStmt
         | DeallocateStmt
         | DeclareCursorStmt
         | DefineStmt
         | DeleteStmt
         | DiscardStmt
         | DoStmt
         | DropAssertStmt
         | DropCastStmt
         | DropFdwStmt
         | DropForeignServerStmt
         | DropGroupStmt
         | DropOpClassStmt
         | DropOpFamilyStmt
         | DropOwnedStmt
         | DropPLangStmt
         | DropRuleStmt
         | DropStmt
         | DropTableSpaceStmt
         | DropTrigStmt
         | DropRoleStmt
         | DropUserStmt
         | DropUserMappingStmt
         | DropdbStmt
         | ExecuteStmt
         | ExplainStmt
         | FetchStmt
         | GrantStmt
         | GrantRoleStmt
         | IndexStmt
         | InsertStmt
         | ListenStmt
         | LoadStmt
         | LockStmt
         | NotifyStmt
         | PrepareStmt
         | ReassignOwnedStmt
         | ReindexStmt
         | RemoveAggrStmt
         | RemoveFuncStmt
         | RemoveOperStmt
         | RenameStmt
         | RevokeStmt
         | RevokeRoleStmt
         | RuleStmt
         | SecLabelStmt
         | SelectStmt
         | TransactionStmt
         | TruncateStmt
         | UnlistenStmt
         | UpdateStmt
         | VacuumStmt
         | VariableResetStmt
         | VariableSetStmt
         | VariableShowStmt
         | ViewStmt
         | /*EMPTY*/
            { NULL }
      ;

/*****************************************************************************
 *
 * Create a new Postgres DBMS role
 *
 *****************************************************************************/

CreateRoleStmt:
         CREATE ROLE RoleId opt_with OptRoleList
            {
               return SQL::Translator::Statement::CreateRole->new(
                  stmt_type => ROLESTMT_ROLE,
                  role      => $_[3],
                  options   => $_[5],
               );
            }
      ;


opt_with:   WITH                           {}
         | /*EMPTY*/                       {}
      ;

/*
 * Options for CREATE ROLE and ALTER ROLE (also used by CREATE/ALTER USER
 * for backwards compatibility).  Note: the only option required by SQL99
 * is "WITH ADMIN name".
 */
OptRoleList:
         OptRoleList CreateOptRoleElem     { lappend($_[1], $_[2]) }
         | /* EMPTY */                     { NIL }
      ;

AlterOptRoleList:
         AlterOptRoleList AlterOptRoleElem { lappend($_[1], $_[2]) }
         | /* EMPTY */                     { NIL }
      ;

AlterOptRoleElem:
         PASSWORD Sconst
            {
               return makeDefElem("password",
                            makeString($_[2]));
            }
         | PASSWORD NULL
            {
               return makeDefElem("password", NULL);
            }
         | ENCRYPTED PASSWORD Sconst
            {
               return makeDefElem("encryptedPassword",
                            makeString($_[3]));
            }
         | UNENCRYPTED PASSWORD Sconst
            {
               return makeDefElem("unencryptedPassword",
                            makeString($_[3]));
            }
         | INHERIT
            {
               return makeDefElem("inherit", makeInteger(TRUE));
            }
         | CONNECTION LIMIT SignedIconst
            {
               return makeDefElem("connectionlimit", makeInteger($_[3]));
            }
         | VALID UNTIL Sconst
            {
               return makeDefElem("validUntil", makeString($_[3]));
            }
      /*   Supported but not documented for roles, for use by ALTER GROUP. */
         | USER name_list
            {
               return makeDefElem("rolemembers", $_[2]);
            }
         | IDENT
               /*
                * We handle identifiers that aren't parser keywords with
                * the following special-case codes, to avoid bloating the
                * size of the main parser.
                */
            {
               for ($_[1]) {
                  when (/^(?:super|create)user$/)   { makeDefElem("superuser",     makeInteger(TRUE));  }     
                  when (/^no(?:super|create)user$/) { makeDefElem("superuser",     makeInteger(FALSE)); }
                  when ("createrole")               { makeDefElem("createrole",    makeInteger(TRUE));  }
                  when ("nocreaterole")             { makeDefElem("createrole",    makeInteger(FALSE)); }
                  when ("replication")              { makeDefElem("isreplication", makeInteger(TRUE));  }
                  when ("noreplication")            { makeDefElem("isreplication", makeInteger(FALSE)); }
                  when ("createdb")                 { makeDefElem("createdb",      makeInteger(TRUE));  }
                  when ("nocreatedb")               { makeDefElem("createdb",      makeInteger(FALSE)); }
                  when ("login")                    { makeDefElem("canlogin",      makeInteger(TRUE));  }
                  when ("nologin")                  { makeDefElem("canlogin",      makeInteger(FALSE)); }
                  #* Note that INHERIT is a keyword, so it's handled by main parser, but
                  #* NOINHERIT is handled here.
                  when ("noinherit")                { makeDefElem("inherit",       makeInteger(FALSE)); }
                  default {
                     $_[0]->ereport(ERROR,
                           ERRCODE_SYNTAX_ERROR,
                            sprintf("unrecognized role option \"%s\"", $_[1]),
                               $_[0]->YYLLoc($_[1], 1));
                  }
               }
            }
      ;

CreateOptRoleElem:
         AlterOptRoleElem         { $_[1] }
         /* The following are not supported by ALTER ROLE/USER/GROUP */
         | SYSID Iconst
            {
               return makeDefElem("sysid", makeInteger($_[2]));
            }
         | ADMIN name_list
            {
               return makeDefElem("adminmembers", $_[2]);
            }
         | ROLE name_list
            {
               return makeDefElem("rolemembers", $_[2]);
            }
         | IN ROLE name_list
            {
               return makeDefElem("addroleto", $_[3]);
            }
         | IN GROUP name_list
            {
               return makeDefElem("addroleto", $_[3]);
            }
      ;


/*****************************************************************************
 *
 * Create a new Postgres DBMS user (role with implied login ability)
 *
 *****************************************************************************/

CreateUserStmt:
         CREATE USER RoleId opt_with OptRoleList
            {
               return SQL::Translator::Statement::CreateRole->new(
                  stmt_type => ROLESTMT_USER,
                  role      => $_[3],
                  options   => $_[5],
               );
            }
      ;


/*****************************************************************************
 *
 * Alter a postgresql DBMS role
 *
 *****************************************************************************/

AlterRoleStmt:
         ALTER ROLE RoleId opt_with AlterOptRoleList
             {
               return SQL::Translator::Statement::AlterRole->new(
                  role    => $_[3],
                  action  => +1,   /* add, if there are members */
                  options => $_[5],
               );
             }
      ;

opt_in_database:
            /* EMPTY */                { NULL  }
         | IN DATABASE database_name   { $_[3] }
      ;

AlterRoleSetStmt:
         ALTER ROLE RoleId opt_in_database SetResetClause
            {
               return SQL::Translator::Statement::AlterRoleSet->new(
                  role     => $_[3],
                  database => $_[4],
                  setstmt  => $_[5],
               );
            }
      ;


/*****************************************************************************
 *
 * Alter a postgresql DBMS user
 *
 *****************************************************************************/

AlterUserStmt:
         ALTER USER RoleId opt_with AlterOptRoleList
             {
               return SQL::Translator::Statement::AlterRole->new(
                  role     => $_[3],
                  action   => +1,   #* add, if there are members
                  options  => $_[5],
               );
             }
      ;


AlterUserSetStmt:
         ALTER USER RoleId SetResetClause
            {
               return SQL::Translator::Statement::AlterRoleSet->new(
                  role     => $_[3],
                  database => NULL,
                  setstmt  => $_[4],
               );
            }
         ;


/*****************************************************************************
 *
 * Drop a postgresql DBMS role
 *
 * XXX Ideally this would have CASCADE/RESTRICT options, but since a role
 * might own objects in multiple databases, there is presently no way to
 * implement either cascading or restricting.  Caveat DBA.
 *****************************************************************************/

DropRoleStmt:
         DROP ROLE name_list
            {
               return SQL::Translator::Statement::DropRole->new(
                  missing_ok => FALSE,
                  roles      => $_[3],
               );
            }
         | DROP ROLE IF EXISTS name_list
            {
               return SQL::Translator::Statement::DropRole->new(
                  missing_ok => TRUE,
                  roles      => $_[5],
               );
            }
         ;

/*****************************************************************************
 *
 * Drop a postgresql DBMS user
 *
 * XXX Ideally this would have CASCADE/RESTRICT options, but since a user
 * might own objects in multiple databases, there is presently no way to
 * implement either cascading or restricting.  Caveat DBA.
 *****************************************************************************/

DropUserStmt:
         DROP USER name_list
            {
               return SQL::Translator::Statement::DropRole->new(
                  missing_ok => FALSE,
                  roles      => $_[3],
               );
            }
         | DROP USER IF EXISTS name_list
            {
               return SQL::Translator::Statement::DropRole->new(
                  roles      => $_[5],
                  missing_ok => TRUE,
               );
            }
         ;


/*****************************************************************************
 *
 * Create a postgresql group (role without login ability)
 *
 *****************************************************************************/

CreateGroupStmt:
         CREATE GROUP RoleId opt_with OptRoleList
            {
               return SQL::Translator::Statement::CreateRole->new(
                  stmt_type => ROLESTMT_GROUP,
                  role      => $_[3],
                  options   => $_[5],
               );
            }
      ;


/*****************************************************************************
 *
 * Alter a postgresql group
 *
 *****************************************************************************/

AlterGroupStmt:
         ALTER GROUP RoleId add_drop USER name_list
            {
               return SQL::Translator::Statement::AlterRole->new(
                  role    => $_[3],
                  action  => $_[4],
                  options => lappend(makeDefElem("rolemembers",
                                          $_[6]));
               );
            }
      ;

add_drop:  ADD                           { +1 }
         | DROP                          { -1 }
      ;


/*****************************************************************************
 *
 * Drop a postgresql group
 *
 * XXX see above notes about cascading DROP USER; groups have same problem.
 *****************************************************************************/

DropGroupStmt:
         DROP GROUP name_list
            {
               return SQL::Translator::Statement::DropRole->new(
                  missing_ok => FALSE,
                  roles      => $_[3],
               );
            }
         | DROP GROUP IF EXISTS name_list
            {
               return SQL::Translator::Statement::DropRole->new(
                  missing_ok => TRUE,
                  roles      => $_[5],
               );
            }
      ;


/*****************************************************************************
 *
 * Manipulate a schema
 *
 *****************************************************************************/

CreateSchemaStmt:
         CREATE SCHEMA OptSchemaName AUTHORIZATION RoleId OptSchemaEltList
            {
               return SQL::Translator::Statement::CreateSchema->new(
                  #* One can omit the schema name or the authorization id.
                  (defined $_[3]) ? (
                     schemaname => $_[3],
                  ) : (
                     schemaname => $_[5],
                     authid     => $_[5],
                     schemaElts => $_[6],
                  ),
               );
            }
         | CREATE SCHEMA ColId OptSchemaEltList
            {
               return SQL::Translator::Statement::CreateSchema->new(
                  #* ...but not both
                  schemaname => $_[3],
                  authid     => NULL,
                  schemaElts => $_[4],
               );
            }
      ;

OptSchemaName:
         ColId                             { $_[1] }
         | /* EMPTY */                     { NULL  }
      ;

OptSchemaEltList:
         OptSchemaEltList schema_stmt      { lappend($_[1], $_[2]) }
         | /* EMPTY */                     { NIL }
      ;

/*
 *   schema_stmt are the ones that can show up inside a CREATE SCHEMA
 *   statement (in addition to by themselves).
 */
schema_stmt:
         CreateStmt
         | IndexStmt
         | CreateSeqStmt
         | CreateTrigStmt
         | GrantStmt
         | ViewStmt
      ;


/*****************************************************************************
 *
 * Set PG internal variable
 *     SET name TO 'var_value'
 * Include SQL92 syntax (thomas 1997-10-22):
 *     SET TIME ZONE 'var_value'
 *
 *****************************************************************************/

VariableSetStmt:
           SET set_rest          { $_[2]->_is_local(0); $_[2]; }
         | SET LOCAL set_rest    { $_[3]->_is_local(1); $_[3]; }
         | SET SESSION set_rest  { $_[3]->_is_local(0); $_[3]; }
      ;

set_rest:   /* Generic SET syntaxes: */
         var_name TO var_list
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => $_[1],
                  args => $_[3],
               );
            }
         | var_name '=' var_list
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => $_[1],
                  args => $_[3],
               );
            }
         | var_name TO DEFAULT
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_DEFAULT,
                  name => $_[1],
               );
            }
         | var_name '=' DEFAULT
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_DEFAULT,
                  name => $_[1],
               );
            }
         | var_name FROM CURRENT
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_CURRENT,
                  name => $_[1],
               );
            }
         /* Special syntaxes mandated by SQL standard: */
         | TIME ZONE zone_value
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => 'timezone',
                  (defined $_[3]) ?
                     (args => lappend($_[3])) :
                     (kind => VAR_SET_DEFAULT),
            }
         | TRANSACTION transaction_mode_list
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_MULTI,
                  name => 'TRANSACTION',
                  args => $_[2],
               );
            }
         | SESSION CHARACTERISTICS AS TRANSACTION transaction_mode_list
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_MULTI,
                  name => 'SESSION CHARACTERISTICS',
                  args => $_[5],
               );
            }
         | CATALOG Sconst
            {
               $_[0]->ereport(ERROR,
                     ERRCODE_FEATURE_NOT_SUPPORTED,
                      "current database cannot be changed",
                      $_[0]->YYLLoc($_[2], 2));
               return NULL; /*not reached*/
            }
         | SCHEMA Sconst
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => 'search_path',
                  args => lappend(makeStringConst($_[2], $_[0]->YYLLoc($_[2], 2))),
               );
            }
         | NAMES opt_encoding
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => 'client_encoding',
                  (defined $_[2]) ?
                     (args => lappend(makeStringConst($_[2], $_[0]->YYLLoc($_[2], 2)))) :
                     (kind => OBJECT_DEFAULT),
               );
            }
         | ROLE ColId_or_Sconst
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => 'role',
                  args => lappend(makeStringConst($_[2], $_[0]->YYLLoc($_[2], 2))),
               );
            }
         | SESSION AUTHORIZATION ColId_or_Sconst
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => 'session_authorization',
                  args => lappend(makeStringConst($_[3], $_[0]->YYLLoc($_[3], 3))),
               );
            }
         | SESSION AUTHORIZATION DEFAULT
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_DEFAULT,
                  name => 'session_authorization',
               );
            }
         | XML OPTION document_or_content
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_SET_VALUE,
                  name => 'xmloption',
                  args => lappend(makeStringConst($_[3], $_[0]->YYLLoc($_[3], 3))),
               );
            }
      ;

var_name:   ColId                        { $_[1] }
         | var_name '.' ColId
            {
               return sprintf("%s.%s", $_[1], $_[3]);
            }
      ;

var_list:   var_value                       { lappend($_[1]) }
         | var_list ',' var_value           { lappend($_[1], $_[3]) }
      ;

var_value:   opt_boolean_or_string
            { makeStringConst($_[1], $_[0]->YYLLoc($_[1], 1)) }
         | NumericOnly
            { makeAConst($_[1], $_[0]->YYLLoc($_[1], 1)) }
      ;

iso_level:   READ UNCOMMITTED               { "read uncommitted" }
         | READ COMMITTED                   { "read committed" }
         | REPEATABLE READ                  { "repeatable read" }
         | SERIALIZABLE                     { "serializable" }
      ;

opt_boolean_or_string:
         TRUE                               { "TRUE" }
         | FALSE                            { "FALSE" }
         | ON                               { "on" }
         /*
          * OFF is also accepted as a boolean value, but is handled
          * by the ColId rule below. The action for booleans and strings
          * is the same, so we don't need to distinguish them here.
          */
         | ColId_or_Sconst                  { $_[1] }
      ;

/* Timezone values can be:
 * - a string such as 'pst8pdt'
 * - an identifier such as "pst8pdt"
 * - an integer or floating point number
 * - a time interval per SQL99
 * ColId gives reduce/reduce errors against ConstInterval and LOCAL,
 * so use IDENT (meaning we reject anything that is a key word).
 */
zone_value:
         Sconst
            {
               return makeStringConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | IDENT
            {
               return makeStringConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | ConstInterval Sconst opt_interval
            {
               my $t = $_[1];
               if (defined $_[3]) {
                  my $n = $_[3]->[0];
                  if (($n->val & ~(INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE))) != 0) {
                     $_[0]->ereport(ERROR,
                           ERRCODE_SYNTAX_ERROR,
                            "Time zone interval must be HOUR or HOUR TO MINUTE",
                            $_[0]->YYLLoc($_[3], 3));
                  }
               }
               $t->typmods = $_[3];
               return makeStringConstCast($_[2], $_[0]->YYLLoc($_[2], 2), $t);
            }
         | ConstInterval '(' Iconst ')' Sconst opt_interval
            {
               my $t = $_[1];
               if (defined $_[6]) {
                  my $n = $_[6]->[0];
                  if (($n->val & ~(INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE))) != 0) {
                     $_[0]->ereport(ERROR,
                           ERRCODE_SYNTAX_ERROR,
                            "Time zone interval must be HOUR or HOUR TO MINUTE",
                            $_[0]->YYLLoc($_[6], 6));
                  }
                  if (@{$_[6]} != 1) {
                     $_[0]->ereport(ERROR,
                           ERRCODE_SYNTAX_ERROR,
                            "interval precision specified twice",
                            $_[0]->YYLLoc($_[1], 1));
                  }
                  $t->typmods( lappend($_[6],                                 makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               }
               else {
                  $t->typmods( lappend(makeIntConst(INTERVAL_FULL_RANGE, -1), makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               }
               return makeStringConstCast($_[5], $_[0]->YYLLoc($_[5], 5), $t);
            }
         | NumericOnly                     { makeAConst($_[1], $_[0]->YYLLoc($_[1], 1)) }
         | DEFAULT                         { NULL }
         | LOCAL                           { NULL }
      ;

opt_encoding:
         Sconst                            { $_[1] }
         | DEFAULT                         { NULL  }
         | /*EMPTY*/                       { NULL  }
      ;

ColId_or_Sconst:
         ColId                           { $_[1] }
         | Sconst                        { $_[1] }
      ;

VariableResetStmt:
         RESET var_name
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_RESET,
                  name => $_[2],
               );
            }
         | RESET TIME ZONE
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_RESET,
                  name => 'timezone',
               );
            }
         | RESET TRANSACTION ISOLATION LEVEL
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_RESET,
                  name => 'transaction_isolation',
               );
            }
         | RESET SESSION AUTHORIZATION
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_RESET,
                  name => 'session_authorization',
               );
            }
         | RESET ALL
            {
               return SQL::Translator::Statement::VariableSet->new(
                  kind => VAR_RESET_ALL,
               );
            }
      ;

/* SetResetClause allows SET or RESET without LOCAL */
SetResetClause:
         SET set_rest               { $_[2] }
         | VariableResetStmt        { $_[1] }
      ;


VariableShowStmt:
         SHOW var_name
            {
               return SQL::Translator::Statement::VariableShow->new(
                  name => $_[2],
               );
            }
         | SHOW TIME ZONE
            {
               return SQL::Translator::Statement::VariableShow->new(
                  name => 'timezone',
               );
            }
         | SHOW TRANSACTION ISOLATION LEVEL
            {
               return SQL::Translator::Statement::VariableShow->new(
                  name => 'transaction_isolation',
               );
            }
         | SHOW SESSION AUTHORIZATION
            {
               return SQL::Translator::Statement::VariableShow->new(
                  name => 'session_authorization',
               );
            }
         | SHOW ALL
            {
               return SQL::Translator::Statement::VariableShow->new(
                  name => 'all',
               );
            }
      ;


ConstraintsSetStmt:
         SET CONSTRAINTS constraints_set_list constraints_set_mode
            {
               return SQL::Translator::Statement::ConstraintsSet->new(
                  constraints => $_[3],
                  deferred    => $_[4];
               );
            }
      ;

constraints_set_list:
         ALL                              { NIL   }
         | qualified_name_list            { $_[1] }
      ;

constraints_set_mode:
         DEFERRED                         { TRUE  }
         | IMMEDIATE                      { FALSE }
      ;


/*
 * Checkpoint statement
 */
CheckPointStmt:
         CHECKPOINT
            {
               return SQL::Translator::Statement::CheckPoint->new();
            }
      ;


/*****************************************************************************
 *
 * DISCARD { ALL | TEMP | PLANS }
 *
 *****************************************************************************/

DiscardStmt:
         DISCARD ALL
            {
               return SQL::Translator::Statement::Discard->new(
                  target => DISCARD_ALL,
               );
            }
         | DISCARD TEMP
            {
               return SQL::Translator::Statement::Discard->new(
                  target => DISCARD_TEMP,
               );
            }
         | DISCARD TEMPORARY
            {
               return SQL::Translator::Statement::Discard->new(
                  target => DISCARD_TEMP,
               );
            }
         | DISCARD PLANS
            {
               return SQL::Translator::Statement::Discard->new(
                  target => DISCARD_PLANS,
               );
            }
      ;


/*****************************************************************************
 *
 *   ALTER [ TABLE | INDEX | SEQUENCE | VIEW ] variations
 *
 * Note: we accept all subcommands for each of the four variants, and sort
 * out what's really legal at execution time.
 *****************************************************************************/

AlterTableStmt:
         ALTER TABLE relation_expr alter_table_cmds
            {
               return SQL::Translator::Statement::AlterTable->new(
                  relation => $_[3],
                  cmds     => $_[4],
                  relkind  => OBJECT_TABLE,
               );
            }
      |   ALTER INDEX qualified_name alter_table_cmds
            {
               return SQL::Translator::Statement::AlterTable->new(
                  relation => $_[3],
                  cmds     => $_[4],
                  relkind  => OBJECT_INDEX,
               );
            }
      |   ALTER SEQUENCE qualified_name alter_table_cmds
            {
               return SQL::Translator::Statement::AlterTable->new(
                  relation => $_[3],
                  cmds     => $_[4],
                  relkind  => OBJECT_SEQUENCE,
               );
            }
      |   ALTER VIEW qualified_name alter_table_cmds
            {
               return SQL::Translator::Statement::AlterTable->new(
                  relation => $_[3],
                  cmds     => $_[4],
                  relkind  => OBJECT_VIEW,
               );
            }
      ;

alter_table_cmds:
           alter_table_cmd                        { lappend($_[1]);        }
         | alter_table_cmds ',' alter_table_cmd   { lappend($_[1], $_[3]); }
      ;

alter_table_cmd:
         /* ALTER TABLE <name> ADD <coldef> */
         ADD columnDef
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddColumn,
                  def        => $_[2],
               );
            }
         /* ALTER TABLE <name> ADD COLUMN <coldef> */
         | ADD COLUMN columnDef
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddColumn,
                  def        => $_[3],
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> {SET DEFAULT <expr>|DROP DEFAULT} */
         | ALTER opt_column ColId alter_column_default
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_ColumnDefault,
                  name       => $_[3],
                  def        => $_[4],
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> DROP NOT NULL */
         | ALTER opt_column ColId DROP NOT NULL
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropNotNull,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> SET NOT NULL */
         | ALTER opt_column ColId SET NOT NULL
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_SetNotNull,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> SET STATISTICS <SignedIconst> */
         | ALTER opt_column ColId SET STATISTICS SignedIconst
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_SetStatistics,
                  name       => $_[3],
                  def        => makeInteger($_[6]),
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> SET ( column_parameter = value [, ... ] ) */
         | ALTER opt_column ColId SET reloptions
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_SetOptions,
                  name       => $_[3],
                  def        => $_[5],
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> SET ( column_parameter = value [, ... ] ) */
         | ALTER opt_column ColId RESET reloptions
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_ResetOptions,
                  name       => $_[3],
                  def        => $_[5],
               );
            }
         /* ALTER TABLE <name> ALTER [COLUMN] <colname> SET STORAGE <storagemode> */
         | ALTER opt_column ColId SET STORAGE ColId
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_SetStorage,
                  name       => $_[3],
                  def        => makeString($_[6]),
               );
            }
         /* ALTER TABLE <name> DROP [COLUMN] IF EXISTS <colname> [RESTRICT|CASCADE] */
         | DROP opt_column IF EXISTS ColId opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropColumn,
                  name       => $_[5],
                  behavior   => $_[6],
                  missing_ok => TRUE,
               );
            }
         /* ALTER TABLE <name> DROP [COLUMN] <colname> [RESTRICT|CASCADE] */
         | DROP opt_column ColId opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropColumn,
                  name       => $_[3],
                  behavior   => $_[4],
                  missing_ok => FALSE,
               );
            }
         /*
          * ALTER TABLE <name> ALTER [COLUMN] <colname> [SET DATA] TYPE <typename>
          *      [ USING <expression> ]
          */
         | ALTER opt_column ColId opt_set_data TYPE Typename opt_collate_clause alter_using
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype => AT_AlterColumnType,
                  name    => $_[3],
                  def     => SQL::Translator::Statement::Column::Definition->new(
                     #* We only use these three fields of the ColumnDef node
                     typeName    => $_[6];
                     collClause  => $_[7];
                     raw_default => $_[8];
                  ),
               );
            }
         /* ALTER TABLE <name> ADD CONSTRAINT ... */
         | ADD TableConstraint
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddConstraint,
                  def        => $_[2],
               );
            }
         /* ALTER TABLE <name> VALIDATE CONSTRAINT ... */
         | VALIDATE CONSTRAINT name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_ValidateConstraint,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> DROP CONSTRAINT IF EXISTS <name> [RESTRICT|CASCADE] */
         | DROP CONSTRAINT IF EXISTS name opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropConstraint,
                  name       => $_[5],
                  behavior   => $_[6],
                  missing_ok => TRUE,
               );
            }
         /* ALTER TABLE <name> DROP CONSTRAINT <name> [RESTRICT|CASCADE] */
         | DROP CONSTRAINT name opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropConstraint,
                  name       => $_[3],
                  behavior   => $_[4],
                  missing_ok => FALSE,
               );
            }
         /* ALTER TABLE <name> SET WITH OIDS  */
         | SET WITH OIDS
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddOids,
               );
            }
         /* ALTER TABLE <name> SET WITHOUT OIDS  */
         | SET WITHOUT OIDS
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropOids,
               );
            }
         /* ALTER TABLE <name> CLUSTER ON <indexname> */
         | CLUSTER ON name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_ClusterOn,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> SET WITHOUT CLUSTER */
         | SET WITHOUT CLUSTER
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropCluster,
                  name       => NULL,
               );
            }
         /* ALTER TABLE <name> ENABLE TRIGGER <trig> */
         | ENABLE TRIGGER name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableTrig,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> ENABLE ALWAYS TRIGGER <trig> */
         | ENABLE ALWAYS TRIGGER name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableAlwaysTrig,
                  name       => $_[4],
               );
            }
         /* ALTER TABLE <name> ENABLE REPLICA TRIGGER <trig> */
         | ENABLE REPLICA TRIGGER name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableReplicaTrig,
                  name       => $_[4],
               );
            }
         /* ALTER TABLE <name> ENABLE TRIGGER ALL */
         | ENABLE TRIGGER ALL
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableTrigAll,
               );
            }
         /* ALTER TABLE <name> ENABLE TRIGGER USER */
         | ENABLE TRIGGER USER
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableTrigUser,
               );
            }
         /* ALTER TABLE <name> DISABLE TRIGGER <trig> */
         | DISABLE TRIGGER name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DisableTrig,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> DISABLE TRIGGER ALL */
         | DISABLE TRIGGER ALL
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DisableTrigAll,
               );
            }
         /* ALTER TABLE <name> DISABLE TRIGGER USER */
         | DISABLE TRIGGER USER
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DisableTrigUser,
               );
            }
         /* ALTER TABLE <name> ENABLE RULE <rule> */
         | ENABLE RULE name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableRule,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> ENABLE ALWAYS RULE <rule> */
         | ENABLE ALWAYS RULE name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableAlwaysRule,
                  name       => $_[4],
               );
            }
         /* ALTER TABLE <name> ENABLE REPLICA RULE <rule> */
         | ENABLE REPLICA RULE name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_EnableReplicaRule,
                  name       => $_[4],
               );
            }
         /* ALTER TABLE <name> DISABLE RULE <rule> */
         | DISABLE RULE name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DisableRule,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> INHERIT <parent> */
         | INHERIT qualified_name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddInherit,
                  def        =>  $_[2],
               );
            }
         /* ALTER TABLE <name> NO INHERIT <parent> */
         | NO INHERIT qualified_name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropInherit,
                  def        =>  $_[3],
               );
            }
         /* ALTER TABLE <name> OF <type_name> */
         | OF any_name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddOf,
                  # TODO: #* TypeName *def = makeTypeNameFromNameList($_[2]);
               );
            }
         /* ALTER TABLE <name> NOT OF */
         | NOT OF
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropOf,
               );
            }
         /* ALTER TABLE <name> OWNER TO RoleId */
         | OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_ChangeOwner,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> SET TABLESPACE <tablespacename> */
         | SET TABLESPACE name
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_SetTableSpace,
                  name       => $_[3],
               );
            }
         /* ALTER TABLE <name> SET (...) */
         | SET reloptions
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_SetRelOptions,
                  def        => $_[2],
               );
            }
         /* ALTER TABLE <name> RESET (...) */
         | RESET reloptions
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_ResetRelOptions,
                  def        => $_[2],
               );
            }
         | alter_generic_options
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_GenericOptions,
                  def        => $_[1],
               );
            }
      ;

alter_column_default:
           SET DEFAULT a_expr      { $_[3] }
         | DROP DEFAULT            { NULL  }
      ;

opt_drop_behavior:
         CASCADE                  { DROP_CASCADE  }
         | RESTRICT               { DROP_RESTRICT }
         | /* EMPTY */            { DROP_RESTRICT }  /* default */
      ;

opt_collate_clause:
         COLLATE any_name
            {
               return SQL::Translator::Statement::CollateClause->new(
                  arg      => NULL,
                  collname => $_[2],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | /* EMPTY */            { NULL }
      ;

alter_using:
         USING a_expr             { $_[2] }
         | /* EMPTY */            { NULL  }
      ;

reloptions:
           '(' reloption_list ')'               { $_[2] }
      ;

opt_reloptions:  WITH reloptions                { $_[2] }
          |      /* EMPTY */                    { NIL   }
      ;

reloption_list:
           reloption_elem                         { lappend($_[1]) }
         | reloption_list ',' reloption_elem      { lappend($_[1], $_[3]) }
      ;

/* This should match def_elem and also allow qualified names */
reloption_elem:
         ColLabel '=' def_arg
            {
               return makeDefElem($_[1], $_[3]);
            }
         | ColLabel
            {
               return makeDefElem($_[1], NULL);
            }
         | ColLabel '.' ColLabel '=' def_arg
            {
               return makeDefElemExtended($_[1], $_[3], $_[5], DEFELEM_UNSPEC);
            }
         | ColLabel '.' ColLabel
            {
               return makeDefElemExtended($_[1], $_[3], NULL,  DEFELEM_UNSPEC);
            }
      ;


/*****************************************************************************
 *
 *   ALTER TYPE
 *
 * really variants of the ALTER TABLE subcommands with different spellings
 *****************************************************************************/

AlterCompositeTypeStmt:
         ALTER TYPE any_name alter_type_cmds
            {
               return SQL::Translator::Statement::AlterTable->new(
                  #* can't use qualified_name, sigh
                  # TODO: #* relation => makeRangeVarFromAnyName($_[3], $_[0]->YYLLoc($_[3], 3)),
                  cmds    => $_[4],
                  relkind => OBJECT_TYPE,
               );
            }
         ;

alter_type_cmds:
           alter_type_cmd                       { lappend($_[1])        }
         | alter_type_cmds ',' alter_type_cmd   { lappend($_[1], $_[3]) }
      ;

alter_type_cmd:
         /* ALTER TYPE <name> ADD ATTRIBUTE <coldef> [RESTRICT|CASCADE] */
         ADD ATTRIBUTE TableFuncElement opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AddColumn,
                  def        => $_[3],
                  behavior   => $_[4],
               );
            }
         /* ALTER TYPE <name> DROP ATTRIBUTE IF EXISTS <attname> [RESTRICT|CASCADE] */
         | DROP ATTRIBUTE IF EXISTS ColId opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropColumn,
                  name       => $_[5],
                  behavior   => $_[6],
                  missing_ok => TRUE,
               );
            }
         /* ALTER TYPE <name> DROP ATTRIBUTE <attname> [RESTRICT|CASCADE] */
         | DROP ATTRIBUTE ColId opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_DropColumn,
                  name       => $_[3],
                  behavior   => $_[4],
                  missing_ok => FALSE,
               );
            }
         /* ALTER TYPE <name> ALTER ATTRIBUTE <attname> [SET DATA] TYPE <typename> [RESTRICT|CASCADE] */
         | ALTER ATTRIBUTE ColId opt_set_data TYPE Typename opt_collate_clause opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterTable::Command->new(
                  subtype    => AT_AlterColumnType,
                  name       => $_[3],
                  def        => SQL::Translator::Statement::Column::Definition->new(
                     #* We only use these three fields of the ColumnDef node
                     typeName    => $_[6];
                     collClause  => $_[7];
                     raw_default => undef;
                  ),
                  behavior   => $_[8],
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERY :
 *            close <portalname>
 *
 *****************************************************************************/

ClosePortalStmt:
         CLOSE cursor_name
            {
               return SQL::Translator::Statement::ClosePortal->new(
                  portalname => $_[2],
               );
            }
         | CLOSE ALL
            {
               return SQL::Translator::Statement::ClosePortal->new(
                  portalname => NULL,
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERY :
 *            COPY relname [(columnList)] FROM/TO file [WITH] [(options)]
 *            COPY ( SELECT ... ) TO file [WITH] [(options)]
 *
 *            In the preferred syntax the options are comma-separated
 *            and use generic identifiers instead of keywords.  The pre-9.0
 *            syntax had a hard-wired, space-separated set of options.
 *
 *            Really old syntax, from versions 7.2 and prior:
 *            COPY [ BINARY ] table [ WITH OIDS ] FROM/TO file
 *               [ [ USING ] DELIMITERS 'delimiter' ] ]
 *               [ WITH NULL AS 'null string' ]
 *            This option placement is not supported with COPY (SELECT...).
 *
 *****************************************************************************/

CopyStmt:   COPY opt_binary qualified_name opt_column_list opt_oids
         copy_from copy_file_name copy_delimiter opt_with copy_options
            {
               return SQL::Translator::Statement::Copy->new(
                  relation => $_[3],
                  query    => NULL,
                  attlist  => $_[4],
                  is_from  => $_[6],
                  filename => $_[7],

                  #* Concatenate user-supplied flags
                  options  => lappend(@_[2,5,8,10]),
               );
            }
         | COPY select_with_parens TO copy_file_name opt_with copy_options
            {
               return SQL::Translator::Statement::Copy->new(
                  relation => NULL,
                  query    => $_[2],
                  attlist  => NIL,
                  is_from  => FALSE,
                  filename => $_[4],
                  options  => $_[6],
               );
            }
      ;

copy_from:
         FROM                           { TRUE  }
         | TO                           { FALSE }
      ;

/*
 * copy_file_name NULL indicates stdio is used. Whether stdin or stdout is
 * used depends on the direction. (It really doesn't make sense to copy from
 * stdout. We silently correct the "typo".)       - AY 9/94
 */
copy_file_name:
         Sconst                           { $_[1] }
         | STDIN                          { NULL  }
         | STDOUT                         { NULL  }
      ;

copy_options: copy_opt_list               { $_[1] }
         | '(' copy_generic_opt_list ')'  { $_[2] }
      ;

/* old COPY option syntax */
copy_opt_list:
         copy_opt_list copy_opt_item      { lappend($_[1], $_[2]) }
         | /* EMPTY */                    { NIL   }
      ;

copy_opt_item:
         BINARY
            {
               return makeDefElem("format", makeString("binary"));
            }
         | OIDS
            {
               return makeDefElem("oids", makeInteger(TRUE));
            }
         | DELIMITER opt_as Sconst
            {
               return makeDefElem("delimiter", makeString($_[3]));
            }
         | NULL opt_as Sconst
            {
               return makeDefElem("null", makeString($_[3]));
            }
         | CSV
            {
               return makeDefElem("format", makeString("csv"));
            }
         | HEADER
            {
               return makeDefElem("header", makeInteger(TRUE));
            }
         | QUOTE opt_as Sconst
            {
               return makeDefElem("quote", makeString($_[3]));
            }
         | ESCAPE opt_as Sconst
            {
               return makeDefElem("escape", makeString($_[3]));
            }
         | FORCE QUOTE columnList
            {
               return makeDefElem("force_quote", $_[3]);
            }
         | FORCE QUOTE '*'
            {
               return makeDefElem("force_quote", makeNode(A_Star));
            }
         | FORCE NOT NULL columnList
            {
               return makeDefElem("force_not_null", $_[4]);
            }
         | ENCODING Sconst
            {
               return makeDefElem("encoding", makeString($_[2]));
            }
      ;

/* The following exist for backward compatibility with very old versions */

opt_binary:
         BINARY
            {
               return makeDefElem("format", makeString("binary"));
            }
         | /*EMPTY*/                        { NULL }
      ;

opt_oids:
         WITH OIDS
            {
               return makeDefElem("oids", makeInteger(TRUE));
            }
         | /*EMPTY*/                        { NULL }
      ;

copy_delimiter:
         opt_using DELIMITERS Sconst
            {
               return makeDefElem("delimiter", makeString($_[3]));
            }
         | /*EMPTY*/                        { NULL }
      ;

opt_using:
         USING                              {}
         | /*EMPTY*/                        {}
      ;

/* new COPY option syntax */
copy_generic_opt_list:
         copy_generic_opt_elem
            {
               return lappend($_[1]);
            }
         | copy_generic_opt_list ',' copy_generic_opt_elem
            {
               return lappend($_[1], $_[3]);
            }
      ;

copy_generic_opt_elem:
         ColLabel copy_generic_opt_arg
            {
               return makeDefElem($_[1], $_[2]);
            }
      ;

copy_generic_opt_arg:
         opt_boolean_or_string                { makeString($_[1]) }
         | NumericOnly                        { $_[1] }
         | '*'                                { makeNode(A_Star) }
         | '(' copy_generic_opt_arg_list ')'  { $_[2] }
         | /* EMPTY */                        { NULL }
      ;

copy_generic_opt_arg_list:
           copy_generic_opt_arg_list_item
            {
               return lappend($_[1]);
            }
         | copy_generic_opt_arg_list ',' copy_generic_opt_arg_list_item
            {
               return lappend($_[1], $_[3]);
            }
      ;

/* beware of emitting non-string list elements here; see commands/define.c */
copy_generic_opt_arg_list_item:
         opt_boolean_or_string   {  makeString($_[1]) }
      ;


/*****************************************************************************
 *
 *      QUERY :
 *            CREATE TABLE relname
 *
 *****************************************************************************/

CreateStmt:   CREATE OptTemp TABLE qualified_name '(' OptTableElementList ')'
         OptInherit OptWith OnCommitOption OptTableSpace
            {
               $_[4]->_relpersistence = $_[2];
               return SQL::Translator::Statement::Create->new(
                  relation       => $_[4],
                  tableElts      => $_[6],
                  inhRelations   => $_[8],
                  constraints    => NIL,
                  options        => $_[9],
                  oncommit       => $_[10],
                  tablespacename => $_[11],
                  if_not_exists  => FALSE,
               );
            }
      | CREATE OptTemp TABLE IF NOT EXISTS qualified_name '('
         OptTableElementList ')' OptInherit OptWith OnCommitOption
         OptTableSpace
            {
               $_[7]->_relpersistence = $_[2];
               return SQL::Translator::Statement::Create->new(
                  relation       => $_[7],
                  tableElts      => $_[9],
                  inhRelations   => $_[11],
                  constraints    => NIL,
                  options        => $_[12],
                  oncommit       => $_[13],
                  tablespacename => $_[14],
                  if_not_exists  => TRUE,
               );
            }
      | CREATE OptTemp TABLE qualified_name OF any_name
         OptTypedTableElementList OptWith OnCommitOption OptTableSpace
            {
               my $ofTypename = makeTypeNameFromNameList($_[6]);
               $ofTypename->location( $_[0]->YYLLoc($_[6], 6) );

               $_[4]->_relpersistence = $_[2];
               return SQL::Translator::Statement::Create->new(
                  relation       => $_[4],
                  tableElts      => $_[7],
                  ofTypename     => $ofTypename,
                  constraints    => NIL,
                  options        => $_[8],
                  oncommit       => $_[9],
                  tablespacename => $_[10],
                  if_not_exists  => FALSE,
               );
            }
      | CREATE OptTemp TABLE IF NOT EXISTS qualified_name OF any_name
         OptTypedTableElementList OptWith OnCommitOption OptTableSpace
            {
               my $ofTypename = makeTypeNameFromNameList($_[9]);
               $ofTypename->location( $_[0]->YYLLoc($_[9], 9) );

               $_[7]->_relpersistence = $_[2];
               return SQL::Translator::Statement::Create->new(
                  relation       => $_[7],
                  tableElts      => $_[10],
                  ofTypename     => $ofTypename,
                  constraints    => NIL,
                  options        => $_[11],
                  oncommit       => $_[12],
                  tablespacename => $_[13],
                  if_not_exists  => TRUE,
               );
            }
      ;

/*
 * Redundancy here is needed to avoid shift/reduce conflicts,
 * since TEMP is not a reserved word.  See also OptTempTableName.
 *
 * NOTE: we accept both GLOBAL and LOCAL options; since we have no modules
 * the LOCAL keyword is really meaningless.
 */
OptTemp:   TEMPORARY                     { RELPERSISTENCE_TEMP      }
         | TEMP                          { RELPERSISTENCE_TEMP      }
         | LOCAL TEMPORARY               { RELPERSISTENCE_TEMP      }
         | LOCAL TEMP                    { RELPERSISTENCE_TEMP      }
         | GLOBAL TEMPORARY              { RELPERSISTENCE_TEMP      }
         | GLOBAL TEMP                   { RELPERSISTENCE_TEMP      }
         | UNLOGGED                      { RELPERSISTENCE_UNLOGGED  }
         | /*EMPTY*/                     { RELPERSISTENCE_PERMANENT }
      ;

OptTableElementList:
         TableElementList                { $_[1] }
         | /*EMPTY*/                     { NIL   }
      ;

OptTypedTableElementList:
         '(' TypedTableElementList ')'   { $_[2] }
         | /*EMPTY*/                     { NIL   }
      ;

TableElementList:
         TableElement
            {
               return lappend($_[1]);
            }
         | TableElementList ',' TableElement
            {
               return lappend($_[1], $_[3]);
            }
      ;

TypedTableElementList:
         TypedTableElement
            {
               return lappend($_[1]);
            }
         | TypedTableElementList ',' TypedTableElement
            {
               return lappend($_[1], $_[3]);
            }
      ;

TableElement:
         columnDef                       { $_[1] }
         | TableLikeClause               { $_[1] }
         | TableConstraint               { $_[1] }
      ;

TypedTableElement:
         columnOptions                   { $_[1] }
         | TableConstraint               { $_[1] }
      ;

columnDef:   ColId Typename ColQualList
            {
               my $n = SQL::Translator::Statement::Column::Definition->new(
                  colname        => $_[1],
                  typeName       => $_[2],
                  inhcount       => 0,
                  is_local       => TRUE,
                  is_not_null    => FALSE,
                  is_from_type   => FALSE,
                  storage        => 0,
                  raw_default    => NULL,
                  cooked_default => NULL,
                  collOid        => InvalidOid,
               );
               $_[0]->SplitColQualList($_[3], $n);
               return $n;
            }
      ;

columnOptions:   ColId WITH OPTIONS ColQualList
            {
               my $n = SQL::Translator::Statement::Column::Definition->new(
                  colname        => $_[1],
                  typeName       => NULL,
                  inhcount       => 0,
                  is_local       => TRUE,
                  is_not_null    => FALSE,
                  is_from_type   => FALSE,
                  storage        => 0,
                  raw_default    => NULL,
                  cooked_default => NULL,
                  collOid        => InvalidOid,
               $_[0]->SplitColQualList($_[4], $n);
               return $n;
            }
      ;

ColQualList:
         ColQualList ColConstraint          { lappend($_[1], $_[2]) }
         | /*EMPTY*/                        { NIL }
      ;

ColConstraint:
         CONSTRAINT name ColConstraintElem
            {
               $_[3]->_conname($_[2]);
               $_[3]->_location($_[0]->YYLLoc($_[1], 1));
               return $_[3];
            }
         | ColConstraintElem               { $_[1] }
         | ConstraintAttr                  { $_[1] }
         | COLLATE any_name
            {
               /*
                * Note: the CollateClause is momentarily included in
                * the list built by ColQualList, but we split it out
                * again in SplitColQualList.
                */
               return SQL::Translator::Statement::CollateClause->new(
                  arg      => NULL,
                  collname => $_[2],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

/* DEFAULT NULL is already the default for Postgres.
 * But define it here and carry it forward into the system
 * to make it explicit.
 * - thomas 1998-09-13
 *
 * WITH NULL and NULL are not SQL92-standard syntax elements,
 * so leave them out. Use DEFAULT NULL to explicitly indicate
 * that a column may have that value. WITH NULL leads to
 * shift/reduce conflicts with WITH TIME ZONE anyway.
 * - thomas 1999-01-08
 *
 * DEFAULT expression must be b_expr not a_expr to prevent shift/reduce
 * conflict on NOT (since NOT might start a subsequent NOT NULL constraint,
 * or be part of a_expr NOT LIKE or similar constructs).
 */
ColConstraintElem:
         NOT NULL
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_NOTNULL,
                  location        => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | NULL
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_NULL,
                  location        => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | UNIQUE opt_definition OptConsTableSpace
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_UNIQUE,
                  location        => $_[0]->YYLLoc($_[1], 1),
                  keys            => NULL,
                  options         => $_[2],
                  indexname       => NULL,
                  indexspace      => $_[3],
               );
            }
         | PRIMARY KEY opt_definition OptConsTableSpace
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_PRIMARY,
                  location        => $_[0]->YYLLoc($_[1], 1),
                  keys            => NULL,
                  options         => $_[3],
                  indexname       => NULL,
                  indexspace      => $_[4],
               );
            }
         | CHECK '(' a_expr ')'
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_CHECK,
                  location        => $_[0]->YYLLoc($_[1], 1),
                  raw_expr        => $_[3],
                  cooked_expr     => NULL,
               );
            }
         | DEFAULT b_expr
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_DEFAULT,
                  location        => $_[0]->YYLLoc($_[1], 1),
                  raw_expr        => $_[2],
                  cooked_expr     => NULL,
               );
            }
         | REFERENCES qualified_name opt_column_list key_match key_actions
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype         => CONSTR_FOREIGN,
                  location        => $_[0]->YYLLoc($_[1], 1),
                  pktable         => $_[2],
                  fk_attrs        => NIL,
                  pk_attrs        => $_[3],
                  fk_matchtype    => $_[4],
                  fk_upd_action   => ($_[5] >> 8),
                  fk_del_action   => ($_[5] & 0xFF),
                  skip_validation => FALSE,
                  initially_valid => TRUE,
               );
            }
      ;

/*
 * ConstraintAttr represents constraint attributes, which we parse as if
 * they were independent constraint clauses, in order to avoid shift/reduce
 * conflicts (since NOT might start either an independent NOT NULL clause
 * or an attribute).  parse_utilcmd.c is responsible for attaching the
 * attribute information to the preceding "real" constraint node, and for
 * complaining if attribute clauses appear in the wrong place or wrong
 * combinations.
 *
 * See also ConstraintAttributeSpec, which can be used in places where
 * there is no parsing conflict.  (Note: currently, NOT VALID is an allowed
 * clause in ConstraintAttributeSpec, but not here.  Someday we might need
 * to allow it here too, but for the moment it doesn't seem useful in the
 * statements that use ConstraintAttr.)
 */
ConstraintAttr:
         DEFERRABLE
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype  => CONSTR_ATTR_DEFERRABLE,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | NOT DEFERRABLE
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype  => CONSTR_ATTR_NOT_DEFERRABLE,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | INITIALLY DEFERRED
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype  => CONSTR_ATTR_DEFERRED,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | INITIALLY IMMEDIATE
            {
               return SQL::Translator::Statement::Constraint->new(
                  contype  => CONSTR_ATTR_IMMEDIATE,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;


/*
 * SQL99 supports wholesale borrowing of a table definition via the LIKE clause.
 * This seems to be a poor man's inheritance capability, with the resulting
 * tables completely decoupled except for the original commonality in definitions.
 *
 * This is very similar to CREATE TABLE AS except for the INCLUDING DEFAULTS extension
 * which is a part of SQL:2003.
 */
TableLikeClause:
         LIKE qualified_name TableLikeOptionList
            {
               return SQL::Translator::Statement::InhRelation->new(
                  relation => $_[2],
                  options  => $_[3],
               );
            }
      ;

TableLikeOptionList:
              TableLikeOptionList INCLUDING TableLikeOption { $_[1] |  $_[3] }
            | TableLikeOptionList EXCLUDING TableLikeOption { $_[1] & ~$_[3] }
            | /* EMPTY */                  { 0 }
      ;

TableLikeOption:
              DEFAULTS         { CREATE_TABLE_LIKE_DEFAULTS    }
            | CONSTRAINTS      { CREATE_TABLE_LIKE_CONSTRAINTS }
            | INDEXES          { CREATE_TABLE_LIKE_INDEXES     }
            | STORAGE          { CREATE_TABLE_LIKE_STORAGE     }
            | COMMENTS         { CREATE_TABLE_LIKE_COMMENTS    }
            | ALL              { CREATE_TABLE_LIKE_ALL         }
      ;


/* ConstraintElem specifies constraint syntax which is not embedded into
 *   a column definition. ColConstraintElem specifies the embedded form.
 * - thomas 1997-12-03
 */
TableConstraint:
         CONSTRAINT name ConstraintElem
            {
               $_[3]->_conname($_[2]);
               $_[3]->_location($_[0]->YYLLoc($_[1], 1));
               return $_[3];
            }
         | ConstraintElem                  { $_[1] }
      ;

ConstraintElem:
         CHECK '(' a_expr ')' ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_CHECK,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  raw_expr      => $_[3],
                  cooked_expr   => NULL,
               );
               processCASbits($_[5], $_[0]->YYLLoc($_[5], 5), "CHECK", $n, 0,0,0);
               return $n;
            }
         | UNIQUE '(' columnList ')' opt_definition OptConsTableSpace
            ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_UNIQUE,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  keys          => $_[3],
                  options       => $_[5],
                  indexname     => NULL,
                  indexspace    => $_[6],
               );
               processCASbits($_[7], $_[0]->YYLLoc($_[7], 7), "UNIQUE", $n, 1,1,0);
               return $n;
            }
         | UNIQUE ExistingIndex ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_UNIQUE,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  keys          => NIL,
                  options       => NIL,
                  indexname     => $_[2],
                  indexspace    => NULL,
               );
               processCASbits($_[3], $_[0]->YYLLoc($_[3], 3), "UNIQUE", $n, 1,1,0);
               return $n;
            }
         | PRIMARY KEY '(' columnList ')' opt_definition OptConsTableSpace
            ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_PRIMARY,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  keys          => $_[4],
                  options       => $_[6],
                  indexname     => NULL,
                  indexspace    => $_[7],
               );
               processCASbits($_[8], $_[0]->YYLLoc($_[8], 8), "PRIMARY KEY", $n, 1,1,0);
               return $n;
            }
         | PRIMARY KEY ExistingIndex ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_PRIMARY,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  keys          => NIL,
                  options       => NIL,
                  indexname     => $_[3],
                  indexspace    => NULL,
               );
               processCASbits($_[4], $_[0]->YYLLoc($_[4], 4), "PRIMARY KEY", $n, 1,1,0);
               return $n;
            }
         | EXCLUDE access_method_clause '(' ExclusionConstraintList ')'
            opt_definition OptConsTableSpace ExclusionWhereClause
            ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_EXCLUSION,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  access_method => $_[2],
                  exclusions    => $_[4],
                  options       => $_[6],
                  indexname     => NULL,
                  indexspace    => $_[7],
                  where_clause  => $_[8],
               );
               processCASbits($_[9], $_[0]->YYLLoc($_[9], 9), "EXCLUDE", $n, 1,1,0);
               return $n;
            }
         | FOREIGN KEY '(' columnList ')' REFERENCES qualified_name
            opt_column_list key_match key_actions ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::Constraint->new(
                  contype       => CONSTR_FOREIGN,
                  location      => $_[0]->YYLLoc($_[1], 1),
                  pktable       => $_[7],
                  fk_attrs      => $_[4],
                  pk_attrs      => $_[8],
                  fk_matchtype  => $_[9],
                  fk_upd_action => ($_[10] >> 8),
                  fk_del_action => ($_[10] & 0xFF),
               );
               processCASbits($_[11], $_[0]->YYLLoc($_[1], 1), "FOREIGN KEY", $n, 1,1,1);
               $n->_initially_valid( !$n->skip_validation );
               return $n;
            }
      ;

opt_column_list:
         '(' columnList ')'                 { $_[2] }
         | /*EMPTY*/                        { NIL   }
      ;

columnList:
         columnElem                         { lappend($_[1])        }
         | columnList ',' columnElem        { lappend($_[1], $_[3]) }
      ;

columnElem: ColId
            {
               return makeString($_[1]);
            }
      ;

key_match:  MATCH FULL
         {
            return FKCONSTR_MATCH_FULL;
         }
      | MATCH PARTIAL
         {
            return FKCONSTR_MATCH_PARTIAL;
         }
      | MATCH SIMPLE
         {
            return FKCONSTR_MATCH_UNSPECIFIED;
         }
      | /*EMPTY*/
         {
            return FKCONSTR_MATCH_UNSPECIFIED;
         }
      ;

ExclusionConstraintList:
           ExclusionConstraintElem                              { lappend($_[1])        }
         | ExclusionConstraintList ',' ExclusionConstraintElem  { lappend($_[1], $_[3]) }
      ;

ExclusionConstraintElem: index_elem WITH any_operator
         {
            return lappend($_[1], $_[3]);
         }
         /* allow OPERATOR() decoration for the benefit of ruleutils.c */
         | index_elem WITH OPERATOR '(' any_operator ')'
         {
            return lappend($_[1], $_[5]);
         }
      ;

ExclusionWhereClause:
         WHERE '(' a_expr ')'               { $_[3] }
         | /*EMPTY*/                        { NULL  }
      ;

/*
 * We combine the update and delete actions into one value temporarily
 * for simplicity of parsing, and then break them down again in the
 * calling production.  update is in the left 8 bits, delete in the right.
 * Note that NOACTION is the default.
 */
key_actions:
         key_update
            { ($_[1] << 8) | (FKCONSTR_ACTION_NOACTION & 0xFF) }
         | key_delete
            { (FKCONSTR_ACTION_NOACTION << 8) | ($_[1] & 0xFF) }
         | key_update key_delete
            { ($_[1] << 8) | ($_[2] & 0xFF) }
         | key_delete key_update
            { ($_[2] << 8) | ($_[1] & 0xFF) }
         | /*EMPTY*/
            { (FKCONSTR_ACTION_NOACTION << 8) | (FKCONSTR_ACTION_NOACTION & 0xFF) }
      ;

key_update: ON UPDATE key_action      { $_[3] }
      ;

key_delete: ON DELETE key_action      { $_[3] }
      ;

key_action:
         NO ACTION                { FKCONSTR_ACTION_NOACTION   }
         | RESTRICT               { FKCONSTR_ACTION_RESTRICT   }
         | CASCADE                { FKCONSTR_ACTION_CASCADE    }
         | SET NULL               { FKCONSTR_ACTION_SETNULL    }
         | SET DEFAULT            { FKCONSTR_ACTION_SETDEFAULT }
      ;

OptInherit: INHERITS '(' qualified_name_list ')'   { $_[3] }
         | /*EMPTY*/                               { NIL   }
      ;

/* WITH (options) is preferred, WITH OIDS and WITHOUT OIDS are legacy forms */
OptWith:
         WITH reloptions           { $_[2] }
         | WITH OIDS               { lappend(defWithOids(TRUE))  }
         | WITHOUT OIDS            { lappend(defWithOids(FALSE)) }
         | /*EMPTY*/               { NULL  }
      ;

OnCommitOption:  ON COMMIT DROP       { ONCOMMIT_DROP          }
         | ON COMMIT DELETE ROWS      { ONCOMMIT_DELETE_ROWS   }
         | ON COMMIT PRESERVE ROWS    { ONCOMMIT_PRESERVE_ROWS }
         | /*EMPTY*/                  { ONCOMMIT_NOOP          }
      ;

OptTableSpace:   TABLESPACE name            { $_[2] }
         | /*EMPTY*/                        { NULL  }
      ;

OptConsTableSpace:   USING INDEX TABLESPACE name   { $_[4] }
         | /*EMPTY*/                               { NULL  }
      ;

ExistingIndex:   USING INDEX index_name            { $_[3] }
      ;


/*
 * Note: CREATE TABLE ... AS SELECT ... is just another spelling for
 * SELECT ... INTO.
 */

CreateAsStmt:
      CREATE OptTemp TABLE create_as_target AS SelectStmt opt_with_data
               /*
                * When the SelectStmt is a set-operation tree, we must
                * stuff the INTO information into the leftmost component
                * Select, because that's where analyze.c will expect
                * to find it.   Similarly, the output column names must
                * be attached to that Select's target list.
                */
            {
               my $n = findLeftmostSelect($_[6]);
               $n->intoClause
                  and $_[0]->ereport(ERROR,
                        ERRCODE_SYNTAX_ERROR,
                         "CREATE TABLE AS cannot specify INTO",
                         exprLocation( n->intoClause));
               $_[4]->rel->_relpersistence = $_[2];
               $n->intoClause($_[4]);
               #* Implement WITH NO DATA by forcing top-level LIMIT 0
               $_[6]->_limitCount( makeIntConst(0, -1) );
               return $_[6];
            }
      ;

create_as_target:
         qualified_name OptCreateAs OptWith OnCommitOption OptTableSpace
            {
               return SQL::Translator::Statement::IntoClause->new(
                  rel            => $_[1],
                  colNames       => $_[2],
                  options        => $_[3],
                  onCommit       => $_[4],
                  tableSpaceName => $_[5],
               );
            }
      ;

OptCreateAs:
         '(' CreateAsList ')'               { $_[2] }
         | /*EMPTY*/                        { NULL }
      ;

CreateAsList:
         CreateAsElement                         { lappend($_[1]) }
         | CreateAsList ',' CreateAsElement      { lappend($_[1], $_[3]) }
      ;

CreateAsElement:
         ColId
            {
               return SQL::Translator::Statement::Column::Definition->new(
                  colname        => $_[1],
                  typeName       => NULL,
                  inhcount       => 0,
                  is_local       => TRUE,
                  is_not_null    => FALSE,
                  is_from_type   => FALSE,
                  storage        => 0,
                  raw_default    => NULL,
                  cooked_default => NULL,
                  collClause     => NULL,
                  collOid        => InvalidOid,
                  constraints    => NIL,
               );
            }
      ;

opt_with_data:
         WITH DATA                        { TRUE  }
         | WITH NO DATA                   { FALSE }
         | /*EMPTY*/                      { TRUE  }
      ;


/*****************************************************************************
 *
 *      QUERY :
 *            CREATE SEQUENCE seqname
 *            ALTER SEQUENCE seqname
 *
 *****************************************************************************/

CreateSeqStmt:
         CREATE OptTemp SEQUENCE qualified_name OptSeqOptList
            {
               $_[4]->_relpersistence($_[2]);
               return SQL::Translator::Statement::CreateSeq->new(
                  sequence => $_[4],
                  options  => $_[5],
                  ownerId  => InvalidOid,
               );
            }
      ;

AlterSeqStmt:
         ALTER SEQUENCE qualified_name SeqOptList
            {
               return SQL::Translator::Statement::AlterSeq->new(
                  sequence => $_[3],
                  options  => $_[4],
               );
            }
      ;

OptSeqOptList: SeqOptList                   { $_[1] }
         | /*EMPTY*/                        { NULL }
      ;

SeqOptList: 
           SeqOptElem                         { lappend($_[1]) }
         | SeqOptList SeqOptElem              { lappend($_[1], $_[2]) }
      ;

SeqOptElem: 
           CACHE NumericOnly             { makeDefElem("cache",     $_[2]);              }
         | CYCLE                         { makeDefElem("cycle",     makeInteger(TRUE));  }
         | NO CYCLE                      { makeDefElem("cycle",     makeInteger(FALSE)); }
         | INCREMENT opt_by NumericOnly  { makeDefElem("increment", $_[3]);              }
         | MAXVALUE NumericOnly          { makeDefElem("maxvalue",  $_[2]);              }
         | MINVALUE NumericOnly          { makeDefElem("minvalue",  $_[2]);              }
         | NO MAXVALUE                   { makeDefElem("maxvalue",  NULL);               }
         | NO MINVALUE                   { makeDefElem("minvalue",  NULL);               }
         | OWNED BY any_name             { makeDefElem("owned_by",  $_[3]);              }
         | START opt_with NumericOnly    { makeDefElem("start",     $_[3]);              }
         | RESTART                       { makeDefElem("restart",   NULL);               }
         | RESTART opt_with NumericOnly  { makeDefElem("restart",   $_[3]);              }
      ;

opt_by:      BY          {}
         | /* empty */   {}
     ;

NumericOnly:
         FCONST                          { makeFloat($_[1])   }
         | '-' FCONST                    { makeFloat(-$_[2]); }
         | SignedIconst                  { makeInteger($_[1]) }
      ;

NumericOnly_list:   NumericOnly                  { lappend($_[1]) }
            | NumericOnly_list ',' NumericOnly   { lappend($_[1], $_[3]) }
      ;

/*****************************************************************************
 *
 *      QUERIES :
 *            CREATE [OR REPLACE] [TRUSTED] [PROCEDURAL] LANGUAGE ...
 *            DROP [PROCEDURAL] LANGUAGE ...
 *
 *****************************************************************************/

CreatePLangStmt:
         CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst
         {
            return SQL::Translator::Statement::CreatePLang->new(
               replace     => $_[2],
               plname      => $_[6],
               #* parameters are all to be supplied by system
               plhandler   => NIL,
               plinline    => NIL,
               plvalidator => NIL,
               pltrusted   => FALSE,
            );
         }
         | CREATE opt_or_replace opt_trusted opt_procedural LANGUAGE ColId_or_Sconst
           HANDLER handler_name opt_inline_handler opt_validator
         {
            return SQL::Translator::Statement::CreatePLang->new(
               replace     => $_[2],
               plname      => $_[6],
               plhandler   => $_[8],
               plinline    => $_[9],
               plvalidator => $_[10],
               pltrusted   => $_[3],
            );
         }
      ;

opt_trusted:
         TRUSTED                           { TRUE  }
         | /*EMPTY*/                       { FALSE }
      ;

/* This ought to be just func_name, but that causes reduce/reduce conflicts
 * (CREATE LANGUAGE is the only place where func_name isn't followed by '(').
 * Work around by using simple names, instead.
 */
handler_name:
         name                    { lappend(makeString($_[1]))      }
         | name attrs            { lcons(makeString($_[1]), $_[2]) }
      ;

opt_inline_handler:
         INLINE handler_name                { $_[2] }
         | /*EMPTY*/                        { NIL   }
      ;

validator_clause:
         VALIDATOR handler_name             { $_[2] }
         | NO VALIDATOR                     { NIL   }
      ;

opt_validator:
         validator_clause                   { $_[1] }
         | /*EMPTY*/                        { NIL   }
      ;

DropPLangStmt:
         DROP opt_procedural LANGUAGE ColId_or_Sconst opt_drop_behavior
            {
               return SQL::Translator::Statement::DropPLang->new(
                  plname     => $_[4],
                  behavior   => $_[5],
                  missing_ok => FALSE,
               );
            }
         | DROP opt_procedural LANGUAGE IF EXISTS ColId_or_Sconst opt_drop_behavior
            {
               return SQL::Translator::Statement::DropPLang->new(
                  plname     => $_[6],
                  behavior   => $_[7],
                  missing_ok => TRUE,
               );
            }
      ;

opt_procedural:
         PROCEDURAL                        {}
         | /*EMPTY*/                       {}
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             CREATE TABLESPACE tablespace LOCATION '/path/to/tablespace/''
 *
 *****************************************************************************/

CreateTableSpaceStmt: CREATE TABLESPACE name OptTableSpaceOwner LOCATION Sconst
            {
               return SQL::Translator::Statement::CreateTableSpace->new(
                  tablespacename => $_[3],
                  owner          => $_[4],
                  location       => $_[6],
               );
            }
      ;

OptTableSpaceOwner: OWNER name         { $_[2] }
         | /*EMPTY */                  { NULL  }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            DROP TABLESPACE <tablespace>
 *
 *      No need for drop behaviour as we cannot implement dependencies for
 *      objects in other databases; we can only support RESTRICT.
 *
 ****************************************************************************/

DropTableSpaceStmt: DROP TABLESPACE name
            {
               return SQL::Translator::Statement::DropTableSpace->new(
                  tablespacename => $_[3],
                  missing_ok     => FALSE,
               );
            }
            |  DROP TABLESPACE IF EXISTS name
            {
               return SQL::Translator::Statement::DropTableSpace->new(
                  tablespacename => $_[5],
                  missing_ok     => TRUE,
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             CREATE EXTENSION extension
 *             [ WITH ] [ SCHEMA schema ] [ VERSION version ] [ FROM oldversion ]
 *
 *****************************************************************************/

CreateExtensionStmt: CREATE EXTENSION name opt_with create_extension_opt_list
            {
               return SQL::Translator::Statement::CreateExtension->new(
                  extname       => $_[3],
                  if_not_exists => FALSE,
                  options       => $_[5],
               );
            }
            | CREATE EXTENSION IF NOT EXISTS name opt_with create_extension_opt_list
            {
               return SQL::Translator::Statement::CreateExtension->new(
                  extname       => $_[6],
                  if_not_exists => TRUE,
                  options       => $_[8],
               );
            }
      ;

create_extension_opt_list:
         create_extension_opt_list create_extension_opt_item
            { lappend($_[1], $_[2]) }
         | /* EMPTY */
            { NIL }
      ;

create_extension_opt_item:
         SCHEMA name
            {
               return makeDefElem("schema", makeString($_[2]));
            }
         | VERSION ColId_or_Sconst
            {
               return makeDefElem("new_version", makeString($_[2]));
            }
         | FROM ColId_or_Sconst
            {
               return makeDefElem("old_version", makeString($_[2]));
            }
      ;

/*****************************************************************************
 *
 * ALTER EXTENSION name UPDATE [ TO version ]
 *
 *****************************************************************************/

AlterExtensionStmt: ALTER EXTENSION name UPDATE alter_extension_opt_list
            {
               return SQL::Translator::Statement::AlterExtension->new(
                  extname => $_[3],
                  options => $_[5],
               );
            }
      ;

alter_extension_opt_list:
         alter_extension_opt_list alter_extension_opt_item
            { lappend($_[1], $_[2]) }
         | /* EMPTY */
            { NIL }
      ;

alter_extension_opt_item:
         TO ColId_or_Sconst
            {
               return makeDefElem("new_version", makeString($_[2]));
            }
      ;

/*****************************************************************************
 *
 * ALTER EXTENSION name ADD/DROP object-identifier
 *
 *****************************************************************************/

AlterExtensionContentsStmt:
         ALTER EXTENSION name add_drop AGGREGATE func_name aggr_args
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_AGGREGATE,
                  objname => $_[6],
                  objargs => $_[7],
               );
            }
         | ALTER EXTENSION name add_drop CAST '(' Typename AS Typename ')'
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_CAST,
                  objname => lappend($_[7]),
                  objargs => lappend($_[9]),
               );
            }
         | ALTER EXTENSION name add_drop COLLATION any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_COLLATION,
                  objname => $_[6],
               );
            }
         | ALTER EXTENSION name add_drop CONVERSION any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_CONVERSION,
                  objname => $_[6],
               );
            }
         | ALTER EXTENSION name add_drop DOMAIN any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_DOMAIN,
                  objname => $_[6],
               );
            }
         | ALTER EXTENSION name add_drop FUNCTION function_with_argtypes
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_FUNCTION,
                  objname => $_[6]->funcname,
                  objargs => $_[6]->funcargs,
               );
            }
         | ALTER EXTENSION name add_drop opt_procedural LANGUAGE name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_LANGUAGE,
                  objname => lappend(makeString($_[7])),
               );
            }
         | ALTER EXTENSION name add_drop OPERATOR any_operator oper_argtypes
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_OPERATOR,
                  objname => $_[6],
                  objargs => $_[7],
               );
            }
         | ALTER EXTENSION name add_drop OPERATOR CLASS any_name USING access_method
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_OPCLASS,
                  objname => $_[7],
                  objargs => lappend(makeString($_[9])),
               );
            }
         | ALTER EXTENSION name add_drop OPERATOR FAMILY any_name USING access_method
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_OPFAMILY,
                  objname => $_[7],
                  objargs => lappend(makeString($_[9])),
               );
            }
         | ALTER EXTENSION name add_drop SCHEMA name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_SCHEMA,
                  objname => lappend(makeString($_[6])),
               );
            }
         | ALTER EXTENSION name add_drop TABLE any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_TABLE,
                  objname => $_[6],
               );
            }
         | ALTER EXTENSION name add_drop TEXT SEARCH PARSER any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_TSPARSER,
                  objname => $_[8],
               );
            }
         | ALTER EXTENSION name add_drop TEXT SEARCH DICTIONARY any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_TSDICTIONARY,
                  objname => $_[8],
               );
            }
         | ALTER EXTENSION name add_drop TEXT SEARCH TEMPLATE any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_TSTEMPLATE,
                  objname => $_[8],
               );
            }
         | ALTER EXTENSION name add_drop TEXT SEARCH CONFIGURATION any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_TSCONFIGURATION,
                  objname => $_[8],
               );
            }
         | ALTER EXTENSION name add_drop SEQUENCE any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_SEQUENCE,
                  objname => $_[6],
               );
            }
         | ALTER EXTENSION name add_drop VIEW any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_VIEW,
                  objname => $_[6],
               );
            }
         | ALTER EXTENSION name add_drop FOREIGN TABLE any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_FOREIGN_TABLE,
                  objname => $_[7],
               );
            }
         | ALTER EXTENSION name add_drop FOREIGN DATA WRAPPER name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_FDW,
                  objname => lappend(makeString($_[8])),
               );
            }
         | ALTER EXTENSION name add_drop SERVER name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_FOREIGN_SERVER,
                  objname => lappend(makeString($_[6])),
               );
            }
         | ALTER EXTENSION name add_drop TYPE any_name
            {
               return SQL::Translator::Statement::AlterExtensionContents->new(
                  extname => $_[3],
                  action  => $_[4],
                  objtype => OBJECT_TYPE,
                  objname => $_[6],
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             CREATE FOREIGN DATA WRAPPER name options
 *
 *****************************************************************************/

CreateFdwStmt: CREATE FOREIGN DATA WRAPPER name opt_fdw_options create_generic_options
            {
               return SQL::Translator::Statement::CreateFdw->new(
                  fdwname      => $_[5],
                  func_options => $_[6],
                  options      => $_[7],
               );
            }
      ;

fdw_option:
           HANDLER handler_name        { makeDefElem("handler",   $_[2]) }
         | NO HANDLER                  { makeDefElem("handler",   NULL)  }
         | VALIDATOR handler_name      { makeDefElem("validator", $_[2]) }
         | NO VALIDATOR                { makeDefElem("validator", NULL)  }
      ;

fdw_options:
         fdw_option                    { lappend($_[1])        }
         | fdw_options fdw_option      { lappend($_[1], $_[2]) }
      ;

opt_fdw_options:
         fdw_options                   { $_[1] }
         | /*EMPTY*/                   { NIL   }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            DROP FOREIGN DATA WRAPPER name
 *
 ****************************************************************************/

DropFdwStmt: DROP FOREIGN DATA WRAPPER name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropFdw->new(
                  fdwname    => $_[5],
                  missing_ok => FALSE,
                  behavior   => $_[6],
               );
            }
            |  DROP FOREIGN DATA WRAPPER IF EXISTS name opt_drop_behavior
                {
               return SQL::Translator::Statement::DropFdw->new(
                  fdwname    => $_[7],
                  missing_ok => TRUE,
                  behavior   => $_[8],
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            ALTER FOREIGN DATA WRAPPER name options
 *
 ****************************************************************************/

AlterFdwStmt: ALTER FOREIGN DATA WRAPPER name opt_fdw_options alter_generic_options
            {
               return SQL::Translator::Statement::AlterFdw->new(
                  fdwname      => $_[5],
                  func_options => $_[6],
                  options      => $_[7],
               );
            }
         | ALTER FOREIGN DATA WRAPPER name fdw_options
            {
               return SQL::Translator::Statement::AlterFdw->new(
                  fdwname      => $_[5],
                  func_options => $_[6],
                  options      => NIL,
               );
            }
      ;

/* Options definition for CREATE FDW, SERVER and USER MAPPING */
create_generic_options:
         OPTIONS '(' generic_option_list ')'   { $_[3] }
         | /*EMPTY*/                           { NULL  }
      ;

generic_option_list:
         generic_option_elem
            {
               return lappend($_[1]);
            }
         | generic_option_list ',' generic_option_elem
            {
               return lappend($_[1], $_[3]);
            }
      ;

/* Options definition for ALTER FDW, SERVER and USER MAPPING */
alter_generic_options:
         OPTIONS   '(' alter_generic_option_list ')'      { $_[3] }
      ;

alter_generic_option_list:
         alter_generic_option_elem
            {
               return lappend($_[1]);
            }
         | alter_generic_option_list ',' alter_generic_option_elem
            {
               return lappend($_[1], $_[3]);
            }
      ;

alter_generic_option_elem:
         generic_option_elem
            {
               return $_[1];
            }
         | SET generic_option_elem
            {
               $_[2]->_defaction(DEFELEM_SET);
               return $_[2];
            }
         | ADD generic_option_elem
            {
               $_[2]->_defaction(DEFELEM_ADD);
               return $_[2];
            }
         | DROP generic_option_name
            {
               return makeDefElemExtended(NULL, $_[2], NULL, DEFELEM_DROP);
            }
      ;

generic_option_elem:
         generic_option_name generic_option_arg
            {
               return makeDefElem($_[1], $_[2]);
            }
      ;

generic_option_name:
            ColLabel         { $_[1] }
      ;

/* We could use def_arg here, but the spec only requires string literals */
generic_option_arg:
            Sconst           { makeString($_[1]) }
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             CREATE SERVER name [TYPE] [VERSION] [OPTIONS]
 *
 *****************************************************************************/

CreateForeignServerStmt: CREATE SERVER name opt_type opt_foreign_server_version
                   FOREIGN DATA WRAPPER name create_generic_options
            {
               return SQL::Translator::Statement::CreateForeignServer->new(
                  servername => $_[3],
                  servertype => $_[4],
                  version    => $_[5],
                  fdwname    => $_[9],
                  options    => $_[10],
               );
            }
      ;

opt_type:
         TYPE Sconst            { $_[2] }
         | /*EMPTY*/            { NULL  }
      ;


foreign_server_version:
         VERSION Sconst         { $_[2] }
      |   VERSION NULL          { NULL  }
      ;

opt_foreign_server_version:
         foreign_server_version { $_[1] }
         | /*EMPTY*/            { NULL  }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            DROP SERVER name
 *
 ****************************************************************************/

DropForeignServerStmt: DROP SERVER name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropForeignServer->new(
                  servername => $_[3],
                  missing_ok => FALSE,
                  behavior   => $_[4],
               );
            }
            |  DROP SERVER IF EXISTS name opt_drop_behavior
                {
               return SQL::Translator::Statement::DropForeignServer->new(
                  servername => $_[5],
                  missing_ok => TRUE,
                  behavior   => $_[6],
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            ALTER SERVER name [VERSION] [OPTIONS]
 *
 ****************************************************************************/

AlterForeignServerStmt: ALTER SERVER name foreign_server_version alter_generic_options
            {
               return SQL::Translator::Statement::AlterForeignServer->new(
                  servername  => $_[3],
                  version     => $_[4],
                  options     => $_[5],
                  has_version => TRUE,
               );
            }
         | ALTER SERVER name foreign_server_version
            {
               return SQL::Translator::Statement::AlterForeignServer->new(
                  servername  => $_[3],
                  version     => $_[4],
                  has_version => TRUE,
               );
            }
         | ALTER SERVER name alter_generic_options
            {
               return SQL::Translator::Statement::AlterForeignServer->new(
                  servername => $_[3],
                  options    => $_[4],
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             CREATE FOREIGN TABLE relname (...) SERVER name (...)
 *
 *****************************************************************************/

CreateForeignTableStmt:
      CREATE FOREIGN TABLE qualified_name
         OptForeignTableElementList
         SERVER name create_generic_options
            {
               $_[4]->_relpersistence(RELPERSISTENCE_PERMANENT);
               return SQL::Translator::Statement::CreateForeignTable->new(
                  base_relation      => $_[4],
                  base_tableElts     => $_[5],
                  base_inhRelations  => NIL,
                  base_if_not_exists => FALSE,
                  #* FDW-specific data
                  servername         => $_[7],
                  options            => $_[8],
               );
            }
      | CREATE FOREIGN TABLE IF NOT EXISTS qualified_name
         OptForeignTableElementList
         SERVER name create_generic_options
            {
               $_[7]->_relpersistence(RELPERSISTENCE_PERMANENT);
               return SQL::Translator::Statement::CreateForeignTable->new(
                  base_relation      => $_[7],
                  base_tableElts     => $_[8],
                  base_inhRelations  => NIL,
                  base_if_not_exists => TRUE,
                  #* FDW-specific data
                  servername         => $_[10],
                  options            => $_[11],
               );
            }
      ;

OptForeignTableElementList:
         '(' ForeignTableElementList ')'  { $_[2] }
         | '(' ')'                        { NIL   }
      ;

ForeignTableElementList:
         ForeignTableElement
            {
               return lappend($_[1]);
            }
         | ForeignTableElementList ',' ForeignTableElement
            {
               return lappend($_[1], $_[3]);
            }
      ;

ForeignTableElement:
         columnDef               { $_[1] }
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             ALTER FOREIGN TABLE relname [...]
 *
 *****************************************************************************/

AlterForeignTableStmt:
         ALTER FOREIGN TABLE relation_expr alter_table_cmds
            {
               return SQL::Translator::Statement::AlterTable->new(
                  relation => $_[4],
                  cmds     => $_[5],
                  relkind  => OBJECT_FOREIGN_TABLE,
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY:
 *             CREATE USER MAPPING FOR auth_ident SERVER name [OPTIONS]
 *
 *****************************************************************************/

CreateUserMappingStmt: CREATE USER MAPPING FOR auth_ident SERVER name create_generic_options
            {
               return SQL::Translator::Statement::CreateUserMapping->new(
                  username   => $_[5],
                  servername => $_[7],
                  options    => $_[8],
               );
            }
      ;

/* User mapping authorization identifier */
auth_ident:
         CURRENT_USER     { "current_user" }
      |   USER            { "current_user" }
      |   RoleId          { ($_[1] eq "public") ? NULL : $_[1] }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            DROP USER MAPPING FOR auth_ident SERVER name
 *
 ****************************************************************************/

DropUserMappingStmt: DROP USER MAPPING FOR auth_ident SERVER name
            {
               return SQL::Translator::Statement::DropUserMapping->new(
                  username   => $_[5],
                  servername => $_[7],
                  missing_ok => FALSE,
               );
            }
            |  DROP USER MAPPING IF EXISTS FOR auth_ident SERVER name
                {
               return SQL::Translator::Statement::DropUserMapping->new(
                  username   => $_[7],
                  servername => $_[9],
                  missing_ok => TRUE,
               );
            }
      ;

/*****************************************************************************
 *
 *       QUERY :
 *            ALTER USER MAPPING FOR auth_ident SERVER name OPTIONS
 *
 ****************************************************************************/

AlterUserMappingStmt: ALTER USER MAPPING FOR auth_ident SERVER name alter_generic_options
            {
               return SQL::Translator::Statement::AlterUserMapping->new(
                  username   => $_[5],
                  servername => $_[7],
                  options    => $_[8],
               );
            }
      ;

/*****************************************************************************
 *
 *      QUERIES :
 *            CREATE TRIGGER ...
 *            DROP TRIGGER ...
 *
 *****************************************************************************/

CreateTrigStmt:
         CREATE TRIGGER name TriggerActionTime TriggerEvents ON
         qualified_name TriggerForSpec TriggerWhen
         EXECUTE PROCEDURE func_name '(' TriggerFuncArgs ')'
            {
               return SQL::Translator::Statement::CreateTrig->new(
                  trigname      => $_[3],
                  relation      => $_[7],
                  funcname      => $_[12],
                  args          => $_[14],
                  row           => $_[8],
                  timing        => $_[4],
                  events        => intVal(linitial($_[5])),
                  columns       => lsecond($_[5]),
                  whenClause    => $_[9],
                  isconstraint  => FALSE,
                  deferrable    => FALSE,
                  initdeferred  => FALSE,
                  constrrel     => NULL,
               );
            }
         | CREATE CONSTRAINT TRIGGER name AFTER TriggerEvents ON
         qualified_name OptConstrFromTable ConstraintAttributeSpec
         FOR EACH ROW TriggerWhen
         EXECUTE PROCEDURE func_name '(' TriggerFuncArgs ')'
            {
               my $n = SQL::Translator::Statement::CreateTrig->new(
                  trigname      => $_[4],
                  relation      => $_[8],
                  funcname      => $_[17],
                  args          => $_[19],
                  row           => TRUE,
                  timing        => TRIGGER_TYPE_AFTER,
                  events        => intVal(linitial($_[6])),
                  columns       => lsecond($_[6]),
                  whenClause    => $_[14],
                  isconstraint  => TRUE,
                  constrrel     => $_[9],
               );
               processCASbits($_[10], $_[0]->YYLLoc($_[1], 1)0, "TRIGGER", $n, 1,1,0);
               return $n;
            }
      ;

TriggerActionTime:
         BEFORE                        { TRIGGER_TYPE_BEFORE }
         | AFTER                       { TRIGGER_TYPE_AFTER }
         | INSTEAD OF                  { TRIGGER_TYPE_INSTEAD }
      ;

TriggerEvents:
         TriggerOneEvent
            { $_[1] }
         | TriggerEvents OR TriggerOneEvent
            {
               my $events1 = $_[1]->[0];
               my $events2 = $_[3]->[0];
               my @columns1 = @{$_[1]->[1]};
               my @columns2 = @{$_[3]->[1]};

               $_[0]->YYError("duplicate trigger events specified")
                  if ($events1 & $events2);
               /*
                * concat'ing the columns lists loses information about
                * which columns went with which event, but so long as
                * only UPDATE carries columns and we disallow multiple
                * UPDATE items, it doesn't matter.  Command execution
                * should just ignore the columns for non-UPDATE events.
                */
               return lappend(makeInteger($events1 | $events2), lappend($columns1, $columns2));
            }
      ;

TriggerOneEvent:
           INSERT                { lappend(makeInteger(TRIGGER_TYPE_INSERT),   NIL)   }
         | DELETE                { lappend(makeInteger(TRIGGER_TYPE_DELETE),   NIL)   }
         | UPDATE                { lappend(makeInteger(TRIGGER_TYPE_UPDATE),   NIL)   }
         | UPDATE OF columnList  { lappend(makeInteger(TRIGGER_TYPE_UPDATE),   $_[3]) }
         | TRUNCATE              { lappend(makeInteger(TRIGGER_TYPE_TRUNCATE), NIL)   }
      ;

TriggerForSpec:
         FOR TriggerForOptEach TriggerForType
            { $_[3] }
         | /* EMPTY */
           /*
            * If ROW/STATEMENT not specified, default to
            * STATEMENT, per SQL
            */
            { FALSE }
      ;

TriggerForOptEach:
         EACH                                  {}
         | /*EMPTY*/                           {}
      ;

TriggerForType:
         ROW                                   { TRUE  }
         | STATEMENT                           { FALSE }
      ;

TriggerWhen:
         WHEN '(' a_expr ')'                   { $_[3] }
         | /*EMPTY*/                           { NULL  }
      ;

TriggerFuncArgs:
         TriggerFuncArg                        { lappend($_[1])        }
         | TriggerFuncArgs ',' TriggerFuncArg  { lappend($_[1], $_[3]) }
         | /*EMPTY*/                           { NULL                  }
      ;

TriggerFuncArg:
         Iconst                                { makeString($_[1]) }
         | FCONST                              { makeString($_[1]) }
         | Sconst                              { makeString($_[1]) }
         | ColLabel                            { makeString($_[1]) }
      ;

OptConstrFromTable:
         FROM qualified_name                   { $_[2] }
         | /*EMPTY*/                           { NIL   }
      ;

ConstraintAttributeSpec:
         /*EMPTY*/
            { 0 }
         | ConstraintAttributeSpec ConstraintAttributeElem
            {
               /*
                * We must complain about conflicting options.
                * We could, but choose not to, complain about redundant
                * options (ie, where $_[2]'s bit is already set in $_[1]).
                */
               my $newspec = $_[1] | $_[2];

               /* special message for this case */
               (($newspec & (CAS_NOT_DEFERRABLE | CAS_INITIALLY_DEFERRED)) == (CAS_NOT_DEFERRABLE | CAS_INITIALLY_DEFERRED))
                  and $_[0]->ereport(ERROR,
                        ERRCODE_SYNTAX_ERROR,
                         "constraint declared INITIALLY DEFERRED must be DEFERRABLE",
                         $_[0]->YYLLoc($_[2], 2));
               /* generic message for other conflicts */
               ((newspec & (CAS_NOT_DEFERRABLE | CAS_DEFERRABLE)) == (CAS_NOT_DEFERRABLE | CAS_DEFERRABLE) ||
                  (newspec & (CAS_INITIALLY_IMMEDIATE | CAS_INITIALLY_DEFERRED)) == (CAS_INITIALLY_IMMEDIATE | CAS_INITIALLY_DEFERRED))
                  and $_[0]->ereport(ERROR,
                        ERRCODE_SYNTAX_ERROR,
                         "conflicting constraint properties",
                         $_[0]->YYLLoc($_[2], 2));
               return $newspec;
            }
      ;

ConstraintAttributeElem:
           NOT DEFERRABLE             { CAS_NOT_DEFERRABLE      }
         | DEFERRABLE                 { CAS_DEFERRABLE          }
         | INITIALLY IMMEDIATE        { CAS_INITIALLY_IMMEDIATE }
         | INITIALLY DEFERRED         { CAS_INITIALLY_DEFERRED  }
         | NOT VALID                  { CAS_NOT_VALID           }
      ;


DropTrigStmt:
         DROP TRIGGER name ON qualified_name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropProperty->new(
                  relation   => $_[5],
                  property   => $_[3],
                  behavior   => $_[6],
                  removeType => OBJECT_TRIGGER,
                  missing_ok => FALSE,
               );
            }
         | DROP TRIGGER IF EXISTS name ON qualified_name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropProperty->new(
                  relation   => $_[7],
                  property   => $_[5],
                  behavior   => $_[8],
                  removeType => OBJECT_TRIGGER,
                  missing_ok => TRUE,
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERIES :
 *            CREATE ASSERTION ...
 *            DROP ASSERTION ...
 *
 *****************************************************************************/

CreateAssertStmt:
         CREATE ASSERTION name CHECK '(' a_expr ')'
         ConstraintAttributeSpec
            {
               my $n = SQL::Translator::Statement::CreateTrig->new(
                  trigname     => $_[3],
                  args         => list_make1($_[6]),
                  isconstraint => TRUE,
               );
               processCASbits($_[8], $_[0]->YYLLoc($_[8], 8), "ASSERTION", $n, 1,1,0);
               return $n;
            }
      ;

DropAssertStmt:
         DROP ASSERTION name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropProperty->new(
                  relation   => NULL,
                  property   => $_[3],
                  behavior   => $_[4],
                  removeType => OBJECT_TRIGGER,  #* XXX
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERY :
 *            define (aggregate,operator,type)
 *
 *****************************************************************************/

DefineStmt:
         CREATE AGGREGATE func_name aggr_args definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_AGGREGATE,
                  oldstyle   => FALSE,
                  defnames   => $_[3],
                  args       => $_[4],
                  definition => $_[5],
               );
            }
         | CREATE AGGREGATE func_name old_aggr_definition
            /* old-style (pre-8.2) syntax for CREATE AGGREGATE */
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_AGGREGATE,
                  oldstyle   => TRUE,
                  defnames   => $_[3],
                  args       => NIL,
                  definition => $_[4],
               );
            }
         | CREATE OPERATOR any_operator definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_OPERATOR,
                  oldstyle   => FALSE,
                  defnames   => $_[3],
                  args       => NIL,
                  definition => $_[4],
               );
            }
         | CREATE TYPE any_name definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_TYPE,
                  oldstyle   => FALSE,
                  defnames   => $_[3],
                  args       => NIL,
                  definition => $_[4],
               );
            }
         | CREATE TYPE any_name
            /* Shell type (identified by lack of definition) */
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_TYPE,
                  oldstyle   => FALSE,
                  defnames   => $_[3],
                  args       => NIL,
                  definition => NIL,
               );
            }
         | CREATE TYPE any_name AS '(' OptTableFuncElementList ')'
            {
               return SQL::Translator::Statement::CompositeType->new(
                  #* can't use qualified_name, sigh
                  # TODO: #* typevar => makeRangeVarFromAnyName($_[3], $_[0]->YYLLoc($_[3], 3)),
                  coldeflist => $_[6],
               );
            }
         | CREATE TYPE any_name AS ENUM '(' opt_enum_val_list ')'
            {
               return SQL::Translator::Statement::CreateEnum->new(
                  typeName => $_[3],
                  vals     => $_[7],
               );
            }
         | CREATE TEXT SEARCH PARSER any_name definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_TSPARSER,
                  args       => NIL,
                  defnames   => $_[5],
                  definition => $_[6],
               );
            }
         | CREATE TEXT SEARCH DICTIONARY any_name definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_TSDICTIONARY,
                  args       => NIL,
                  defnames   => $_[5],
                  definition => $_[6],
               );
            }
         | CREATE TEXT SEARCH TEMPLATE any_name definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_TSTEMPLATE,
                  args       => NIL,
                  defnames   => $_[5],
                  definition => $_[6],
               );
            }
         | CREATE TEXT SEARCH CONFIGURATION any_name definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_TSCONFIGURATION,
                  args       => NIL,
                  defnames   => $_[5],
                  definition => $_[6],
               );
            }
         | CREATE COLLATION any_name definition
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_COLLATION,
                  args       => NIL,
                  defnames   => $_[3],
                  definition => $_[4],
               );
            }
         | CREATE COLLATION any_name FROM any_name
            {
               return SQL::Translator::Statement::Define->new(
                  kind       => OBJECT_COLLATION,
                  args       => NIL,
                  defnames   => $_[3],
                  definition => lappend(makeDefElem("from",  $_[5])),
               );
            }
      ;

definition: '(' def_list ')'               { $_[2] }
      ;

def_list:     def_elem                     { lappend($_[1])        }
         | def_list ',' def_elem           { lappend($_[1], $_[3]) }
      ;

def_elem:   ColLabel '=' def_arg           { makeDefElem($_[1],  $_[3]) }
         | ColLabel                        { makeDefElem($_[1], NULL)   }
      ;

/* Note: any simple identifier will be returned as a type name! */
def_arg:   func_type                       { $_[1]             }
         | reserved_keyword                { makeString($_[1]) }
         | qual_all_Op                     { $_[1]             }
         | NumericOnly                     { $_[1]             }
         | Sconst                          { makeString($_[1]) }
      ;

aggr_args: '(' type_list ')'               { $_[2] }
         | '(' '*' ')'                     { NIL   }
      ;

old_aggr_definition: '(' old_aggr_list ')' { $_[2] }
      ;

old_aggr_list: old_aggr_elem               { lappend($_[1])        }
         | old_aggr_list ',' old_aggr_elem { lappend($_[1], $_[3]) }
      ;

/*
 * Must use IDENT here to avoid reduce/reduce conflicts; fortunately none of
 * the item names needed in old aggregate definitions are likely to become
 * SQL keywords.
 */
old_aggr_elem:  IDENT '=' def_arg
            {
               return makeDefElem($_[1], $_[3]);
            }
      ;

opt_enum_val_list:
      enum_val_list                      { $_[1] }
      | /*EMPTY*/                        { NIL   }
      ;

enum_val_list:   Sconst                  { lappend(makeString($_[1]))        }
         | enum_val_list ',' Sconst      { lappend($_[1], makeString($_[3])) }
      ;

/*****************************************************************************
 *
 *   ALTER TYPE enumtype ADD ...
 *
 *****************************************************************************/

AlterEnumStmt:
         ALTER TYPE any_name ADD VALUE Sconst
          {
             return SQL::Translator::Statement::AlterEnum->new(
                typeName       => $_[3],
                newVal         => $_[6],
                newValNeighbor => NULL,
                newValIsAfter  => TRUE,
             );
          }
       | ALTER TYPE any_name ADD VALUE Sconst BEFORE Sconst
          {
             return SQL::Translator::Statement::AlterEnum->new(
                typeName       => $_[3],
                newVal         => $_[6],
                newValNeighbor => $_[8],
                newValIsAfter  => FALSE,
             );
          }
       | ALTER TYPE any_name ADD VALUE Sconst AFTER Sconst
          {
             return SQL::Translator::Statement::AlterEnum->new(
                typeName       => $_[3],
                newVal         => $_[6],
                newValNeighbor => $_[8],
                newValIsAfter  => TRUE,
             );
          }
       ;


/*****************************************************************************
 *
 *      QUERIES :
 *            CREATE OPERATOR CLASS ...
 *            CREATE OPERATOR FAMILY ...
 *            ALTER OPERATOR FAMILY ...
 *            DROP OPERATOR CLASS ...
 *            DROP OPERATOR FAMILY ...
 *
 *****************************************************************************/

CreateOpClassStmt:
         CREATE OPERATOR CLASS any_name opt_default FOR TYPE Typename
         USING access_method opt_opfamily AS opclass_item_list
            {
               return SQL::Translator::Statement::CreateOpClass->new(
                  opclassname  => $_[4],
                  isDefault    => $_[5],
                  datatype     => $_[8],
                  amname       => $_[10],
                  opfamilyname => $_[11],
                  items        => $_[13],
               );
            }
      ;

opclass_item_list:
           opclass_item                         { lappend($_[1])        }
         | opclass_item_list ',' opclass_item   { lappend($_[1], $_[3]) }
      ;

opclass_item:
         OPERATOR Iconst any_operator opclass_purpose opt_recheck
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype     => OPCLASS_ITEM_OPERATOR,
                  name         => $_[3],
                  args         => NIL,
                  number       => $_[2],
                  order_family => $_[4],
               );
            }
         | OPERATOR Iconst any_operator oper_argtypes opclass_purpose
           opt_recheck
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype     => OPCLASS_ITEM_OPERATOR,
                  name         => $_[3],
                  args         => $_[4],
                  number       => $_[2],
                  order_family => $_[5],
               );
            }
         | FUNCTION Iconst func_name func_args
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype     => OPCLASS_ITEM_FUNCTION,
                  name         => $_[3],
                  args         => extractArgTypes($_[4]),
                  number       => $_[2],
               );
            }
         | FUNCTION Iconst '(' type_list ')' func_name func_args
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype     => OPCLASS_ITEM_FUNCTION,
                  name         => $_[6],
                  args         => extractArgTypes($_[7]),
                  number       => $_[2],
                  class_args   => $_[4],
               );
            }
         | STORAGE Typename
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype     => OPCLASS_ITEM_STORAGETYPE,
                  storedtype   => $_[2],
               );
            }
      ;

opt_default:   DEFAULT                  { TRUE  }
         | /*EMPTY*/                    { FALSE }
      ;

opt_opfamily:   FAMILY any_name         { $_[2] }
         | /*EMPTY*/                    { NULL  }
      ;

opclass_purpose: FOR SEARCH             { NULL  }
         | FOR ORDER BY any_name        { $_[4] }
         | /*EMPTY*/                    { NULL  }
      ;

opt_recheck:   RECHECK
            {
               /*
                * RECHECK no longer does anything in opclass definitions,
                * but we still accept it to ease porting of old database
                * dumps.
                */
               return TRUE;
            }
         | /*EMPTY*/                  { FALSE }
      ;


CreateOpFamilyStmt:
         CREATE OPERATOR FAMILY any_name USING access_method
            {
               return SQL::Translator::Statement::CreateOpFamily->new(
                  opfamilyname => $_[4],
                  amname       => $_[6],
               );
            }
      ;

AlterOpFamilyStmt:
         ALTER OPERATOR FAMILY any_name USING access_method ADD opclass_item_list
            {
               return SQL::Translator::Statement::AlterOpFamily->new(
                  opfamilyname => $_[4],
                  amname       => $_[6],
                  isDrop       => FALSE,
                  items        => $_[8],
               );
            }
         | ALTER OPERATOR FAMILY any_name USING access_method DROP opclass_drop_list
            {
               return SQL::Translator::Statement::AlterOpFamily->new(
                  opfamilyname => $_[4],
                  amname       => $_[6],
                  isDrop       => TRUE,
                  items        => $_[8],
               );
            }
      ;

opclass_drop_list:
           opclass_drop                         { lappend($_[1]) }
         | opclass_drop_list ',' opclass_drop   { lappend($_[1], $_[3]) }
      ;

opclass_drop:
         OPERATOR Iconst '(' type_list ')'
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype => OPCLASS_ITEM_OPERATOR,
                  number   => $_[2],
                  args     => $_[4],
               );
            }
         | FUNCTION Iconst '(' type_list ')'
            {
               return SQL::Translator::Statement::CreateOpClass::Item->new(
                  itemtype => OPCLASS_ITEM_FUNCTION,
                  number   => $_[2],
                  args     => $_[4],
               );
            }
      ;


DropOpClassStmt:
         DROP OPERATOR CLASS any_name USING access_method opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveOpClass->new(
                  opclassname  => $_[4],
                  amname       => $_[6],
                  behavior     => $_[7],
                  missing_ok   => FALSE,
               );
            }
         | DROP OPERATOR CLASS IF EXISTS any_name USING access_method opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveOpClass->new(
                  opclassname  => $_[6],
                  amname       => $_[8],
                  behavior     => $_[9],
                  missing_ok   => TRUE,
               );
            }
      ;

DropOpFamilyStmt:
         DROP OPERATOR FAMILY any_name USING access_method opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveOpFamily->new(
                  opfamilyname => $_[4],
                  amname       => $_[6],
                  behavior     => $_[7],
                  missing_ok   => FALSE,
               );
            }
         | DROP OPERATOR FAMILY IF EXISTS any_name USING access_method opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveOpFamily->new(
                  opfamilyname => $_[6],
                  amname       => $_[8],
                  behavior     => $_[9],
                  missing_ok   => TRUE,
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *
 *      DROP OWNED BY username [, username ...] [ RESTRICT | CASCADE ]
 *      REASSIGN OWNED BY username [, username ...] TO username
 *
 *****************************************************************************/
DropOwnedStmt:
         DROP OWNED BY name_list opt_drop_behavior
             {
               return SQL::Translator::Statement::DropOwned->new(
                  roles    => $_[4],
                  behavior => $_[5],
               );
            }
      ;

ReassignOwnedStmt:
         REASSIGN OWNED BY name_list TO name
            {
               return SQL::Translator::Statement::ReassignOwned->new(
                  roles    => $_[4],
                  newrole  => $_[6],
               );
            }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *
 *      DROP itemtype [ IF EXISTS ] itemname [, itemname ...]
 *           [ RESTRICT | CASCADE ]
 *
 *****************************************************************************/

DropStmt:   DROP drop_type IF EXISTS any_name_list opt_drop_behavior
            {
               return SQL::Translator::Statement::Drop->new(
                  removeType => $_[2],
                  missing_ok => TRUE,
                  objects    => $_[5],
                  behavior   => $_[6],
               );
            }
         | DROP drop_type any_name_list opt_drop_behavior
            {
               return SQL::Translator::Statement::Drop->new(
                  removeType => $_[2],
                  missing_ok => FALSE,
                  objects    => $_[3],
                  behavior   => $_[4],
               );
            }
      ;


drop_type:   TABLE                           { OBJECT_TABLE           }
         | SEQUENCE                          { OBJECT_SEQUENCE        }
         | VIEW                              { OBJECT_VIEW            }
         | INDEX                             { OBJECT_INDEX           }
         | FOREIGN TABLE                     { OBJECT_FOREIGN_TABLE   }
         | TYPE                              { OBJECT_TYPE            }
         | DOMAIN                            { OBJECT_DOMAIN          }
         | COLLATION                         { OBJECT_COLLATION       }
         | CONVERSION                        { OBJECT_CONVERSION      }
         | SCHEMA                            { OBJECT_SCHEMA          }
         | EXTENSION                         { OBJECT_EXTENSION       }
         | TEXT SEARCH PARSER                { OBJECT_TSPARSER        }
         | TEXT SEARCH DICTIONARY            { OBJECT_TSDICTIONARY    }
         | TEXT SEARCH TEMPLATE              { OBJECT_TSTEMPLATE      }
         | TEXT SEARCH CONFIGURATION         { OBJECT_TSCONFIGURATION }
      ;

any_name_list:
         any_name                        { lappend($_[1])        }
         | any_name_list ',' any_name    { lappend($_[1], $_[3]) }
      ;

any_name:   ColId                        { lappend(makeString($_[1]))      }
         | ColId attrs                   { lcons(makeString($_[1]), $_[2]) }
      ;

attrs:     '.' attr_name                 { lappend(makeString($_[2]))        }
         | attrs '.' attr_name           { lappend($_[1], makeString($_[3])) }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            truncate table relname1, relname2, ...
 *
 *****************************************************************************/

TruncateStmt:
         TRUNCATE opt_table relation_expr_list opt_restart_seqs opt_drop_behavior
            {
               return SQL::Translator::Statement::Truncate->new(
                  relations    => $_[3],
                  restart_seqs => $_[4],
                  behavior     => $_[5],
               );
            }
      ;

opt_restart_seqs:
         CONTINUE IDENTITY        { FALSE }
         | RESTART IDENTITY       { TRUE  }
         | /* EMPTY */            { FALSE }
      ;

/*****************************************************************************
 *
 *   The COMMENT ON statement can take different forms based upon the type of
 *   the object associated with the comment. The form of the statement is:
 *
 *   COMMENT ON [ [ DATABASE | DOMAIN | INDEX | SEQUENCE | TABLE | TYPE | VIEW |
 *               COLLATION | CONVERSION | LANGUAGE | OPERATOR CLASS |
 *               LARGE OBJECT | CAST | COLUMN | SCHEMA | TABLESPACE |
 *               EXTENSION | ROLE | TEXT SEARCH PARSER |
 *               TEXT SEARCH DICTIONARY | TEXT SEARCH TEMPLATE |
 *               TEXT SEARCH CONFIGURATION | FOREIGN TABLE |
 *               FOREIGN DATA WRAPPER | SERVER ] <objname> |
 *             AGGREGATE <aggname> (arg1, ...) |
 *             FUNCTION <funcname> (arg1, arg2, ...) |
 *             OPERATOR <op> (leftoperand_typ, rightoperand_typ) |
 *             TRIGGER <triggername> ON <relname> |
 *             CONSTRAINT <constraintname> ON <relname> |
 *             RULE <rulename> ON <relname> ]
 *            IS 'text'
 *
 *****************************************************************************/

CommentStmt:
         COMMENT ON comment_type any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => $_[3],
                  objname => $_[4],
                  objargs => NIL,
                  comment => $_[6],
               );
            }
         | COMMENT ON AGGREGATE func_name aggr_args IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_AGGREGATE,
                  objname => $_[4],
                  objargs => $_[5],
                  comment => $_[7],
               );
            }
         | COMMENT ON FUNCTION func_name func_args IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_FUNCTION,
                  objname => $_[4],
                  objargs => extractArgTypes($_[5]),
                  comment => $_[7],
               );
            }
         | COMMENT ON OPERATOR any_operator oper_argtypes IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_OPERATOR,
                  objname => $_[4],
                  objargs => $_[5],
                  comment => $_[7],
               );
            }
         | COMMENT ON CONSTRAINT name ON any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_CONSTRAINT,
                  objname => lappend($_[6], makeString($_[4])),
                  objargs => NIL,
                  comment => $_[8],
               );
            }
         | COMMENT ON RULE name ON any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_RULE,
                  objname => lappend($_[6], makeString($_[4])),
                  objargs => NIL,
                  comment => $_[8],
               );
            }
         | COMMENT ON RULE name IS comment_text
            /* Obsolete syntax supported for awhile for compatibility */
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_RULE,
                  objname => lappend(makeString($_[4])),
                  objargs => NIL,
                  comment => $_[6],
               );
            }
         | COMMENT ON TRIGGER name ON any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_TRIGGER,
                  objname => lappend($_[6], makeString($_[4])),
                  objargs => NIL,
                  comment => $_[8],
               );
            }
         | COMMENT ON OPERATOR CLASS any_name USING access_method IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_OPCLASS,
                  objname => $_[5],
                  objargs => lappend(makeString($_[7])),
                  comment => $_[9],
               );
            }
         | COMMENT ON OPERATOR FAMILY any_name USING access_method IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_OPFAMILY,
                  objname => $_[5],
                  objargs => lappend(makeString($_[7])),
                  comment => $_[9],
               );
            }
         | COMMENT ON LARGE OBJECT NumericOnly IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_LARGEOBJECT,
                  objname => lappend($_[5]),
                  objargs => NIL,
                  comment => $_[7],
               );
            }
         | COMMENT ON CAST '(' Typename AS Typename ')' IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_CAST,
                  objname => lappend($_[5]),
                  objargs => lappend($_[7]),
                  comment => $_[10],
               );
            }
         | COMMENT ON opt_procedural LANGUAGE any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_LANGUAGE,
                  objname => $_[5],
                  objargs => NIL,
                  comment => $_[7],
               );
            }
         | COMMENT ON TEXT SEARCH PARSER any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_TSPARSER,
                  objname => $_[6],
                  comment => $_[8],
               );
            }
         | COMMENT ON TEXT SEARCH DICTIONARY any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_TSDICTIONARY,
                  objname => $_[6],
                  comment => $_[8],
               );
            }
         | COMMENT ON TEXT SEARCH TEMPLATE any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_TSTEMPLATE,
                  objname => $_[6],
                  comment => $_[8],
               );
            }
         | COMMENT ON TEXT SEARCH CONFIGURATION any_name IS comment_text
            {
               return SQL::Translator::Statement::Comment->new(
                  objtype => OBJECT_TSCONFIGURATION,
                  objname => $_[6],
                  comment => $_[8],
               );
            }
      ;

comment_type:
         COLUMN                           { OBJECT_COLUMN         }
         | DATABASE                       { OBJECT_DATABASE       }
         | SCHEMA                         { OBJECT_SCHEMA         }
         | INDEX                          { OBJECT_INDEX          }
         | SEQUENCE                       { OBJECT_SEQUENCE       }
         | TABLE                          { OBJECT_TABLE          }
         | DOMAIN                         { OBJECT_DOMAIN         }
         | TYPE                           { OBJECT_TYPE           }
         | VIEW                           { OBJECT_VIEW           }
         | COLLATION                      { OBJECT_COLLATION      }
         | CONVERSION                     { OBJECT_CONVERSION     }
         | TABLESPACE                     { OBJECT_TABLESPACE     }
         | EXTENSION                      { OBJECT_EXTENSION      }
         | ROLE                           { OBJECT_ROLE           }
         | FOREIGN TABLE                  { OBJECT_FOREIGN_TABLE  }
         | SERVER                         { OBJECT_FOREIGN_SERVER }
         | FOREIGN DATA WRAPPER           { OBJECT_FDW            }
      ;

comment_text:
         Sconst                        { $_[1] }
         | NULL                     { NULL }
      ;


/*****************************************************************************
 *
 *  SECURITY LABEL [FOR <provider>] ON <object> IS <label>
 *
 *  As with COMMENT ON, <object> can refer to various types of database
 *  objects (e.g. TABLE, COLUMN, etc.).
 *
 *****************************************************************************/

SecLabelStmt:
         SECURITY LABEL opt_provider ON security_label_type any_name
         IS security_label
            {
               return SQL::Translator::Statement::SecLabel->new(
                  provider => $_[3],
                  objtype  => $_[5],
                  objname  => $_[6],
                  objargs  => NIL,
                  label    => $_[8],
               );
            }
         | SECURITY LABEL opt_provider ON AGGREGATE func_name aggr_args
           IS security_label
            {
               return SQL::Translator::Statement::SecLabel->new(
                  provider => $_[3],
                  objtype  => OBJECT_AGGREGATE,
                  objname  => $_[6],
                  objargs  => $_[7],
                  label    => $_[9],
               );
            }
         | SECURITY LABEL opt_provider ON FUNCTION func_name func_args
           IS security_label
            {
               return SQL::Translator::Statement::SecLabel->new(
                  provider => $_[3],
                  objtype  => OBJECT_FUNCTION,
                  objname  => $_[6],
                  objargs  => extractArgTypes($_[7]),
                  label    => $_[9],
               );
            }
         | SECURITY LABEL opt_provider ON LARGE OBJECT NumericOnly
           IS security_label
            {
               return SQL::Translator::Statement::SecLabel->new(
                  provider => $_[3],
                  objtype  => OBJECT_LARGEOBJECT,
                  objname  => lappend($_[7]),
                  objargs  => NIL,
                  label    => $_[9],
               );
            }
         | SECURITY LABEL opt_provider ON opt_procedural LANGUAGE any_name
           IS security_label
            {
               return SQL::Translator::Statement::SecLabel->new(
                  provider => $_[3],
                  objtype  => OBJECT_LANGUAGE,
                  objname  => $_[7],
                  objargs  => NIL,
                  label    => $_[9],
               );
            }
      ;

opt_provider:   FOR ColId_or_Sconst   { $_[2] }
            | /* empty */      { NULL }
      ;

security_label_type:
         COLUMN                         { OBJECT_COLUMN        }
         | FOREIGN TABLE                { OBJECT_FOREIGN_TABLE }
         | SCHEMA                       { OBJECT_SCHEMA        }
         | SEQUENCE                     { OBJECT_SEQUENCE      }
         | TABLE                        { OBJECT_TABLE         }
         | DOMAIN                       { OBJECT_TYPE          }
         | TYPE                         { OBJECT_TYPE          }
         | VIEW                         { OBJECT_VIEW          }
      ;

security_label:   Sconst            { $_[1] }
            | NULL         { NULL }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *         fetch/move
 *
 *****************************************************************************/

FetchStmt:   FETCH fetch_args
            {
               $_[2]->_ismove(FALSE);
               return $_[2];
            }
         | MOVE fetch_args
            {
               $_[2]->_ismove(TRUE);
               return $_[2];
            }
      ;

fetch_args:   cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[1],
                  direction  => FETCH_FORWARD,
                  howMany    => 1,
               );
            }
         | from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[2],
                  direction  => FETCH_FORWARD,
                  howMany    => 1,
               );
            }
         | NEXT opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_FORWARD,
                  howMany    => 1,
               );
            }
         | PRIOR opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_BACKWARD,
                  howMany    => 1,
               );
            }
         | FIRST opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_ABSOLUTE,
                  howMany    => 1,
               );
            }
         | LAST opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_ABSOLUTE,
                  howMany    => -1,
               );
            }
         | ABSOLUTE SignedIconst opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[4],
                  direction  => FETCH_ABSOLUTE,
                  howMany    => $_[2],
               );
            }
         | RELATIVE SignedIconst opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[4],
                  direction  => FETCH_RELATIVE,
                  howMany    => $_[2],
               );
            }
         | SignedIconst opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_FORWARD,
                  howMany    => $_[1],
               );
            }
         | ALL opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_FORWARD,
                  howMany    => FETCH_ALL,
               );
            }
         | FORWARD opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_FORWARD,
                  howMany    => 1,
               );
            }
         | FORWARD SignedIconst opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[4],
                  direction  => FETCH_FORWARD,
                  howMany    => $_[2],
               );
            }
         | FORWARD ALL opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[4],
                  direction  => FETCH_FORWARD,
                  howMany    => FETCH_ALL,
               );
            }
         | BACKWARD opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[3],
                  direction  => FETCH_BACKWARD,
                  howMany    => 1,
               );
            }
         | BACKWARD SignedIconst opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[4],
                  direction  => FETCH_BACKWARD,
                  howMany    => $_[2],
               );
            }
         | BACKWARD ALL opt_from_in cursor_name
            {
               return SQL::Translator::Statement::Fetch->new(
                  portalname => $_[4],
                  direction  => FETCH_BACKWARD,
                  howMany    => FETCH_ALL,
               );
            }
      ;

from_in:   FROM                           {}
         | IN                             {}
      ;

opt_from_in:   from_in                    {}
         | /* EMPTY */                    {}
      ;


/*****************************************************************************
 *
 * GRANT and REVOKE statements
 *
 *****************************************************************************/

GrantStmt:   GRANT privileges ON privilege_target TO grantee_list
         opt_grant_grant_option
            {
               return SQL::Translator::Statement::Grant->new(
                  is_grant     => TRUE,
                  privileges   => $_[2],
                  targtype     => $_[4]->targtype,
                  objtype      => $_[4]->objtype,
                  objects      => $_[4]->objs,
                  grantees     => $_[6],
                  grant_option => $_[7],
               );
            }
      ;

RevokeStmt:
         REVOKE privileges ON privilege_target
         FROM grantee_list opt_drop_behavior
            {
               return SQL::Translator::Statement::Grant->new(
                  is_grant     => FALSE,
                  grant_option => FALSE,
                  privileges   => $_[2],
                  targtype     => $_[4]->targtype,
                  objtype      => $_[4]->objtype,
                  objects      => $_[4]->objs,
                  grantees     => $_[6],
                  behavior     => $_[7],
               );
            }
         | REVOKE GRANT OPTION FOR privileges ON privilege_target
         FROM grantee_list opt_drop_behavior
            {
               return SQL::Translator::Statement::Grant->new(
                  is_grant     => FALSE,
                  grant_option => TRUE,
                  privileges   => $_[5],
                  targtype     => $_[7]->targtype,
                  objtype      => $_[7]->objtype,
                  objects      => $_[7]->objs,
                  grantees     => $_[9],
                  behavior     => $_[10],
               );
            }
      ;


/*
 * Privilege names are represented as strings; the validity of the privilege
 * names gets checked at execution.  This is a bit annoying but we have little
 * choice because of the syntactic conflict with lists of role names in
 * GRANT/REVOKE.  What's more, we have to call out in the "privilege"
 * production any reserved keywords that need to be usable as privilege names.
 */

/* either ALL [PRIVILEGES] or a list of individual privileges */
privileges: privilege_list            { $_[1] }
         | ALL                        { NULL }
         | ALL PRIVILEGES             { NULL }
         | ALL '(' columnList ')'
            {
               return [ SQL::Translator::Statement::AccessPriv->new(
                  priv_name => NULL,
                  cols      => $_[3],
               ) ];
            }
         | ALL PRIVILEGES '(' columnList ')'
            {
               return [ SQL::Translator::Statement::AccessPriv->new(
                  priv_name => NULL,
                  cols      => $_[4],
               ) ];
            }
      ;

privilege_list:   privilege                     { lappend($_[1]) }
         | privilege_list ',' privilege         { lappend($_[1], $_[3]) }
      ;

privilege:   SELECT opt_column_list
         {
            return SQL::Translator::Statement::AccessPriv->new(
               priv_name => $_[1],
               cols      => $_[2],
            );
         }
      | REFERENCES opt_column_list
         {
            return SQL::Translator::Statement::AccessPriv->new(
               priv_name => $_[1],
               cols      => $_[2],
            );
         }
      | CREATE opt_column_list
         {
            return SQL::Translator::Statement::AccessPriv->new(
               priv_name => $_[1],
               cols      => $_[2],
            );
         }
      | ColId opt_column_list
         {
            return SQL::Translator::Statement::AccessPriv->new(
               priv_name => $_[1],
               cols      => $_[2],
            );
         }
      ;


/* Don't bother trying to fold the first two rules into one using
 * opt_table.  You're going to get conflicts.
 */
privilege_target:
         qualified_name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_RELATION,
                  objs => $_[1],
               );
            }
         | TABLE qualified_name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_RELATION,
                  objs => $_[2],
               );
            }
         | SEQUENCE qualified_name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_SEQUENCE,
                  objs => $_[2],
               );
            }
         | FOREIGN DATA WRAPPER name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_FDW,
                  objs => $_[4],
               );
            }
         | FOREIGN SERVER name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_FOREIGN_SERVER,
                  objs => $_[3],
               );
            }
         | FUNCTION function_with_argtypes_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_FUNCTION,
                  objs => $_[2],
               );
            }
         | DATABASE name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_DATABASE,
                  objs => $_[2],
               );
            }
         | LANGUAGE name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_LANGUAGE,
                  objs => $_[2],
               );
            }
         | LARGE OBJECT NumericOnly_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_LARGEOBJECT,
                  objs => $_[3],
               );
            }
         | SCHEMA name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_NAMESPACE,
                  objs => $_[2],
               );
            }
         | TABLESPACE name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_OBJECT,
                  objtype => ACL_OBJECT_TABLESPACE,
                  objs => $_[2],
               );
            }
         | ALL TABLES IN SCHEMA name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_ALL_IN_SCHEMA,
                  objtype => ACL_OBJECT_RELATION,
                  objs => $_[5],
               );
            }
         | ALL SEQUENCES IN SCHEMA name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_ALL_IN_SCHEMA,
                  objtype => ACL_OBJECT_SEQUENCE,
                  objs => $_[5],
               );
            }
         | ALL FUNCTIONS IN SCHEMA name_list
            {
               PrivTarget *n = (PrivTarget *) palloc(sizeof(PrivTarget));
                  targtype => ACL_TARGET_ALL_IN_SCHEMA,
                  objtype => ACL_OBJECT_FUNCTION,
                  objs => $_[5],
               );
            }
      ;


grantee_list:
         grantee                               { lappend($_[1]) }
         | grantee_list ',' grantee            { lappend($_[1], $_[3]) }
      ;

grantee:   RoleId
            {
               PrivGrantee *n = makeNode(PrivGrantee);
               /* This hack lets us avoid reserving PUBLIC as a keyword*/
               if ($_[1] eq "public")
                     rolname => NULL,
               else
                     rolname => $_[1],
               );
            }
         | GROUP RoleId
            {
               PrivGrantee *n = makeNode(PrivGrantee);
               /* Treat GROUP PUBLIC as a synonym for PUBLIC */
               if ($_[2] eq "public")
                     rolname => NULL,
               else
                     rolname => $_[2],
               );
            }
      ;


opt_grant_grant_option:
         WITH GRANT OPTION { TRUE }
         | /*EMPTY*/       { FALSE }
      ;

function_with_argtypes_list:
         function_with_argtypes               { lappend($_[1]); }
         | function_with_argtypes_list ',' function_with_argtypes
                                              { lappend($_[1], $_[3]); }
      ;

function_with_argtypes:
         func_name func_args
            {
               return SQL::Translator::Statement::Function->new(
                  funcname => $_[1],
                  funcargs => extractArgTypes($_[2]),
               );
            }
      ;

/*****************************************************************************
 *
 * GRANT and REVOKE ROLE statements
 *
 *****************************************************************************/

GrantRoleStmt:
         GRANT privilege_list TO name_list opt_grant_admin_option opt_granted_by
            {
               return SQL::Translator::Statement::GrantRole->new(
                  is_grant => TRUE,
                  granted_roles => $_[2],
                  grantee_roles => $_[4],
                  admin_opt => $_[5],
                  grantor => $_[6],
               );
            }
      ;

RevokeRoleStmt:
         REVOKE privilege_list FROM name_list opt_granted_by opt_drop_behavior
            {
               return SQL::Translator::Statement::GrantRole->new(
                  is_grant => FALSE,
                  admin_opt => FALSE,
                  granted_roles => $_[2],
                  grantee_roles => $_[4],
                  behavior => $_[6],
               );
            }
         | REVOKE ADMIN OPTION FOR privilege_list FROM name_list opt_granted_by opt_drop_behavior
            {
               return SQL::Translator::Statement::GrantRole->new(
                  is_grant => FALSE,
                  admin_opt => TRUE,
                  granted_roles => $_[5],
                  grantee_roles => $_[7],
                  behavior => $_[9],
               );
            }
      ;

opt_grant_admin_option: WITH ADMIN OPTION      { TRUE }
         | /*EMPTY*/                           { FALSE }
      ;

opt_granted_by: GRANTED BY RoleId              { $_[3] }
         | /*EMPTY*/                           { NULL }
      ;

/*****************************************************************************
 *
 * ALTER DEFAULT PRIVILEGES statement
 *
 *****************************************************************************/

AlterDefaultPrivilegesStmt:
         ALTER DEFAULT PRIVILEGES DefACLOptionList DefACLAction
            {
               return SQL::Translator::Statement::AlterDefaultPrivileges->new(
                  options => $_[4],
                  action  => $_[5],
               );
            }
      ;

DefACLOptionList:
         DefACLOptionList DefACLOption         { lappend($_[1], $_[2]) }
         | /* EMPTY */                     { NULL }
      ;

DefACLOption:
         IN SCHEMA name_list
            {
               return makeDefElem("schemas", $_[3]);
            }
         | FOR ROLE name_list
            {
               return makeDefElem("roles", $_[3]);
            }
         | FOR USER name_list
            {
               return makeDefElem("roles", $_[3]);
            }
      ;

/*
 * This should match GRANT/REVOKE, except that individual target objects
 * are not mentioned and we only allow a subset of object types.
 */
DefACLAction:
         GRANT privileges ON defacl_privilege_target TO grantee_list
         opt_grant_grant_option
            {
               return SQL::Translator::Statement::Grant->new(
                  is_grant     => TRUE,
                  privileges   => $_[2],
                  targtype     => 'TARGET_DEFAULTS',
                  objtype      => $_[4],
                  objects      => NIL,
                  grantees     => $_[6],
                  grant_option => $_[7],
               );
            }
         | REVOKE privileges ON defacl_privilege_target
         FROM grantee_list opt_drop_behavior
            {
               return SQL::Translator::Statement::Grant->new(
                  is_grant     => FALSE,
                  grant_option => FALSE,
                  privileges   => $_[2],
                  targtype     => 'TARGET_DEFAULTS',
                  objtype      => $_[4],
                  objects      => NIL,
                  grantees     => $_[6],
                  behavior     => $_[7],
               );
            }
         | REVOKE GRANT OPTION FOR privileges ON defacl_privilege_target
         FROM grantee_list opt_drop_behavior
            {
               return SQL::Translator::Statement::Grant->new(
                  is_grant     => FALSE,
                  grant_option => TRUE,
                  privileges   => $_[5],
                  targtype     => 'TARGET_DEFAULTS',
                  objtype      => $_[7],
                  objects      => NIL,
                  grantees     => $_[9],
                  behavior     => $_[10],
               );
            }
      ;

defacl_privilege_target:
         TABLES           { ACL_OBJECT_RELATION }
         | FUNCTIONS      { ACL_OBJECT_FUNCTION }
         | SEQUENCES      { ACL_OBJECT_SEQUENCE }
      ;


/*****************************************************************************
 *
 *      QUERY: CREATE INDEX
 *
 * Note: we cannot put TABLESPACE clause after WHERE clause unless we are
 * willing to make TABLESPACE a fully reserved word.
 *****************************************************************************/

IndexStmt:   CREATE opt_unique INDEX opt_concurrently opt_index_name
         ON qualified_name access_method_clause '(' index_params ')'
         opt_reloptions OptTableSpace where_clause
            {
               return SQL::Translator::Statement::Index->new(
                  unique       => $_[2],
                  concurrent   => $_[4],
                  idxname      => $_[5],
                  relation     => $_[7],
                  accessMethod => $_[8],
                  indexParams  => $_[10],
                  options      => $_[12],
                  tableSpace   => $_[13],
                  whereClause  => $_[14],
                  indexOid     => 'InvalidOid',
               );
            }
      ;

opt_unique:
         UNIQUE                             { TRUE; }
         | /*EMPTY*/                        { FALSE; }
      ;

opt_concurrently:
         CONCURRENTLY                       { TRUE; }
         | /*EMPTY*/                        { FALSE; }
      ;

opt_index_name:
         index_name                         { $_[1]; }
         | /*EMPTY*/                        { NULL }
      ;

access_method_clause:
         USING access_method                { $_[2]; }
         | /*EMPTY*/                        { DEFAULT_INDEX_TYPE; }
      ;

index_params:   index_elem                  { lappend($_[1]); }
         | index_params ',' index_elem      { lappend($_[1], $_[3]); }
      ;

/*
 * Index attributes can be either simple column references, or arbitrary
 * expressions in parens.  For backwards-compatibility reasons, we allow
 * an expression that's just a function call to be written without parens.
 */
index_elem:   ColId opt_collate opt_class opt_asc_desc opt_nulls_order
            {
               return makeNode(IndexElem);
               $n->name = $_[1];
               $n->expr = NULL;
               $n->indexcolname = NULL;
               $n->collation = $_[2];
               $n->opclass = $_[3];
               $n->ordering = $_[4];
               $n->nulls_ordering = $_[5];
            }
         | func_expr opt_collate opt_class opt_asc_desc opt_nulls_order
            {
               return makeNode(IndexElem);
               $n->name = NULL;
               $n->expr = $_[1];
               $n->indexcolname = NULL;
               $n->collation = $_[2];
               $n->opclass = $_[3];
               $n->ordering = $_[4];
               $n->nulls_ordering = $_[5];
            }
         | '(' a_expr ')' opt_collate opt_class opt_asc_desc opt_nulls_order
            {
               return makeNode(IndexElem);
               $n->name = NULL;
               $n->expr = $_[2];
               $n->indexcolname = NULL;
               $n->collation = $_[4];
               $n->opclass = $_[5];
               $n->ordering = $_[6];
               $n->nulls_ordering = $_[7];
            }
      ;

opt_collate: COLLATE any_name       { $_[2]; }
         | /*EMPTY*/                { NIL }
      ;

opt_class:   any_name               { $_[1]; }
         | USING any_name           { $_[2]; }
         | /*EMPTY*/                { NIL }
      ;

opt_asc_desc: ASC                   { SORTBY_ASC }
         | DESC                     { SORTBY_DESC }
         | /*EMPTY*/                { SORTBY_DEFAULT }
      ;

opt_nulls_order: NULLS_FIRST        { SORTBY_NULLS_FIRST }
         | NULLS_LAST               { SORTBY_NULLS_LAST }
         | /*EMPTY*/                { SORTBY_NULLS_DEFAULT }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            create [or replace] function <fname>
 *                  [(<type-1> { , <type-n>})]
 *                  returns <type-r>
 *                  as <filename or code in language as appropriate>
 *                  language <lang> [with parameters]
 *
 *****************************************************************************/

CreateFunctionStmt:
         CREATE opt_or_replace FUNCTION func_name func_args_with_defaults
         RETURNS func_return createfunc_opt_list opt_definition
            {
               return SQL::Translator::Statement::CreateFunction->new(
                  replace    => $_[2],
                  funcname   => $_[4],
                  parameters => $_[5],
                  returnType => $_[7],
                  options    => $_[8],
                  withClause => $_[9],
               );
            }
         | CREATE opt_or_replace FUNCTION func_name func_args_with_defaults
           RETURNS TABLE '(' table_func_column_list ')' createfunc_opt_list opt_definition
            {
               return SQL::Translator::Statement::CreateFunction->new(
                  replace => $_[2],
                  funcname => $_[4],
                  parameters => mergeTableFuncParameters($_[5], $_[9]),
                  returnType => TableFuncTypeName($_[9]),
               n->returnType->location( $_[0]->YYLLoc($_[7], 7) );
                  options => $_[11],
                  withClause => $_[12],
               );
            }
         | CREATE opt_or_replace FUNCTION func_name func_args_with_defaults
           createfunc_opt_list opt_definition
            {
               return SQL::Translator::Statement::CreateFunction->new(
                  replace => $_[2],
                  funcname => $_[4],
                  parameters => $_[5],
                  returnType => NULL,
                  options => $_[6],
                  withClause => $_[7],
               );
            }
      ;

opt_or_replace:
         OR REPLACE                      { TRUE }
         | /*EMPTY*/                     { FALSE }
      ;

func_args:   '(' func_args_list ')'      { $_[2] }
         | '(' ')'                       { NULL }
      ;

func_args_list:
         func_arg                        { lappend($_[1]); }
         | func_args_list ',' func_arg   { lappend($_[1], $_[3]); }
      ;

/*
 * func_args_with_defaults is separate because we only want to accept
 * defaults in CREATE FUNCTION, not in ALTER etc.
 */
func_args_with_defaults:
      '(' func_args_with_defaults_list ')'      { $_[2]; }
      | '(' ')'                                 { NULL }
      ;

func_args_with_defaults_list:
      func_arg_with_default                  { lappend($_[1]); }
      | func_args_with_defaults_list ',' func_arg_with_default
                                             { lappend($_[1], $_[3]); }
      ;

/*
 * The style with arg_class first is SQL99 standard, but Oracle puts
 * param_name first; accept both since it's likely people will try both
 * anyway.  Don't bother trying to save productions by letting arg_class
 * have an empty alternative ... you'll get shift/reduce conflicts.
 *
 * We can catch over-specified arguments here if we want to,
 * but for now better to silently swallow typmod, etc.
 * - thomas 2000-03-22
 */
 
func_arg:
         arg_class param_name func_type
            {
               return SQL::Translator::Statement::Function::Param->new(
                  name    => $_[2],
                  argType => $_[3],
                  mode    => $_[1],
                  defexpr => NULL,
               );
            }
         | param_name arg_class func_type
            {
               return SQL::Translator::Statement::Function::Param->new(
                  name    => $_[1],
                  argType => $_[3],
                  mode    => $_[2],
                  defexpr => NULL,
               );
            }
         | param_name func_type
            {
               return SQL::Translator::Statement::Function::Param->new(
                  name    => $_[1],
                  argType => $_[2],
                  mode    => 'IN',
                  defexpr => NULL,
               );
            }
         | arg_class func_type
            {
               return SQL::Translator::Statement::Function::Param->new(
                  name    => NULL,
                  argType => $_[2],
                  mode    => $_[1],
                  defexpr => NULL,
               );
            }
         | func_type
            {
               return SQL::Translator::Statement::Function::Param->new(
                  name    => NULL,
                  argType => $_[1],
                  mode    => 'IN',
                  defexpr => NULL,
               );
            }
      ;

/* INOUT is SQL99 standard, IN OUT is for Oracle compatibility */
arg_class: IN                      { FUNC_PARAM_IN       }
         | OUT                     { FUNC_PARAM_OUT      }
         | INOUT                   { FUNC_PARAM_INOUT    }
         | IN OUT                  { FUNC_PARAM_INOUT    }
         | VARIADIC                { FUNC_PARAM_VARIADIC }
      ;

/*
 * Ideally param_name should be ColId, but that causes too many conflicts.
 */
param_name:   type_function_name
      ;

func_return:
         func_type
               /* We can catch over-specified results here if we want to,
                * but for now better to silently swallow typmod, etc.
                * - thomas 2000-03-22
                */
            {
               return $_[1];
            }
      ;

/*
 * We would like to make the %TYPE productions here be ColId attrs etc,
 * but that causes reduce/reduce conflicts.  type_function_name
 * is next best choice.
 */
func_type:   Typename                        { $_[1] }
         | type_function_name attrs '%' TYPE
            {
               return makeTypeNameFromNameList(lcons(makeString($_[1]), $_[2]));
               $n->pct_type = TRUE;
               $n->location( $_[0]->YYLLoc($_[1], 1) );
            }
         | SETOF type_function_name attrs '%' TYPE
            {
               return makeTypeNameFromNameList(lcons(makeString($_[2]), $_[3]));
               $n->pct_type = TRUE;
               $n->setof = TRUE;
               $n->location( $_[0]->YYLLoc($_[2], 2) );
            }
      ;

func_arg_with_default:
      func_arg
             {
                return $_[1];
             }
      | func_arg DEFAULT a_expr
             {
                $_[1]->_defexpr($_[3]);
                return $_[1];
             }
      | func_arg '=' a_expr
             {
                $_[1]->_defexpr($_[3]);
                return $_[1];
             }
      ;


createfunc_opt_list:
         /* Must be at least one to prevent conflict */
         createfunc_opt_item                       { lappend($_[1]) }
         | createfunc_opt_list createfunc_opt_item { lappend($_[1], $_[2]) }
   ;

/*
 * Options common to both CREATE FUNCTION and ALTER FUNCTION
 */
common_func_opt_item:
         CALLED ON NULL INPUT
            {
               return makeDefElem("strict", makeInteger(FALSE));
            }
         | RETURNS NULL ON NULL INPUT
            {
               return makeDefElem("strict", makeInteger(TRUE));
            }
         | STRICT
            {
               return makeDefElem("strict", makeInteger(TRUE));
            }
         | IMMUTABLE
            {
               return makeDefElem("volatility", makeString("immutable"));
            }
         | STABLE
            {
               return makeDefElem("volatility", makeString("stable"));
            }
         | VOLATILE
            {
               return makeDefElem("volatility", makeString("volatile"));
            }
         | EXTERNAL SECURITY DEFINER
            {
               return makeDefElem("security", makeInteger(TRUE));
            }
         | EXTERNAL SECURITY INVOKER
            {
               return makeDefElem("security", makeInteger(FALSE));
            }
         | SECURITY DEFINER
            {
               return makeDefElem("security", makeInteger(TRUE));
            }
         | SECURITY INVOKER
            {
               return makeDefElem("security", makeInteger(FALSE));
            }
         | COST NumericOnly
            {
               return makeDefElem("cost", $_[2]);
            }
         | ROWS NumericOnly
            {
               return makeDefElem("rows", $_[2]);
            }
         | SetResetClause
            /* we abuse the normal content of a DefElem here */
            {
               return makeDefElem("set", $_[1]);
            }
      ;

createfunc_opt_item:
         AS func_as
            {
               return makeDefElem("as", $_[2]);
            }
         | LANGUAGE ColId_or_Sconst
            {
               return makeDefElem("language", makeString($_[2]));
            }
         | WINDOW
            {
               return makeDefElem("window", makeInteger(TRUE));
            }
         | common_func_opt_item
            {
               return $_[1];
            }
      ;

func_as:   Sconst                  { lappend(makeString($_[1])) }
         | Sconst ',' Sconst
            {
               return lappend(makeString($_[1]), makeString($_[3]));
            }
      ;

opt_definition:
         WITH definition                    { $_[2] }
         | /*EMPTY*/                        { NULL }
      ;

table_func_column:   param_name func_type
            {
               return SQL::Translator::Statement::Function::Param->new(
                  name => $_[1],
                  argType => $_[2],
                  mode => FUNC_PARAM_TABLE,
                  defexpr => NULL,
               );
            }
      ;

table_func_column_list:
         table_func_column
            {
               return lappend($_[1]);
            }
         | table_func_column_list ',' table_func_column
            {
               return lappend($_[1], $_[3]);
            }
      ;

/*****************************************************************************
 * ALTER FUNCTION
 *
 * RENAME and OWNER subcommands are already provided by the generic
 * ALTER infrastructure, here we just specify alterations that can
 * only be applied to functions.
 *
 *****************************************************************************/
AlterFunctionStmt:
         ALTER FUNCTION function_with_argtypes alterfunc_opt_list opt_restrict
            {
               return SQL::Translator::Statement::AlterFunction->new(
                  func => $_[3],
                  actions => $_[4],
               );
            }
      ;

alterfunc_opt_list:
         /* At least one option must be specified */
         common_func_opt_item                      { lappend($_[1]) }
         | alterfunc_opt_list common_func_opt_item { lappend($_[1], $_[2]) }
      ;

/* Ignored, merely for SQL compliance */
opt_restrict:
         RESTRICT
         | /* EMPTY */
      ;


/*****************************************************************************
 *
 *      QUERY:
 *
 *      DROP FUNCTION funcname (arg1, arg2, ...) [ RESTRICT | CASCADE ]
 *      DROP AGGREGATE aggname (arg1, ...) [ RESTRICT | CASCADE ]
 *      DROP OPERATOR opname (leftoperand_typ, rightoperand_typ) [ RESTRICT | CASCADE ]
 *
 *****************************************************************************/

RemoveFuncStmt:
         DROP FUNCTION func_name func_args opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveFunc->new(
                  kind => OBJECT_FUNCTION,
                  name => $_[3],
                  args => extractArgTypes($_[4]),
                  behavior => $_[5],
                  missing_ok => FALSE,
               );
            }
         | DROP FUNCTION IF EXISTS func_name func_args opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveFunc->new(
                  kind => OBJECT_FUNCTION,
                  name => $_[5],
                  args => extractArgTypes($_[6]),
                  behavior => $_[7],
                  missing_ok => TRUE,
               );
            }
      ;

RemoveAggrStmt:
         DROP AGGREGATE func_name aggr_args opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveFunc->new(
                  kind => OBJECT_AGGREGATE,
                  name => $_[3],
                  args => $_[4],
                  behavior => $_[5],
                  missing_ok => FALSE,
               );
            }
         | DROP AGGREGATE IF EXISTS func_name aggr_args opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveFunc->new(
                  kind => OBJECT_AGGREGATE,
                  name => $_[5],
                  args => $_[6],
                  behavior => $_[7],
                  missing_ok => TRUE,
               );
            }
      ;

RemoveOperStmt:
         DROP OPERATOR any_operator oper_argtypes opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveFunc->new(
                  kind => OBJECT_OPERATOR,
                  name => $_[3],
                  args => $_[4],
                  behavior => $_[5],
                  missing_ok => FALSE,
               );
            }
         | DROP OPERATOR IF EXISTS any_operator oper_argtypes opt_drop_behavior
            {
               return SQL::Translator::Statement::RemoveFunc->new(
                  kind => OBJECT_OPERATOR,
                  name => $_[5],
                  args => $_[6],
                  behavior => $_[7],
                  missing_ok => TRUE,
               );
            }
      ;

oper_argtypes:
         '(' Typename ')'
            {
               $_[0]->ereport(ERROR,
                     ERRCODE_SYNTAX_ERROR,
                     "missing argument",
                     "Use NONE to denote the missing argument of a unary operator.",
                     $_[0]->YYLLoc($_[3], 3));
            }
         | '(' Typename ',' Typename ')'
               { lappend($_[2], $_[4]) }
         | '(' NONE ',' Typename ')'               /* left unary */
               { lappend(NULL, $_[4]) }
         | '(' Typename ',' NONE ')'               /* right unary */
               { lappend($_[2], NULL) }
      ;

any_operator:
         all_Op
               { lappend(makeString($_[1])) }
         | ColId '.' any_operator
               { lcons(makeString($_[1]), $_[3]) }
      ;

/*****************************************************************************
 *
 *      DO <anonymous code block> [ LANGUAGE language ]
 *
 * We use a DefElem list for future extensibility, and to allow flexibility
 * in the clause order.
 *
 *****************************************************************************/

DoStmt: DO dostmt_opt_list
            {
               return SQL::Translator::Statement::Do->new(
                  args => $_[2],
               );
            }
      ;

dostmt_opt_list:
         dostmt_opt_item                     { lappend($_[1]) }
         | dostmt_opt_list dostmt_opt_item   { lappend($_[1], $_[2]) }
      ;

dostmt_opt_item:
         Sconst
            {
               return makeDefElem("as", makeString($_[1]));
            }
         | LANGUAGE ColId_or_Sconst
            {
               return makeDefElem("language", makeString($_[2]));
            }
      ;

/*****************************************************************************
 *
 *      CREATE CAST / DROP CAST
 *
 *****************************************************************************/

CreateCastStmt: CREATE CAST '(' Typename AS Typename ')'
               WITH FUNCTION function_with_argtypes cast_context
            {
               return SQL::Translator::Statement::CreateCast->new(
                  sourcetype => $_[4],
                  targettype => $_[6],
                  func => $_[10],
                  context => $_[11],
                  inout => FALSE,
               );
            }
         | CREATE CAST '(' Typename AS Typename ')'
               WITHOUT FUNCTION cast_context
            {
               return SQL::Translator::Statement::CreateCast->new(
                  sourcetype => $_[4],
                  targettype => $_[6],
                  func => NULL,
                  context => $_[10],
                  inout => FALSE,
               );
            }
         | CREATE CAST '(' Typename AS Typename ')'
               WITH INOUT cast_context
            {
               return SQL::Translator::Statement::CreateCast->new(
                  sourcetype => $_[4],
                  targettype => $_[6],
                  func => NULL,
                  context => $_[10],
                  inout => TRUE,
               );
            }
      ;

cast_context:  AS IMPLICIT                { COERCION_IMPLICIT   }
      | AS ASSIGNMENT                     { COERCION_ASSIGNMENT }
      | /*EMPTY*/                         { COERCION_EXPLICIT   }
      ;


DropCastStmt: DROP CAST opt_if_exists '(' Typename AS Typename ')' opt_drop_behavior
            {
               return SQL::Translator::Statement::DropCast->new(
                  sourcetype => $_[5],
                  targettype => $_[7],
                  behavior => $_[9],
                  missing_ok => $_[3],
               );
            }
      ;

opt_if_exists: IF EXISTS                  { TRUE }
      | /*EMPTY*/                        { FALSE }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *
 *      REINDEX type <name> [FORCE]
 *
 * FORCE no longer does anything, but we accept it for backwards compatibility
 *****************************************************************************/

ReindexStmt:
         REINDEX reindex_type qualified_name opt_force
            {
               return SQL::Translator::Statement::Reindex->new(
                  kind => $_[2],
                  relation => $_[3],
                  name => NULL,
               );
            }
         | REINDEX SYSTEM name opt_force
            {
               return SQL::Translator::Statement::Reindex->new(
                  kind => OBJECT_DATABASE,
                  name => $_[3],
                  relation => NULL,
                  do_system => TRUE,
                  do_user => FALSE,
               );
            }
         | REINDEX DATABASE name opt_force
            {
               return SQL::Translator::Statement::Reindex->new(
                  kind => OBJECT_DATABASE,
                  name => $_[3],
                  relation => NULL,
                  do_system => TRUE,
                  do_user => TRUE,
               );
            }
      ;

reindex_type:
         INDEX                             { 'INDEX' }
         | TABLE                           { 'TABLE' }
      ;

opt_force:   FORCE                         {  return TRUE; }
         | /* EMPTY */                     {  return FALSE; }
      ;


/*****************************************************************************
 *
 * ALTER THING name RENAME TO newname
 *
 *****************************************************************************/

RenameStmt: ALTER AGGREGATE func_name aggr_args RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_AGGREGATE,
                  object => $_[3],
                  objarg => $_[4],
                  newname => $_[7],
               );
            }
         | ALTER COLLATION any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_COLLATION,
                  object => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER CONVERSION any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_CONVERSION,
                  object => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER DATABASE database_name RENAME TO database_name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_DATABASE,
                  subname => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER FUNCTION function_with_argtypes RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_FUNCTION,
                  object => $_[3]->funcname,
                  objarg => $_[3]->funcargs,
                  newname => $_[6],
               );
            }
         | ALTER GROUP RoleId RENAME TO RoleId
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_ROLE,
                  subname => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER opt_procedural LANGUAGE name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_LANGUAGE,
                  subname => $_[4],
                  newname => $_[7],
               );
            }
         | ALTER OPERATOR CLASS any_name USING access_method RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_OPCLASS,
                  object => $_[4],
                  subname => $_[6],
                  newname => $_[9],
               );
            }
         | ALTER OPERATOR FAMILY any_name USING access_method RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_OPFAMILY,
                  object => $_[4],
                  subname => $_[6],
                  newname => $_[9],
               );
            }
         | ALTER SCHEMA name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_SCHEMA,
                  subname => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER TABLE relation_expr RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TABLE,
                  relation => $_[3],
                  subname => NULL,
                  newname => $_[6],
               );
            }
         | ALTER SEQUENCE qualified_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_SEQUENCE,
                  relation => $_[3],
                  subname => NULL,
                  newname => $_[6],
               );
            }
         | ALTER VIEW qualified_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_VIEW,
                  relation => $_[3],
                  subname => NULL,
                  newname => $_[6],
               );
            }
         | ALTER INDEX qualified_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_INDEX,
                  relation => $_[3],
                  subname => NULL,
                  newname => $_[6],
               );
            }
         | ALTER FOREIGN TABLE relation_expr RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_FOREIGN_TABLE,
                  relation => $_[4],
                  subname => NULL,
                  newname => $_[7],
               );
            }
         | ALTER TABLE relation_expr RENAME opt_column name TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType   => OBJECT_COLUMN,
                  relationType => OBJECT_TABLE,
                  relation => $_[3],
                  subname => $_[6],
                  newname => $_[8],
               );
            }
         | ALTER FOREIGN TABLE relation_expr RENAME opt_column name TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType   => OBJECT_COLUMN,
                  relationType => OBJECT_FOREIGN_TABLE,
                  relation => $_[4],
                  subname => $_[7],
                  newname => $_[9],
               );
            }
         | ALTER TRIGGER name ON qualified_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TRIGGER,
                  relation => $_[5],
                  subname => $_[3],
                  newname => $_[8],
               );
            }
         | ALTER ROLE RoleId RENAME TO RoleId
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_ROLE,
                  subname => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER USER RoleId RENAME TO RoleId
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_ROLE,
                  subname => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER TABLESPACE name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TABLESPACE,
                  subname => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER TABLESPACE name SET reloptions
            {
               return SQL::Translator::Statement::AlterTableSpaceOptions->new(
                  tablespacename => $_[3],
                  options => $_[5],
                  isReset => FALSE,
               );
            }
         | ALTER TABLESPACE name RESET reloptions
            {
               return SQL::Translator::Statement::AlterTableSpaceOptions->new(
                  tablespacename => $_[3],
                  options => $_[5],
                  isReset => TRUE,
               );
            }
         | ALTER TEXT SEARCH PARSER any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TSPARSER,
                  object => $_[5],
                  newname => $_[8],
               );
            }
         | ALTER TEXT SEARCH DICTIONARY any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TSDICTIONARY,
                  object => $_[5],
                  newname => $_[8],
               );
            }
         | ALTER TEXT SEARCH TEMPLATE any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TSTEMPLATE,
                  object => $_[5],
                  newname => $_[8],
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TSCONFIGURATION,
                  object => $_[5],
                  newname => $_[8],
               );
            }
         | ALTER TYPE any_name RENAME TO name
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType => OBJECT_TYPE,
                  object => $_[3],
                  newname => $_[6],
               );
            }
         | ALTER TYPE any_name RENAME ATTRIBUTE name TO name opt_drop_behavior
            {
               return SQL::Translator::Statement::Rename->new(
                  renameType   => OBJECT_ATTRIBUTE,
                  relationType => OBJECT_TYPE,
                  # TODO: #* relation => makeRangeVarFromAnyName($_[3], $_[0]->YYLLoc($_[3], 3)),
                  subname => $_[6],
                  newname => $_[8],
                  behavior => $_[9],
               );
            }
      ;

opt_column: COLUMN                           { COLUMN }
         | /*EMPTY*/                         { 0 }
      ;

opt_set_data: SET DATA                      { 1 }
         | /*EMPTY*/                        { 0 }
      ;

/*****************************************************************************
 *
 * ALTER THING name SET SCHEMA name
 *
 *****************************************************************************/

AlterObjectSchemaStmt:
         ALTER AGGREGATE func_name aggr_args SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_AGGREGATE,
                  object => $_[3],
                  objarg => $_[4],
                  newschema => $_[7],
               );
            }
         | ALTER COLLATION any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_COLLATION,
                  object => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER CONVERSION any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_CONVERSION,
                  object => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER DOMAIN any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_DOMAIN,
                  object => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER EXTENSION any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_EXTENSION,
                  object => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER FUNCTION function_with_argtypes SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_FUNCTION,
                  object => $_[3]->funcname,
                  objarg => $_[3]->funcargs,
                  newschema => $_[6],
               );
            }
         | ALTER OPERATOR any_operator oper_argtypes SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_OPERATOR,
                  object => $_[3],
                  objarg => $_[4],
                  newschema => $_[7],
               );
            }
         | ALTER OPERATOR CLASS any_name USING access_method SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_OPCLASS,
                  object => $_[4],
                  addname => $_[6],
                  newschema => $_[9],
               );
            }
         | ALTER OPERATOR FAMILY any_name USING access_method SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_OPFAMILY,
                  object => $_[4],
                  addname => $_[6],
                  newschema => $_[9],
               );
            }
         | ALTER TABLE relation_expr SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_TABLE,
                  relation => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER TEXT SEARCH PARSER any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_TSPARSER,
                  object => $_[5],
                  newschema => $_[8],
               );
            }
         | ALTER TEXT SEARCH DICTIONARY any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_TSDICTIONARY,
                  object => $_[5],
                  newschema => $_[8],
               );
            }
         | ALTER TEXT SEARCH TEMPLATE any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_TSTEMPLATE,
                  object => $_[5],
                  newschema => $_[8],
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_TSCONFIGURATION,
                  object => $_[5],
                  newschema => $_[8],
               );
            }
         | ALTER SEQUENCE qualified_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_SEQUENCE,
                  relation => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER VIEW qualified_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_VIEW,
                  relation => $_[3],
                  newschema => $_[6],
               );
            }
         | ALTER FOREIGN TABLE relation_expr SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_FOREIGN_TABLE,
                  relation => $_[4],
                  newschema => $_[7],
               );
            }
         | ALTER TYPE any_name SET SCHEMA name
            {
               return SQL::Translator::Statement::AlterObjectSchema->new(
                  objectType => OBJECT_TYPE,
                  object => $_[3],
                  newschema => $_[6],
               );
            }
      ;

/*****************************************************************************
 *
 * ALTER THING name OWNER TO newname
 *
 *****************************************************************************/

AlterOwnerStmt: ALTER AGGREGATE func_name aggr_args OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_AGGREGATE,
                  object => $_[3],
                  objarg => $_[4],
                  newowner => $_[7],
               );
            }
         | ALTER COLLATION any_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_COLLATION,
                  object => $_[3],
                  newowner => $_[6],
               );
            }
         | ALTER CONVERSION any_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_CONVERSION,
                  object => $_[3],
                  newowner => $_[6],
               );
            }
         | ALTER DATABASE database_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_DATABASE,
                  object => lappend(makeString($_[3])),
                  newowner => $_[6],
               );
            }
         | ALTER DOMAIN any_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_DOMAIN,
                  object => $_[3],
                  newowner => $_[6],
               );
            }
         | ALTER FUNCTION function_with_argtypes OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_FUNCTION,
                  object => $_[3]->funcname,
                  objarg => $_[3]->funcargs,
                  newowner => $_[6],
               );
            }
         | ALTER opt_procedural LANGUAGE name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_LANGUAGE,
                  object => lappend(makeString($_[4])),
                  newowner => $_[7],
               );
            }
         | ALTER LARGE OBJECT NumericOnly OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_LARGEOBJECT,
                  object => lappend($_[4]),
                  newowner => $_[7],
               );
            }
         | ALTER OPERATOR any_operator oper_argtypes OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_OPERATOR,
                  object => $_[3],
                  objarg => $_[4],
                  newowner => $_[7],
               );
            }
         | ALTER OPERATOR CLASS any_name USING access_method OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_OPCLASS,
                  object => $_[4],
                  addname => $_[6],
                  newowner => $_[9],
               );
            }
         | ALTER OPERATOR FAMILY any_name USING access_method OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_OPFAMILY,
                  object => $_[4],
                  addname => $_[6],
                  newowner => $_[9],
               );
            }
         | ALTER SCHEMA name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_SCHEMA,
                  object => lappend(makeString($_[3])),
                  newowner => $_[6],
               );
            }
         | ALTER TYPE any_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_TYPE,
                  object => $_[3],
                  newowner => $_[6],
               );
            }
         | ALTER TABLESPACE name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_TABLESPACE,
                  object => lappend(makeString($_[3])),
                  newowner => $_[6],
               );
            }
         | ALTER TEXT SEARCH DICTIONARY any_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_TSDICTIONARY,
                  object => $_[5],
                  newowner => $_[8],
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_TSCONFIGURATION,
                  object => $_[5],
                  newowner => $_[8],
               );
            }
         | ALTER FOREIGN DATA WRAPPER name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_FDW,
                  object => lappend(makeString($_[5])),
                  newowner => $_[8],
               );
            }
         | ALTER SERVER name OWNER TO RoleId
            {
               return SQL::Translator::Statement::AlterOwner->new(
                  objectType => OBJECT_FOREIGN_SERVER,
                  object => lappend(makeString($_[3])),
                  newowner => $_[6],
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERY:   Define Rewrite Rule
 *
 *****************************************************************************/

RuleStmt:   CREATE opt_or_replace RULE name AS
         ON event TO qualified_name where_clause
         DO opt_instead RuleActionList
            {
               return SQL::Translator::Statement::Rule->new(
                  replace => $_[2],
                  relation => $_[9],
                  rulename => $_[4],
                  whereClause => $_[10],
                  event => $_[7],
                  instead => $_[12],
                  actions => $_[13],
               );
            }
      ;

RuleActionList:
         NOTHING                           { NIL }
         | RuleActionStmt                  { lappend($_[1]) }
         | '(' RuleActionMulti ')'            { $_[2] }
      ;

/* the thrashing around here is to discard "empty" statements... */
RuleActionMulti:
         RuleActionMulti ';' RuleActionStmtOrEmpty
            { (defined $_[3]) ? lappend($_[1], $_[3]) : $_[1]; }
         | RuleActionStmtOrEmpty
            { (defined $_[1]) ? lappend($_[1]) : NIL; }
      ;

RuleActionStmt:
         SelectStmt
         | InsertStmt
         | UpdateStmt
         | DeleteStmt
         | NotifyStmt
      ;

RuleActionStmtOrEmpty:
         RuleActionStmt                     { $_[1] }
         |   /*EMPTY*/                      { NULL }
      ;

event:      SELECT                       { CMD_SELECT }
         | UPDATE                        { CMD_UPDATE }
         | DELETE                        { CMD_DELETE }
         | INSERT                        { CMD_INSERT }
       ;

opt_instead:
         INSTEAD                          { TRUE  }
         | ALSO                           { FALSE }
         | /*EMPTY*/                      { FALSE }
      ;


DropRuleStmt:
         DROP RULE name ON qualified_name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropProperty->new(
                  relation => $_[5],
                  property => $_[3],
                  behavior => $_[6],
                  removeType => OBJECT_RULE,
                  missing_ok => FALSE,
               );
            }
         | DROP RULE IF EXISTS name ON qualified_name opt_drop_behavior
            {
               return SQL::Translator::Statement::DropProperty->new(
                  relation => $_[7],
                  property => $_[5],
                  behavior => $_[8],
                  removeType => OBJECT_RULE,
                  missing_ok => TRUE,
               );
            }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            NOTIFY <identifier> can appear both in rule bodies and
 *            as a query-level command
 *
 *****************************************************************************/

NotifyStmt: NOTIFY ColId notify_payload
            {
               return SQL::Translator::Statement::Notify->new(
                  conditionname => $_[2],
                  payload => $_[3],
               );
            }
      ;

notify_payload:
         ',' Sconst                     { $_[2] }
         | /*EMPTY*/                    { NULL  }
      ;

ListenStmt: LISTEN ColId
            {
               return SQL::Translator::Statement::Listen->new(
                  conditionname => $_[2],
               );
            }
      ;

UnlistenStmt:
         UNLISTEN ColId
            {
               return SQL::Translator::Statement::Unlisten->new(
                  conditionname => $_[2],
               );
            }
         | UNLISTEN '*'
            {
               return SQL::Translator::Statement::Unlisten->new(
                  conditionname => NULL,
               );
            }
      ;


/*****************************************************************************
 *
 *      Transactions:
 *
 *      BEGIN / COMMIT / ROLLBACK
 *      (also older versions END / ABORT)
 *
 *****************************************************************************/

TransactionStmt:
         ABORT opt_transaction
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_ROLLBACK,
                  options => NIL,
               );
            }
         | BEGIN opt_transaction transaction_mode_list_or_empty
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_BEGIN,
                  options => $_[3],
               );
            }
         | START TRANSACTION transaction_mode_list_or_empty
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_START,
                  options => $_[3],
               );
            }
         | COMMIT opt_transaction
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_COMMIT,
                  options => NIL,
               );
            }
         | END opt_transaction
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_COMMIT,
                  options => NIL,
               );
            }
         | ROLLBACK opt_transaction
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_ROLLBACK,
                  options => NIL,
               );
            }
         | SAVEPOINT ColId
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_SAVEPOINT,
                  options => lappend(makeDefElem("savepoint_name", makeString($_[2])));
               );
            }
         | RELEASE SAVEPOINT ColId
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_RELEASE,
                  options => lappend(makeDefElem("savepoint_name", makeString($_[3])));
               );
            }
         | RELEASE ColId
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_RELEASE,
                  options => lappend(makeDefElem("savepoint_name", makeString($_[2])));
               );
            }
         | ROLLBACK opt_transaction TO SAVEPOINT ColId
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_ROLLBACK_TO,
                  options => lappend(makeDefElem("savepoint_name", makeString($_[5])));
               );
            }
         | ROLLBACK opt_transaction TO ColId
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_ROLLBACK_TO,
                  options => lappend(makeDefElem("savepoint_name", makeString($_[4])));
               );
            }
         | PREPARE TRANSACTION Sconst
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_PREPARE,
                  gid => $_[3],
               );
            }
         | COMMIT PREPARED Sconst
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_COMMIT_PREPARED,
                  gid => $_[3],
               );
            }
         | ROLLBACK PREPARED Sconst
            {
               return SQL::Translator::Statement::Transaction->new(
                  kind => TRANS_STMT_ROLLBACK_PREPARED,
                  gid => $_[3],
               );
            }
      ;

opt_transaction:   WORK                     {}
         | TRANSACTION                      {}
         | /*EMPTY*/                        {}
      ;

transaction_mode_item:
         ISOLATION LEVEL iso_level
               { return makeDefElem("transaction_isolation",
                              makeStringConst($_[3], $_[0]->YYLLoc($_[3], 3))); }
         | READ ONLY
               { return makeDefElem("transaction_read_only",
                              makeIntConst(TRUE, $_[0]->YYLLoc($_[1], 1))); }
         | READ WRITE
               { return makeDefElem("transaction_read_only",
                              makeIntConst(FALSE, $_[0]->YYLLoc($_[1], 1))); }
         | DEFERRABLE
               { return makeDefElem("transaction_deferrable",
                              makeIntConst(TRUE, $_[0]->YYLLoc($_[1], 1))); }
         | NOT DEFERRABLE
               { return makeDefElem("transaction_deferrable",
                              makeIntConst(FALSE, $_[0]->YYLLoc($_[1], 1))); }
      ;

/* Syntax with commas is SQL-spec, without commas is Postgres historical */
transaction_mode_list:
         transaction_mode_item
               { lappend($_[1]) }
         | transaction_mode_list ',' transaction_mode_item
               { lappend($_[1], $_[3]) }
         | transaction_mode_list transaction_mode_item
               { lappend($_[1], $_[2]) }
      ;

transaction_mode_list_or_empty:
         transaction_mode_list
         | /* EMPTY */
               { NULL }
      ;


/*****************************************************************************
 *
 *   QUERY:
 *      CREATE [ OR REPLACE ] [ TEMP ] VIEW <viewname> '('target-list ')'
 *         AS <query> [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
 *
 *****************************************************************************/

ViewStmt: CREATE OptTemp VIEW qualified_name opt_column_list
            AS SelectStmt opt_check_option
            {
               return SQL::Translator::Statement::View->new(
                  view => $_[4],
               n->view->relpersistence = $_[2];
                  aliases => $_[5],
                  query => $_[7],
                  replace => FALSE,
               );
            }
      | CREATE OR REPLACE OptTemp VIEW qualified_name opt_column_list
            AS SelectStmt opt_check_option
            {
               return SQL::Translator::Statement::View->new(
                  view => $_[6],
               n->view->relpersistence = $_[4];
                  aliases => $_[7],
                  query => $_[9],
                  replace => TRUE,
               );
            }
      ;

opt_check_option:
      WITH CHECK OPTION
            {
               $_[0]->ereport(ERROR,
                     ERRCODE_FEATURE_NOT_SUPPORTED,
                      "WITH CHECK OPTION is not implemented"));
            }
      | WITH CASCADED CHECK OPTION
            {
               $_[0]->ereport(ERROR,
                     ERRCODE_FEATURE_NOT_SUPPORTED,
                      "WITH CHECK OPTION is not implemented"));
            }
      | WITH LOCAL CHECK OPTION
            {
               $_[0]->ereport(ERROR,
                     ERRCODE_FEATURE_NOT_SUPPORTED,
                      "WITH CHECK OPTION is not implemented"));
            }
      | /* EMPTY */                     { NULL }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *            LOAD "filename"
 *
 *****************************************************************************/

LoadStmt:   LOAD file_name
            {
               return SQL::Translator::Statement::Load->new(
                  filename => $_[2],
               );
            }
      ;


/*****************************************************************************
 *
 *      CREATE DATABASE
 *
 *****************************************************************************/

CreatedbStmt:
         CREATE DATABASE database_name opt_with createdb_opt_list
            {
               return SQL::Translator::Statement::Createdb->new(
                  dbname => $_[3],
                  options => $_[5],
               );
            }
      ;

createdb_opt_list:
         createdb_opt_list createdb_opt_item      { lappend($_[1], $_[2]) }
         | /* EMPTY */                            { NIL }
      ;

createdb_opt_item:
         TABLESPACE opt_equal name
            {
               return makeDefElem("tablespace", makeString($_[3]));
            }
         | TABLESPACE opt_equal DEFAULT
            {
               return makeDefElem("tablespace", NULL);
            }
         | LOCATION opt_equal Sconst
            {
               return makeDefElem("location", makeString($_[3]));
            }
         | LOCATION opt_equal DEFAULT
            {
               return makeDefElem("location", NULL);
            }
         | TEMPLATE opt_equal name
            {
               return makeDefElem("template", makeString($_[3]));
            }
         | TEMPLATE opt_equal DEFAULT
            {
               return makeDefElem("template", NULL);
            }
         | ENCODING opt_equal Sconst
            {
               return makeDefElem("encoding", makeString($_[3]));
            }
         | ENCODING opt_equal Iconst
            {
               return makeDefElem("encoding", makeInteger($_[3]));
            }
         | ENCODING opt_equal DEFAULT
            {
               return makeDefElem("encoding", NULL);
            }
         | LC_COLLATE opt_equal Sconst
            {
               return makeDefElem("lc_collate", makeString($_[3]));
            }
         | LC_COLLATE opt_equal DEFAULT
            {
               return makeDefElem("lc_collate", NULL);
            }
         | LC_CTYPE opt_equal Sconst
            {
               return makeDefElem("lc_ctype", makeString($_[3]));
            }
         | LC_CTYPE opt_equal DEFAULT
            {
               return makeDefElem("lc_ctype", NULL);
            }
         | CONNECTION LIMIT opt_equal SignedIconst
            {
               return makeDefElem("connectionlimit", makeInteger($_[4]));
            }
         | OWNER opt_equal name
            {
               return makeDefElem("owner", makeString($_[3]));
            }
         | OWNER opt_equal DEFAULT
            {
               return makeDefElem("owner", NULL);
            }
      ;

/*
 *   Though the equals sign doesn't match other WITH options, pg_dump uses
 *   equals for backward compatibility, and it doesn't seem worth removing it.
 */
opt_equal:   '='                              {}
         | /*EMPTY*/                        {}
      ;


/*****************************************************************************
 *
 *      ALTER DATABASE
 *
 *****************************************************************************/

AlterDatabaseStmt:
         ALTER DATABASE database_name opt_with alterdb_opt_list
             {
               return SQL::Translator::Statement::AlterDatabase->new(
                  dbname => $_[3],
                  options => $_[5],
               );
             }
         | ALTER DATABASE database_name SET TABLESPACE name
             {
               return SQL::Translator::Statement::AlterDatabase->new(
                  dbname => $_[3],
                  options => lappend(makeDefElem("tablespace", makeString($_[6]))),
               );
             }
      ;

AlterDatabaseSetStmt:
         ALTER DATABASE database_name SetResetClause
            {
               return SQL::Translator::Statement::AlterDatabaseSet->new(
                  dbname => $_[3],
                  setstmt => $_[4],
               );
            }
      ;


alterdb_opt_list:
         alterdb_opt_list alterdb_opt_item      { lappend($_[1], $_[2]) }
         | /* EMPTY */                          { NIL }
      ;

alterdb_opt_item:
         CONNECTION LIMIT opt_equal SignedIconst
            {
               return makeDefElem("connectionlimit", makeInteger($_[4]));
            }
      ;


/*****************************************************************************
 *
 *      DROP DATABASE [ IF EXISTS ]
 *
 * This is implicitly CASCADE, no need for drop behavior
 *****************************************************************************/

DropdbStmt: DROP DATABASE database_name
            {
               return SQL::Translator::Statement::Dropdb->new(
                  dbname => $_[3],
                  missing_ok => FALSE,
               );
            }
         | DROP DATABASE IF EXISTS database_name
            {
               return SQL::Translator::Statement::Dropdb->new(
                  dbname => $_[5],
                  missing_ok => TRUE,
               );
            }
      ;


/*****************************************************************************
 *
 * Manipulate a domain
 *
 *****************************************************************************/

CreateDomainStmt:
         CREATE DOMAIN any_name opt_as Typename ColQualList
            {
               return SQL::Translator::Statement::CreateDomain->new(
                  domainname => $_[3],
                  typeName => $_[5],
               SplitColQualList($_[6], &n->constraints, &n->collClause,
                            yyscanner);
               );
            }
      ;

AlterDomainStmt:
         /* ALTER DOMAIN <domain> {SET DEFAULT <expr>|DROP DEFAULT} */
         ALTER DOMAIN any_name alter_column_default
            {
               return SQL::Translator::Statement::AlterDomain->new(
                  subtype => 'T',
                  typeName => $_[3],
                  def => $_[4],
               );
            }
         /* ALTER DOMAIN <domain> DROP NOT NULL */
         | ALTER DOMAIN any_name DROP NOT NULL
            {
               return SQL::Translator::Statement::AlterDomain->new(
                  subtype => 'N',
                  typeName => $_[3],
               );
            }
         /* ALTER DOMAIN <domain> SET NOT NULL */
         | ALTER DOMAIN any_name SET NOT NULL
            {
               return SQL::Translator::Statement::AlterDomain->new(
                  subtype => 'O',
                  typeName => $_[3],
               );
            }
         /* ALTER DOMAIN <domain> ADD CONSTRAINT ... */
         | ALTER DOMAIN any_name ADD TableConstraint
            {
               return SQL::Translator::Statement::AlterDomain->new(
                  subtype => 'C',
                  typeName => $_[3],
                  def => $_[5],
               );
            }
         /* ALTER DOMAIN <domain> DROP CONSTRAINT <name> [RESTRICT|CASCADE] */
         | ALTER DOMAIN any_name DROP CONSTRAINT name opt_drop_behavior
            {
               return SQL::Translator::Statement::AlterDomain->new(
                  subtype => 'X',
                  typeName => $_[3],
                  name => $_[6],
                  behavior => $_[7],
               );
            }
         ;

opt_as:      AS                            {}
         | /* EMPTY */                     {}
      ;


/*****************************************************************************
 *
 * Manipulate a text search dictionary or configuration
 *
 *****************************************************************************/

AlterTSDictionaryStmt:
         ALTER TEXT SEARCH DICTIONARY any_name definition
            {
               return SQL::Translator::Statement::AlterTSDictionary->new(
                  dictname => $_[5],
                  options => $_[6],
               );
            }
      ;

AlterTSConfigurationStmt:
         ALTER TEXT SEARCH CONFIGURATION any_name ADD MAPPING FOR name_list WITH any_name_list
            {
               return SQL::Translator::Statement::AlterTSConfiguration->new(
                  cfgname => $_[5],
                  tokentype => $_[9],
                  dicts => $_[11],
                  override => FALSE,
                  replace => FALSE,
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list WITH any_name_list
            {
               return SQL::Translator::Statement::AlterTSConfiguration->new(
                  cfgname => $_[5],
                  tokentype => $_[9],
                  dicts => $_[11],
                  override => TRUE,
                  replace => FALSE,
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING REPLACE any_name WITH any_name
            {
               return SQL::Translator::Statement::AlterTSConfiguration->new(
                  cfgname => $_[5],
                  tokentype => NIL,
                  dicts => lappend($_[9],$_[11]),
                  override => FALSE,
                  replace => TRUE,
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name ALTER MAPPING FOR name_list REPLACE any_name WITH any_name
            {
               return SQL::Translator::Statement::AlterTSConfiguration->new(
                  cfgname => $_[5],
                  tokentype => $_[9],
                  dicts => lappend($_[11],$_[13]),
                  override => FALSE,
                  replace => TRUE,
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name DROP MAPPING FOR name_list
            {
               return SQL::Translator::Statement::AlterTSConfiguration->new(
                  cfgname => $_[5],
                  tokentype => $_[9],
                  missing_ok => FALSE,
               );
            }
         | ALTER TEXT SEARCH CONFIGURATION any_name DROP MAPPING IF EXISTS FOR name_list
            {
               return SQL::Translator::Statement::AlterTSConfiguration->new(
                  cfgname => $_[5],
                  tokentype => $_[11],
                  missing_ok => TRUE,
               );
            }
      ;


/*****************************************************************************
 *
 * Manipulate a conversion
 *
 *      CREATE [DEFAULT] CONVERSION <conversion_name>
 *      FOR <encoding_name> TO <encoding_name> FROM <func_name>
 *
 *****************************************************************************/

CreateConversionStmt:
         CREATE opt_default CONVERSION any_name FOR Sconst
         TO Sconst FROM any_name
         {
           return SQL::Translator::Statement::CreateConversion->new(
              conversion_name => $_[4],
              for_encoding_name => $_[6],
              to_encoding_name => $_[8],
              func_name => $_[10],
              def => $_[2],
           );
         }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *            CLUSTER [VERBOSE] <qualified_name> [ USING <index_name> ]
 *            CLUSTER [VERBOSE]
 *            CLUSTER [VERBOSE] <index_name> ON <qualified_name> (for pre-8.3)
 *
 *****************************************************************************/

ClusterStmt:
         CLUSTER opt_verbose qualified_name cluster_index_specification
            {
                return SQL::Translator::Statement::Cluster->new(
                  relation => $_[3],
                  indexname => $_[4],
                  verbose => $_[2],
               );
            }
         | CLUSTER opt_verbose
             {
               return SQL::Translator::Statement::Cluster->new(
                  relation => NULL,
                  indexname => NULL,
                  verbose => $_[2],
               );
            }
         /* kept for pre-8.3 compatibility */
         | CLUSTER opt_verbose index_name ON qualified_name
            {
               return SQL::Translator::Statement::Cluster->new(
                  relation => $_[5],
                  indexname => $_[3],
                  verbose => $_[2],
               );
            }
      ;

cluster_index_specification:
         USING index_name      { $_[2] }
         | /*EMPTY*/            { NULL }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            VACUUM
 *            ANALYZE
 *
 *****************************************************************************/

VacuumStmt: VACUUM opt_full opt_freeze opt_verbose
            {
               return SQL::Translator::Statement::Analyze->new(
                  options => 
                     VACOPT_VACUUM |
                     $_[2] ? VACOPT_FULL : 0 |
                     $_[4] ? VACOPT_VERBOSE : 0,
                  freeze_min_age   => $_[3] ? 0 : -1,
                  freeze_table_age => $_[3] ? 0 : -1,
                  relation => NULL,
                  va_cols  => NIL,
               );
            }
         | VACUUM opt_full opt_freeze opt_verbose qualified_name
            {
               return SQL::Translator::Statement::Analyze->new(
                  options => 
                     VACOPT_VACUUM |
                     $_[2] ? VACOPT_FULL : 0 |
                     $_[4] ? VACOPT_VERBOSE : 0,
                  freeze_min_age   => $_[3] ? 0 : -1,
                  freeze_table_age => $_[3] ? 0 : -1,
                  relation => $_[5],
                  va_cols  => NIL,
               );
            }
         | VACUUM opt_full opt_freeze opt_verbose AnalyzeStmt
            {
               $_[5]->_options( 
                     VACOPT_VACUUM |
                     $_[2] ? VACOPT_FULL : 0 |
                     $_[4] ? VACOPT_VERBOSE : 0
               );
               $_[5]->_freeze_min_age  ($_[3] ? 0 : -1);
               $_[5]->_freeze_table_age($_[3] ? 0 : -1);
               return $_[5];
            }
         | VACUUM '(' vacuum_option_list ')'
            {
               my $opt = VACOPT_VACUUM | $_[3];
               return SQL::Translator::Statement::Analyze->new(
                  options => $opt,
                  freeze_min_age   => ($opt & VACOPT_FREEZE) ? 0 : -1,
                  freeze_table_age => ($opt & VACOPT_FREEZE) ? 0 : -1,
                  relation => NULL,
                  va_cols  => NIL,
               );
            }
         | VACUUM '(' vacuum_option_list ')' qualified_name opt_name_list
            {
               my $opt = VACOPT_VACUUM |
                         $_[3] |
                         $_[6] ? VACOPT_ANALYZE : 0;  #* implies analyze
               return SQL::Translator::Statement::Analyze->new(
                  options => $opt,
                  freeze_min_age   => ($opt & VACOPT_FREEZE) ? 0 : -1,
                  freeze_table_age => ($opt & VACOPT_FREEZE) ? 0 : -1,
                  relation => $_[5],
                  va_cols  => $_[6],
               );
            }
      ;

vacuum_option_list:
         vacuum_option_elem                               { $_[1] }
         | vacuum_option_list ',' vacuum_option_elem      { $_[1] | $_[3] }
      ;

vacuum_option_elem:
         analyze_keyword      { VACOPT_ANALYZE }
         | VERBOSE            { VACOPT_VERBOSE }
         | FREEZE             { VACOPT_FREEZE  }
         | FULL               { VACOPT_FULL    }
      ;

AnalyzeStmt:
         analyze_keyword opt_verbose
            {
               return SQL::Translator::Statement::Analyze->new(
                  options => 
                     VACOPT_ANALYZE |
                     $_[2] ? VACOPT_VERBOSE : 0,
                  freeze_min_age   => -1,
                  freeze_table_age => -1,
                  relation => NULL,
                  va_cols  => NIL,
               );
            }
         | analyze_keyword opt_verbose qualified_name opt_name_list
            {
               return SQL::Translator::Statement::Analyze->new(
                  options => 
                     VACOPT_ANALYZE |
                     $_[2] ? VACOPT_VERBOSE : 0,
                  freeze_min_age   => -1,
                  freeze_table_age => -1,
                  relation => $_[3],
                  va_cols  => $_[4],
               );
            }
      ;

analyze_keyword:
         ANALYZE                           {}
         | ANALYSE /* British */           {}
      ;

opt_verbose:
         VERBOSE                           { TRUE  }
         | /*EMPTY*/                       { FALSE }
      ;

opt_full:   FULL                           { TRUE  }
         | /*EMPTY*/                       { FALSE }
      ;

opt_freeze: FREEZE                         { TRUE  }
         | /*EMPTY*/                       { FALSE }
      ;

opt_name_list:
         '(' name_list ')'                 { $_[2] }
         | /*EMPTY*/                       { NIL   }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            EXPLAIN [ANALYZE] [VERBOSE] query
 *            EXPLAIN ( options ) query
 *
 *****************************************************************************/

ExplainStmt:
      EXPLAIN ExplainableStmt
            {
               return SQL::Translator::Statement::Explain->new(
                  query => $_[2],
                  options => NIL,
               );
            }
      | EXPLAIN analyze_keyword opt_verbose ExplainableStmt
            {
               return SQL::Translator::Statement::Explain->new(
                  query => $_[4],
                  options => lappend(makeDefElem(
                     $_[3] ? "analyze" : "verbose"
                  , NULL)),
               );
            }
      | EXPLAIN VERBOSE ExplainableStmt
            {
               return SQL::Translator::Statement::Explain->new(
                  query => $_[3],
                  options => lappend(makeDefElem("verbose", NULL)),
               );
            }
      | EXPLAIN '(' explain_option_list ')' ExplainableStmt
            {
               return SQL::Translator::Statement::Explain->new(
                  query => $_[5],
                  options => $_[3],
               );
            }
      ;

ExplainableStmt:
         SelectStmt
         | InsertStmt
         | UpdateStmt
         | DeleteStmt
         | DeclareCursorStmt
         | CreateAsStmt
         | ExecuteStmt               /* by default all are $$=$_[1] */
      ;

explain_option_list:
         explain_option_elem
            {
               return lappend($_[1]);
            }
         | explain_option_list ',' explain_option_elem
            {
               return lappend($_[1], $_[3]);
            }
      ;

explain_option_elem:
         explain_option_name explain_option_arg
            {
               return makeDefElem($_[1], $_[2]);
            }
      ;

explain_option_name:
         ColId               { $_[1] }
         | analyze_keyword   { "analyze" }
         | VERBOSE           { "verbose" }
      ;

explain_option_arg:
         opt_boolean_or_string   { makeString($_[1]) }
         | NumericOnly           { $_[1] }
         | /* EMPTY */           { NULL  }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *            PREPARE <plan_name> [(args, ...)] AS <query>
 *
 *****************************************************************************/

PrepareStmt: PREPARE name prep_type_clause AS PreparableStmt
            {
               return SQL::Translator::Statement::Prepare->new(
                  name => $_[2],
                  argtypes => $_[3],
                  query => $_[5],
               );
            }
      ;

prep_type_clause: '(' type_list ')'         { $_[2] }
            | /* EMPTY */                   { NIL }
      ;

PreparableStmt:
         SelectStmt
         | InsertStmt
         | UpdateStmt
         | DeleteStmt               /* by default all are $$=$_[1] */
      ;

/*****************************************************************************
 *
 * EXECUTE <plan_name> [(params, ...)]
 * CREATE TABLE <name> AS EXECUTE <plan_name> [(params, ...)]
 *
 *****************************************************************************/

ExecuteStmt: EXECUTE name execute_param_clause
            {
               return SQL::Translator::Statement::Execute->new(
                  name => $_[2],
                  params => $_[3],
                  into => NULL,
               );
            }
         | CREATE OptTemp TABLE create_as_target AS
            EXECUTE name execute_param_clause
            {
               $_[4]->rel->_relpersistence($_[2]);
               return SQL::Translator::Statement::Execute->new(
                  name => $_[7],
                  params => $_[8],
                  into => $_[4],
               );
            }
      ;

execute_param_clause: '(' expr_list ')'    { $_[2] }
               | /* EMPTY */               { NULL  }
               ;

/*****************************************************************************
 *
 *      QUERY:
 *            DEALLOCATE [PREPARE] <plan_name>
 *
 *****************************************************************************/

DeallocateStmt: DEALLOCATE name
               {
                  return SQL::Translator::Statement::Deallocate->new(
                     name => $_[2],
                  );
               }
            | DEALLOCATE PREPARE name
               {
                  return SQL::Translator::Statement::Deallocate->new(
                     name => $_[3],
                  );
               }
            | DEALLOCATE ALL
               {
                  return SQL::Translator::Statement::Deallocate->new(
                     name => NULL,
                  );
               }
            | DEALLOCATE PREPARE ALL
               {
                  return SQL::Translator::Statement::Deallocate->new(
                     name => NULL,
                  );
               }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *            INSERT STATEMENTS
 *
 *****************************************************************************/

InsertStmt:
         opt_with_clause INSERT INTO qualified_name insert_rest returning_clause
            {
               $_[5]->_relation($_[4]);
               $_[5]->_returningList($_[6]);
               $_[5]->_withClause($_[1]);
               return $_[5];
            }
      ;

insert_rest:
         SelectStmt
            {
               return SQL::Translator::Statement::Insert->new(
                  cols       => NIL,
                  selectStmt => $_[1],
               );
            }
         | '(' insert_column_list ')' SelectStmt
            {
               return SQL::Translator::Statement::Insert->new(
                  cols       => $_[2],
                  selectStmt => $_[4],
               );
            }
         | DEFAULT VALUES
            {
               return SQL::Translator::Statement::Insert->new(
                  cols       => NIL,
                  selectStmt => NULL,
               );
            }
      ;

insert_column_list:
         insert_column_item
               { lappend($_[1]) }
         | insert_column_list ',' insert_column_item
               { lappend($_[1], $_[3]) }
      ;

insert_column_item:
         ColId opt_indirection
            {
               return SQL::Translator::Statement::ResultTarget->new(
                  name        => $_[1],
                  indirection => check_indirection($_[2]),
                  val         => NULL,
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

returning_clause:
         RETURNING target_list      { $_[2] }
         | /* EMPTY */              { NIL   }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            DELETE STATEMENTS
 *
 *****************************************************************************/

DeleteStmt: opt_with_clause DELETE FROM relation_expr_opt_alias
         using_clause where_or_current_clause returning_clause
            {
               return SQL::Translator::Statement::Delete->new(
                  relation => $_[4],
                  usingClause => $_[5],
                  whereClause => $_[6],
                  returningList => $_[7],
                  withClause => $_[1],
               );
            }
      ;

using_clause:
             USING from_list                { $_[2] }
         | /*EMPTY*/                        { NIL   }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            LOCK TABLE
 *
 *****************************************************************************/

LockStmt:   LOCK opt_table relation_expr_list opt_lock opt_nowait
            {
               return SQL::Translator::Statement::Lock->new(
                  relations => $_[3],
                  mode => $_[4],
                  nowait => $_[5],
               );
            }
      ;

opt_lock:   IN lock_type MODE         { $_[2] }
         | /*EMPTY*/                  { AccessExclusiveLock }
      ;

lock_type:   ACCESS SHARE             { AccessShareLock          }
         | ROW SHARE                  { RowShareLock             }
         | ROW EXCLUSIVE              { RowExclusiveLock         }
         | SHARE UPDATE EXCLUSIVE     { ShareUpdateExclusiveLock }
         | SHARE                      { ShareLock                }
         | SHARE ROW EXCLUSIVE        { ShareRowExclusiveLock    }
         | EXCLUSIVE                  { ExclusiveLock            }
         | ACCESS EXCLUSIVE           { AccessExclusiveLock      }
      ;

opt_nowait:   NOWAIT                  { TRUE  }
         | /*EMPTY*/                  { FALSE }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            UpdateStmt (UPDATE)
 *
 *****************************************************************************/

UpdateStmt: opt_with_clause UPDATE relation_expr_opt_alias
         SET set_clause_list
         from_clause
         where_or_current_clause
         returning_clause
            {
               return SQL::Translator::Statement::Update->new(
                  relation      => $_[3],
                  targetList    => $_[5],
                  fromClause    => $_[6],
                  whereClause   => $_[7],
                  returningList => $_[8],
                  withClause    => $_[1],
               );
            }
      ;

set_clause_list:
         set_clause                         { $_[1] }
         | set_clause_list ',' set_clause   { lappend($_[1],$_[3]) }
      ;

set_clause:
         single_set_clause                  { lappend($_[1]) }
         | multiple_set_clause              { $_[1] }
      ;

single_set_clause:
         set_target '=' ctext_expr
            {
               $_[1]->_val($_[3]);
               return $_[1];
            }
      ;

multiple_set_clause:
         '(' set_target_list ')' '=' ctext_row
            {
               #* Break the ctext_row apart, merge individual expressions
               #* into the destination ResTargets.  XXX this approach
               #* cannot work for general row expressions as sources.
               unless (@{$_[2]} == @{$_[5]}) {
                  $_[0]->ereport(ERROR,
                        ERRCODE_SYNTAX_ERROR,
                         "number of columns does not match number of values",
                         $_[0]->YYLLoc($_[1], 1));
               }
               pairwise {
                  $a->val($b);
               } @{$_[2]}, @{$_[5]};

               return $_[2];
            }
      ;

set_target:
         ColId opt_indirection
            {
               return SQL::Translator::Statement::ResultTarget->new(
                  name        => $_[1],
                  indirection => check_indirection($_[2]),
                  val         => NULL,  #* upper production sets this
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

set_target_list:
         set_target                            { lappend($_[1]) }
         | set_target_list ',' set_target      { lappend($_[1],$_[3]) }
      ;


/*****************************************************************************
 *
 *      QUERY:
 *            CURSOR STATEMENTS
 *
 *****************************************************************************/
DeclareCursorStmt: DECLARE cursor_name cursor_options CURSOR opt_hold FOR SelectStmt
            {
               return SQL::Translator::Statement::DeclareCursor->new(
                  portalname => $_[2],
                  #* currently we always set FAST_PLAN option
                  options => $_[3] | $_[5] | CURSOR_OPT_FAST_PLAN,
                  query => $_[7],
               );
            }
      ;

cursor_name:   name                     { $_[1] }
      ;

cursor_options: /*EMPTY*/               { 0 }
         | cursor_options NO SCROLL     { $_[1] | CURSOR_OPT_NO_SCROLL   }
         | cursor_options SCROLL        { $_[1] | CURSOR_OPT_SCROLL      }
         | cursor_options BINARY        { $_[1] | CURSOR_OPT_BINARY      }
         | cursor_options INSENSITIVE   { $_[1] | CURSOR_OPT_INSENSITIVE }
      ;

opt_hold: /* EMPTY */                 { 0 }
         | WITH HOLD                  { CURSOR_OPT_HOLD }
         | WITHOUT HOLD               { 0 }
      ;

/*****************************************************************************
 *
 *      QUERY:
 *            SELECT STATEMENTS
 *
 *****************************************************************************/

/* A complete SELECT statement looks like this.
 *
 * The rule returns either a single SelectStmt node or a tree of them,
 * representing a set-operation tree.
 *
 * There is an ambiguity when a sub-SELECT is within an a_expr and there
 * are excess parentheses: do the parentheses belong to the sub-SELECT or
 * to the surrounding a_expr?  We don't really care, but bison wants to know.
 * To resolve the ambiguity, we are careful to define the grammar so that
 * the decision is staved off as long as possible: as long as we can keep
 * absorbing parentheses into the sub-SELECT, we will do so, and only when
 * it's no longer possible to do that will we decide that parens belong to
 * the expression.   For example, in "SELECT (((SELECT 2)) + 3)" the extra
 * parentheses are treated as part of the sub-select.  The necessity of doing
 * it that way is shown by "SELECT (((SELECT 2)) UNION SELECT 2)".   Had we
 * parsed "((SELECT 2))" as an a_expr, it'd be too late to go back to the
 * SELECT viewpoint when we see the UNION.
 *
 * This approach is implemented by defining a nonterminal select_with_parens,
 * which represents a SELECT with at least one outer layer of parentheses,
 * and being careful to use select_with_parens, never '(' SelectStmt ')',
 * in the expression grammar.  We will then have shift-reduce conflicts
 * which we can resolve in favor of always treating '(' <select> ')' as
 * a select_with_parens.  To resolve the conflicts, the productions that
 * conflict with the select_with_parens productions are manually given
 * precedences lower than the precedence of ')', thereby ensuring that we
 * shift ')' (and then reduce to select_with_parens) rather than trying to
 * reduce the inner <select> nonterminal to something else.  We use UMINUS
 * precedence for this, which is a fairly arbitrary choice.
 *
 * To be able to define select_with_parens itself without ambiguity, we need
 * a nonterminal select_no_parens that represents a SELECT structure with no
 * outermost parentheses.  This is a little bit tedious, but it works.
 *
 * In non-expression contexts, we use SelectStmt which can represent a SELECT
 * with or without outer parentheses.
 */

SelectStmt: select_no_parens       %prec UMINUS
         | select_with_parens      %prec UMINUS
      ;

select_with_parens:
         '(' select_no_parens ')'             { $_[2] }
         | '(' select_with_parens ')'         { $_[2] }
      ;

/*
 * This rule parses the equivalent of the standard's <query expression>.
 * The duplicative productions are annoying, but hard to get rid of without
 * creating shift/reduce conflicts.
 *
 *   FOR UPDATE/SHARE may be before or after LIMIT/OFFSET.
 *   In <=7.2.X, LIMIT/OFFSET had to be after FOR UPDATE
 *   We now support both orderings, but prefer LIMIT/OFFSET before FOR UPDATE/SHARE
 *   2002-08-28 bjm
 */
select_no_parens:
         simple_select                  { $_[1] }
         | select_clause sort_clause
            {
               insertSelectOptions($_[1], $_[2], NIL, NULL, NULL, NULL);
               return $_[1];
            }
         | select_clause opt_sort_clause for_locking_clause opt_select_limit
            {
               insertSelectOptions($_[1], $_[2], $_[3], $_[4]->[0,1], NULL);
               return $_[1];
            }
         | select_clause opt_sort_clause select_limit opt_for_locking_clause
            {
               insertSelectOptions($_[1], $_[2], $_[4], $_[3]->[0,1], NULL);
               return $_[1];
            }
         | with_clause select_clause
            {
               insertSelectOptions($_[2], NULL, NIL, NULL, NULL, $_[1]);
               return $_[2];
            }
         | with_clause select_clause sort_clause
            {
               insertSelectOptions($_[2], $_[3], NIL, NULL, NULL, $_[1]);
               return $_[2];
            }
         | with_clause select_clause opt_sort_clause for_locking_clause opt_select_limit
            {
               insertSelectOptions($_[2], $_[3], $_[4], $_[5]->[0,1], $_[1]);
               return $_[2];
            }
         | with_clause select_clause opt_sort_clause select_limit opt_for_locking_clause
            {
               insertSelectOptions($_[2], $_[3], $_[5], $_[4]->[0,1], $_[1]);
               return $_[2];
            }
      ;

select_clause:
         simple_select                     { $_[1] }
         | select_with_parens              { $_[1] }
      ;

/*
 * This rule parses SELECT statements that can appear within set operations,
 * including UNION, INTERSECT and EXCEPT.  '(' and ')' can be used to specify
 * the ordering of the set operations.   Without '(' and ')' we want the
 * operations to be ordered per the precedence specs at the head of this file.
 *
 * As with select_no_parens, simple_select cannot have outer parentheses,
 * but can have parenthesized subclauses.
 *
 * Note that sort clauses cannot be included at this level --- SQL92 requires
 *      SELECT foo UNION SELECT bar ORDER BY baz
 * to be parsed as
 *      (SELECT foo UNION SELECT bar) ORDER BY baz
 * not
 *      SELECT foo UNION (SELECT bar ORDER BY baz)
 * Likewise for WITH, FOR UPDATE and LIMIT.  Therefore, those clauses are
 * described as part of the select_no_parens production, not simple_select.
 * This does not limit functionality, because you can reintroduce these
 * clauses inside parentheses.
 *
 * NOTE: only the leftmost component SelectStmt should have INTO.
 * However, this is not checked by the grammar; parse analysis must check it.
 */
simple_select:
         SELECT opt_distinct target_list
         into_clause from_clause where_clause
         group_clause having_clause window_clause
            {
               return SQL::Translator::Statement::Select->new(
                  distinctClause => $_[2],
                  targetList     => $_[3],
                  intoClause     => $_[4],
                  fromClause     => $_[5],
                  whereClause    => $_[6],
                  groupClause    => $_[7],
                  havingClause   => $_[8],
                  windowClause   => $_[9],
               );
            }
         | values_clause                     { $_[1] }
         | TABLE relation_expr
            /* same as SELECT * FROM relation_expr */
            {
               return SQL::Translator::Statement::Select->new(
                  targetList => lappend(
                     SQL::Translator::Statement::ResultTarget->new(
                        name        => NULL,
                        indirection => NIL,
                        location    => NULL,
                        val = SQL::Translator::Statement::Column::Reference->new(
                           fields   => lappend(makeNode(A_Star)),
                           location => NULL,
                        ),
                     ),
                  ),
                  fromClause => lappend($_[2]),
               );
            }
         | select_clause UNION opt_all select_clause
            {
               return makeSetOp(SETOP_UNION, $_[3], $_[1], $_[4]);
            }
         | select_clause INTERSECT opt_all select_clause
            {
               return makeSetOp(SETOP_INTERSECT, $_[3], $_[1], $_[4]);
            }
         | select_clause EXCEPT opt_all select_clause
            {
               return makeSetOp(SETOP_EXCEPT, $_[3], $_[1], $_[4]);
            }
      ;

/*
 * SQL standard WITH clause looks like:
 *
 * WITH [ RECURSIVE ] <query name> [ (<column>,...) ]
 *      AS (query) [ SEARCH or CYCLE clause ]
 *
 * We don't currently support the SEARCH or CYCLE clause.
 */
with_clause:
      WITH cte_list
         {
            return SQL::Translator::Statement::WithClause->new(
               ctes      => $_[2],
               recursive => FALSE,
               location  => $_[0]->YYLLoc($_[1], 1),
            );
         }
      | WITH RECURSIVE cte_list
         {
            return SQL::Translator::Statement::WithClause->new(
               ctes      => $_[3],
               recursive => TRUE,
               location  => $_[0]->YYLLoc($_[1], 1),
            );
         }
      ;

cte_list:
      common_table_expr                  { lappend($_[1]) }
      | cte_list ',' common_table_expr   { lappend($_[1], $_[3]) }
      ;

common_table_expr:  name opt_name_list AS '(' PreparableStmt ')'
         {
            return SQL::Translator::Statement::CommonTableExpr->new(
               ctename       => $_[1],
               aliascolnames => $_[2],
               ctequery      => $_[5],
               location      => $_[0]->YYLLoc($_[1], 1),
            );
         }
      ;

opt_with_clause:
      with_clause                        { $_[1] }
      | /*EMPTY*/                        { NULL }
      ;

into_clause:
         INTO OptTempTableName
            {
               return SQL::Translator::Statement::IntoClause->new(
                  rel            => $_[2],
                  colNames       => NIL,
                  options        => NIL,
                  onCommit       => ONCOMMIT_NOOP,
                  tableSpaceName => NULL,
               );
            }
         | /*EMPTY*/
            { NULL }
      ;

/*
 * Redundancy here is needed to avoid shift/reduce conflicts,
 * since TEMP is not a reserved word.  See also OptTemp.
 */
OptTempTableName:
         TEMPORARY opt_table qualified_name
            {
               $_[3]->_relpersistence(RELPERSISTENCE_TEMP);
               return $_[3];
            }
         | TEMP opt_table qualified_name
            {
               $_[3]->_relpersistence(RELPERSISTENCE_TEMP);
               return $_[3];
            }
         | LOCAL TEMPORARY opt_table qualified_name
            {
               $_[4]->_relpersistence(RELPERSISTENCE_TEMP);
               return $_[4];
            }
         | LOCAL TEMP opt_table qualified_name
            {
               $_[4]->_relpersistence(RELPERSISTENCE_TEMP);
               return $_[4];
            }
         | GLOBAL TEMPORARY opt_table qualified_name
            {
               $_[4]->_relpersistence(RELPERSISTENCE_TEMP);
               return $_[4];
            }
         | GLOBAL TEMP opt_table qualified_name
            {
               $_[4]->_relpersistence(RELPERSISTENCE_TEMP);
               return $_[4];
            }
         | UNLOGGED opt_table qualified_name
            {
               $_[3]->_relpersistence(RELPERSISTENCE_UNLOGGED);
               return $_[3];
            }
         | TABLE qualified_name
            {
               $_[2]->_relpersistence(RELPERSISTENCE_PERMANENT);
               return $_[2];
            }
         | qualified_name
            {
               $_[1]->_relpersistence(RELPERSISTENCE_PERMANENT);
               return $_[1];
            }
      ;

opt_table:   TABLE                          {}
         | /*EMPTY*/                        {}
      ;

opt_all:   ALL                              { TRUE  }
         | DISTINCT                         { FALSE }
         | /*EMPTY*/                        { FALSE }
      ;

/* We use (NIL) as a placeholder to indicate that all target expressions
 * should be placed in the DISTINCT list during parsetree analysis.
 */
opt_distinct:
         DISTINCT                        { lappend(NIL) }
         | DISTINCT ON '(' expr_list ')' { $_[4] }
         | ALL                           { NIL   }
         | /*EMPTY*/                     { NIL   }
      ;

opt_sort_clause:
         sort_clause                        { $_[1] }
         | /*EMPTY*/                        { NIL   }
      ;

sort_clause:
         ORDER BY sortby_list               { $_[3] }
      ;

sortby_list:
         sortby                             { lappend($_[1]) }
         | sortby_list ',' sortby           { lappend($_[1], $_[3]) }
      ;

sortby:      a_expr USING qual_all_Op opt_nulls_order
            {
               return SQL::Translator::Statement::SortBy->new(
                  node         => $_[1],
                  sortby_dir   => SORTBY_USING,
                  sortby_nulls => $_[4],
                  useOp        => $_[3],
                  location     => $_[0]->YYLLoc($_[3], 3),
               );
            }
         | a_expr opt_asc_desc opt_nulls_order
            {
               return SQL::Translator::Statement::SortBy->new(
                  node         => $_[1],
                  sortby_dir   => $_[2],
                  sortby_nulls => $_[3],
                  useOp        => NIL,
                  location     => NULL,  #* no operator
               );
            }
      ;


select_limit:
         limit_clause offset_clause      { lappend($_[2], $_[1]) }
         | offset_clause limit_clause    { lappend($_[1], $_[2]) }
         | limit_clause                  { ref $_[1] eq 'ARRAY' ? $_[1] : lappend(NULL, $_[1]) }  /* Changed to support LimitYX */
         | offset_clause                 { lappend($_[1], NULL) }
      ;

opt_select_limit:
         select_limit                    { $_[1] }
         | /* EMPTY */                   { lappend(NULL,NULL) }
      ;

limit_clause:
         LIMIT select_limit_value
            { $_[2] }
         | LIMIT select_limit_value ',' select_offset_value
         /* Disabled because it was too confusing, bjm 2002-02-18 */
         /*# SQLite supports this format, so we'll go ahead and re-enable this.
          *# This would be 'LimitYX' in SQL::Abstract::Limit.
          */
            {
               lappend($_[1], $_[3]);
            }
         /* SQL:2008 syntax */
         | FETCH first_or_next opt_select_fetch_first_value row_or_rows ONLY
            { $_[3] }
      ;

offset_clause:
         OFFSET select_offset_value
            { $_[2] }
         /* SQL:2008 syntax */
         | OFFSET select_offset_value2 row_or_rows
            { $_[2] }
      ;

select_limit_value:
         a_expr                           { $_[1] }
         | ALL
            {
               /* LIMIT ALL is represented as a NULL constant */
               return makeNullAConst($_[0]->YYLLoc($_[1], 1));
            }
      ;

select_offset_value:
         a_expr                           { $_[1] }
      ;

/*
 * Allowing full expressions without parentheses causes various parsing
 * problems with the trailing ROW/ROWS key words.  SQL only calls for
 * constants, so we allow the rest only with parentheses.  If omitted,
 * default to 1.
 */
opt_select_fetch_first_value:
         SignedIconst                  { makeIntConst($_[1], $_[0]->YYLLoc($_[1], 1)) }
         | '(' a_expr ')'              { $_[2] }
         | /*EMPTY*/                   { makeIntConst(1, -1) }
      ;

/*
 * Again, the trailing ROW/ROWS in this case prevent the full expression
 * syntax.  c_expr is the best we can do.
 */
select_offset_value2:
         c_expr                            { $_[1] }
      ;

/* noise words */
row_or_rows: ROW                           { 0 }
         | ROWS                            { 0 }
      ;

first_or_next: FIRST                       { 0 }
         | NEXT                            { 0 }
      ;


group_clause:
         GROUP BY expr_list                { $_[3] }
         | /*EMPTY*/                       { NIL   }
      ;

having_clause:
         HAVING a_expr                     { $_[2] }
         | /*EMPTY*/                       { NULL  }
      ;

for_locking_clause:
         for_locking_items                 { $_[1] }
         | FOR READ ONLY                   { NIL   }
      ;

opt_for_locking_clause:
         for_locking_clause                { $_[1] }
         | /* EMPTY */                     { NIL   }
      ;

for_locking_items:
         for_locking_item                       { lappend($_[1]) }
         | for_locking_items for_locking_item   { lappend($_[1], $_[2]) }
      ;

for_locking_item:
         FOR UPDATE locked_rels_list opt_nowait
            {
               return SQL::Translator::Statement::LockingClause->new(
                  lockedRels => $_[3],
                  forUpdate  => TRUE,
                  noWait     => $_[4],
               );
            }
         | FOR SHARE locked_rels_list opt_nowait
            {
               return SQL::Translator::Statement::LockingClause->new(
                  lockedRels => $_[3],
                  forUpdate  => FALSE,
                  noWait     => $_[4],
               );
            }
      ;

locked_rels_list:
         OF qualified_name_list            { $_[2] }
         | /* EMPTY */                     { NIL   }
      ;


values_clause:
         VALUES ctext_row
            {
               return SQL::Translator::Statement::Select->new(
                  valuesLists => lappend($_[2]),
               );
            }
         | values_clause ',' ctext_row
            {
               $_[1]->valuesLists( lappend($_[1]->valuesLists, $_[3]) );
               return $_[1];
            }
      ;


/*****************************************************************************
 *
 *   clauses common to all Optimizable Stmts:
 *      from_clause      - allow list of both JOIN expressions and table names
 *      where_clause   - qualifications for joins or restrictions
 *
 *****************************************************************************/

from_clause:
         FROM from_list                     { $_[2] }
         | /*EMPTY*/                        { NULL  }
      ;

from_list:
         table_ref                          { lappend($_[1]) }
         | from_list ',' table_ref          { lappend($_[1], $_[3]) }
      ;

/*
 * table_ref is where an alias clause can be attached.   Note we cannot make
 * alias_clause have an empty production because that causes parse conflicts
 * between table_ref := '(' joined_table ')' alias_clause
 * and joined_table := '(' joined_table ')'.  So, we must have the
 * redundant-looking productions here instead.
 */
table_ref:   relation_expr
            {
               return $_[1];
            }
         | relation_expr alias_clause
            {
               $_[1]->alias = $_[2];
               return $_[1];
            }
         | func_table
            {
               return SQL::Translator::Statement::Range::Function->new(
                  funccallnode => $_[1],
                  coldeflist   => NIL,
               );
            }
         | func_table alias_clause
            {
               return SQL::Translator::Statement::Range::Function->new(
                  funccallnode => $_[1],
                  alias        => $_[2],
                  coldeflist   => NIL,
               );
            }
         | func_table AS '(' TableFuncElementList ')'
            {
               return SQL::Translator::Statement::Range::Function->new(
                  funccallnode => $_[1],
                  coldeflist   => $_[4],
               );
            }
         | func_table AS ColId '(' TableFuncElementList ')'
            {
               return SQL::Translator::Statement::Range::Function->new(
                  funccallnode => $_[1],
                  alias => SQL::Translator::Statement::Alias->new(
                     aliasname => $_[3]
                  ),
                  coldeflist   => $_[5],
               );
            }
         | func_table ColId '(' TableFuncElementList ')'
            {
               return SQL::Translator::Statement::Range::Function->new(
                  funccallnode => $_[1],
                  alias => SQL::Translator::Statement::Alias->new(
                     aliasname => $_[2]
                  ),
                  coldeflist   => $_[4],
               );
            }
         | select_with_parens
            {
               /*
                * The SQL spec does not permit a subselect
                * (<derived_table>) without an alias clause,
                * so we don't either.  This avoids the problem
                * of needing to invent a unique refname for it.
                * That could be surmounted if there's sufficient
                * popular demand, but for now let's just implement
                * the spec and see if anyone complains.
                * However, it does seem like a good idea to emit
                * an error message that's better than "syntax error".
                */
               $_[0]->ereport(ERROR,
                     ERRCODE_SYNTAX_ERROR,
                     ($_[1]->isa('SQL::Translator::Statement::Select') && $_[1]->valuesLists) ? (
                        "VALUES in FROM must have an alias",
                        "For example, FROM (VALUES ...) [AS] foo.",
                     ) : (
                        "Subquery in FROM must have an alias",
                        "For example, FROM (SELECT ...) [AS] foo.",
                     )
                     $_[0]->YYLLoc($_[1], 1));
               return undef;
            }
         | select_with_parens alias_clause
            {
               return SQL::Translator::Statement::Range::SubSelect->new(
                  subquery => $_[1],
                  alias => $_[2],
               );
            }
         | joined_table
            {
               return $_[1];
            }
         | '(' joined_table ')' alias_clause
            {
               $_[2]->alias = $_[4];
               return $_[2];
            }
      ;


/*
 * It may seem silly to separate joined_table from table_ref, but there is
 * method in SQL92's madness: if you don't do it this way you get reduce-
 * reduce conflicts, because it's not clear to the parser generator whether
 * to expect alias_clause after ')' or not.  For the same reason we must
 * treat 'JOIN' and 'join_type JOIN' separately, rather than allowing
 * join_type to expand to empty; if we try it, the parser generator can't
 * figure out when to reduce an empty join_type right after table_ref.
 *
 * Note that a CROSS JOIN is the same as an unqualified
 * INNER JOIN, and an INNER JOIN/ON has the same shape
 * but a qualification expression to limit membership.
 * A NATURAL JOIN implicitly matches column names between
 * tables and the shape is determined by which columns are
 * in common. We'll collect columns during the later transformations.
 */

joined_table:
         '(' joined_table ')'
            {
               return $_[2];
            }
         | table_ref CROSS JOIN table_ref
            /* CROSS JOIN is same as unqualified inner join */
            {
               return SQL::Translator::Statement::JoinExpr->new(
                  jointype => JOIN_INNER,
                  isNatural => FALSE,
                  larg => $_[1],
                  rarg => $_[4],
                  usingClause => NIL,
                  quals => NULL,
               );
            }
         | table_ref join_type JOIN table_ref join_qual
            {
               return SQL::Translator::Statement::JoinExpr->new(
                  jointype => $_[2],
                  isNatural => FALSE,
                  larg => $_[1],
                  rarg => $_[4],
                  (defined $_[5] && $_[5]->isa('SQL::Translator::Statement::List')) ? (
                     usingClause => $_[5],  #* USING clause
                  ) : (
                     quals => $_[5],        #* ON clause
                  ),
               );
            }
         | table_ref JOIN table_ref join_qual
            /* letting join_type reduce to empty doesn't work */
            {
               return SQL::Translator::Statement::JoinExpr->new(
                  jointype => JOIN_INNER,
                  isNatural => FALSE,
                  larg => $_[1],
                  rarg => $_[3],
                  (defined $_[4] && $_[4]->isa('SQL::Translator::Statement::List')) ? (
                     usingClause => $_[4],  #* USING clause
                  ) : (
                     quals => $_[4],        #* ON clause
                  ),
               );
            }
         | table_ref NATURAL join_type JOIN table_ref
            {
               return SQL::Translator::Statement::JoinExpr->new(
                  jointype => $_[3],
                  isNatural => TRUE,
                  larg => $_[1],
                  rarg => $_[5],
                  usingClause => NIL,  #* figure out which columns later...
                  quals => NULL,       #* fill later
               );
            }
         | table_ref NATURAL JOIN table_ref
            /* letting join_type reduce to empty doesn't work */
            {
               return SQL::Translator::Statement::JoinExpr->new(
                  jointype => JOIN_INNER,
                  isNatural => TRUE,
                  larg => $_[1],
                  rarg => $_[4],
                  usingClause => NIL,  #* figure out which columns later...
                  quals => NULL,       #* fill later
               );
            }
      ;

alias_clause:
         AS ColId '(' name_list ')'
            {
               return SQL::Translator::Statement::Alias->new(
                  aliasname => $_[2],
                  colnames  => $_[4],
               );
            }
         | AS ColId
            {
               return SQL::Translator::Statement::Alias->new(
                  aliasname => $_[2],
               );
            }
         | ColId '(' name_list ')'
            {
               return SQL::Translator::Statement::Alias->new(
                  aliasname => $_[1],
                  colnames  => $_[3],
               );
            }
         | ColId
            {
               return SQL::Translator::Statement::Alias->new(
                  aliasname => $_[1],
               );
            }
      ;

join_type:   FULL join_outer                { JOIN_FULL }
         | LEFT join_outer                  { JOIN_LEFT }
         | RIGHT join_outer                 { JOIN_RIGHT }
         | INNER                            { JOIN_INNER }
      ;

/* OUTER is just noise... */
join_outer: OUTER                           { NULL }
         | /*EMPTY*/                        { NULL }
      ;

/* JOIN qualification clauses
 * Possibilities are:
 *   USING ( column list ) allows only unqualified column names,
 *                    which must match between tables.
 *   ON expr allows more general qualifications.
 *
 * We return USING as a List node, while an ON-expr will not be a List.
 */

join_qual:   USING '(' name_list ')'        { $_[3] }
         | ON a_expr                        { $_[2] }
      ;


relation_expr:
         qualified_name
            /* default inheritance */
            {
               $_[1]->inhOpt(INH_DEFAULT);
               $_[1]->alias(NULL);
               return $_[1];
            }
         | qualified_name '*'
            /* inheritance query */
            {
               $_[1]->inhOpt(INH_YES);
               $_[1]->alias(NULL);
               return $_[1];
            }
         | ONLY qualified_name
            /* no inheritance */
            {
               $_[2]->inhOpt(INH_NO);
               $_[2]->alias(NULL);
               return $_[2];
            }
         | ONLY '(' qualified_name ')'
            /* no inheritance, SQL99-style syntax */
            {
               $_[3]->inhOpt(INH_NO);
               $_[3]->alias(NULL);
               return $_[3];
            }
      ;


relation_expr_list:
         relation_expr                            { lappend($_[1]) }
         | relation_expr_list ',' relation_expr   { lappend($_[1], $_[3]) }
      ;


/*
 * Given "UPDATE foo set set ...", we have to decide without looking any
 * further ahead whether the first "set" is an alias or the UPDATE's SET
 * keyword.  Since "set" is allowed as a column name both interpretations
 * are feasible.  We resolve the shift/reduce conflict by giving the first
 * relation_expr_opt_alias production a higher precedence than the SET token
 * has, causing the parser to prefer to reduce, in effect assuming that the
 * SET is not an alias.
 */
relation_expr_opt_alias: relation_expr               %prec UMINUS
            {
               return $_[1];
            }
         | relation_expr ColId
            {
               my $alias = SQL::Translator::Statement::Alias->new(
                  aliasname => $_[2],
               );
               $_[1]->alias = $alias;
               return $_[1];
            }
         | relation_expr AS ColId
            {
               my $alias = SQL::Translator::Statement::Alias->new(
                  aliasname => $_[3],
               );
               $_[1]->alias = $alias;
               return $_[1];
            }
      ;


func_table: func_expr                        { $_[1] }
      ;


where_clause:
         WHERE a_expr                       { $_[2] }
         | /*EMPTY*/                        { NULL }
      ;

/* variant for UPDATE and DELETE */
where_or_current_clause:
         WHERE a_expr                     { $_[2] }
         | WHERE CURRENT OF cursor_name
            {
               return SQL::Translator::Statement::CurrentOfExpr->new(
                  #* cvarno is filled in by parse analysis
                  cursor_name  => $_[4],
                  cursor_param => 0,
               );
            }
         | /*EMPTY*/                        { NULL }
      ;


OptTableFuncElementList:
         TableFuncElementList            { $_[1] }
         | /*EMPTY*/                     { NULL }
      ;

TableFuncElementList:
         TableFuncElement
            {
               return lappend($_[1]);
            }
         | TableFuncElementList ',' TableFuncElement
            {
               return lappend($_[1], $_[3]);
            }
      ;

TableFuncElement:   ColId Typename opt_collate_clause
            {
               return SQL::Translator::Statement::Column::Definition->new(
                  colname        => $_[1],
                  typeName       => $_[2],
                  inhcount       => 0,
                  is_local       => TRUE,
                  is_not_null    => FALSE,
                  is_from_type   => FALSE,
                  storage        => 0,
                  raw_default    => NULL,
                  cooked_default => NULL,
                  collClause     => $_[3],
                  collOid        => InvalidOid,
                  constraints    => NIL,
               );
            }
      ;

/*****************************************************************************
 *
 *   Type syntax
 *      SQL92 introduces a large amount of type-specific syntax.
 *      Define individual clauses to handle these cases, and use
 *       the generic case to handle regular type-extensible Postgres syntax.
 *      - thomas 1997-10-10
 *
 *****************************************************************************/

Typename:   SimpleTypename opt_array_bounds
            {
               $_[1]->arrayBounds($_[2]);
               return $_[1];
            }
         | SETOF SimpleTypename opt_array_bounds
            {
               $_[2]->arrayBounds($_[3]);
               $_[2]->setof(TRUE);
               return $_[2];
            }
         /* SQL standard syntax, currently only one-dimensional */
         | SimpleTypename ARRAY '[' Iconst ']'
            {
               $_[1]->arrayBounds( lappend(makeInteger($_[4])) );
               return $_[1];
            }
         | SETOF SimpleTypename ARRAY '[' Iconst ']'
            {
               $_[2]->arrayBounds( lappend(makeInteger($_[5])) );
               $_[2]->setof = TRUE;
               return $_[2];
            }
         | SimpleTypename ARRAY
            {
               $_[1]->arrayBounds( lappend(makeInteger(-1)) );
               return $_[1];
            }
         | SETOF SimpleTypename ARRAY
            {
               $_[2]->arrayBounds( lappend(makeInteger(-1)) );
               $_[2]->setof = TRUE;
               return $_[2];
            }
      ;

opt_array_bounds:
         opt_array_bounds '[' ']'
               {  return lappend($_[1], makeInteger(-1)); }
         | opt_array_bounds '[' Iconst ']'
               {  return lappend($_[1], makeInteger($_[3])); }
         | /*EMPTY*/
               {  return undef; }
      ;

SimpleTypename:
         GenericType                        { $_[1] }
         | Numeric                          { $_[1] }
         | Bit                              { $_[1] }
         | Character                        { $_[1] }
         | ConstDatetime                    { $_[1] }
         | ConstInterval opt_interval
            {
               $_[1]->typmods($_[2]);
               return $_[1];
            }
         | ConstInterval '(' Iconst ')' opt_interval
            {
               if (defined $_[5])  {
                  $_[0]->ereport(ERROR,
                        ERRCODE_SYNTAX_ERROR,
                         "Interval precision specified twice",
                         $_[0]->YYLLoc($_[1], 1)) if (@{$_[5]} > 1);
                  $_[1]->typmods( lappend($_[5], makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               }
               else {
                  $_[1]->typmods( lappend(makeIntConst(INTERVAL_FULL_RANGE, -1), makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               }
               return $_[1];
            }
      ;

/* We have a separate ConstTypename to allow defaulting fixed-length
 * types such as CHAR() and BIT() to an unspecified length.
 * SQL9x requires that these default to a length of one, but this
 * makes no sense for constructs like CHAR 'hi' and BIT '0101',
 * where there is an obvious better choice to make.
 * Note that ConstInterval is not included here since it must
 * be pushed up higher in the rules to accomodate the postfix
 * options (e.g. INTERVAL '1' YEAR). Likewise, we have to handle
 * the generic-type-name case in AExprConst to avoid premature
 * reduce/reduce conflicts against function names.
 */
ConstTypename:
         Numeric                           { $_[1] }
         | ConstBit                        { $_[1] }
         | ConstCharacter                  { $_[1] }
         | ConstDatetime                   { $_[1] }
      ;

/*
 * GenericType covers all type names that don't have special syntax mandated
 * by the standard, including qualified names.  We also allow type modifiers.
 * To avoid parsing conflicts against function invocations, the modifiers
 * have to be shown as expr_list here, but parse analysis will only accept
 * constants for them.
 */
GenericType:
         type_function_name opt_type_modifiers
            {
               $n = makeTypeName($_[1]);
               $n->typmods($_[2]);
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | type_function_name attrs opt_type_modifiers
            {
               $n = makeTypeNameFromNameList(lcons(makeString($_[1]), $_[2]));
               $n->typmods($_[3]);
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
      ;

opt_type_modifiers: '(' expr_list ')'      { $_[2] }
               | /* EMPTY */               { NULL  }
      ;

/*
 * SQL92 numeric data types
 */
Numeric:   INT
            {
               my $n = SystemTypeName("int4");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | INTEGER
            {
               my $n = SystemTypeName("int4");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | SMALLINT
            {
               my $n = SystemTypeName("int2");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | BIGINT
            {
               my $n = SystemTypeName("int8");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | REAL
            {
               my $n = SystemTypeName("float4");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | FLOAT opt_float
            {
               $_[2]->location( $_[0]->YYLLoc($_[1], 1) );
               return $_[2];
            }
         | DOUBLE PRECISION
            {
               my $n = SystemTypeName("float8");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | DECIMAL opt_type_modifiers
            {
               my $n = SystemTypeName("numeric");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               $n->typmods($_[2]);
               return $n;
            }
         | DEC opt_type_modifiers
            {
               my $n = SystemTypeName("numeric");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               $n->typmods($_[2]);
               return $n;
            }
         | NUMERIC opt_type_modifiers
            {
               my $n = SystemTypeName("numeric");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               $n->typmods($_[2]);
               return $n;
            }
         | BOOLEAN
            {
               my $n = SystemTypeName("bool");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
      ;

opt_float:   '(' Iconst ')'
            {
               /*
                * Check FLOAT() precision limits assuming IEEE floating
                * types - thomas 1997-09-18
                */
               if ($_[2] < 1) {
                  $_[0]->ereport(ERROR,
                        ERRCODE_INVALID_PARAMETER_VALUE,
                         "precision for type float must be at least 1 bit",
                         $_[0]->YYLLoc($_[2], 2));
               }
               elsif ($_[2] <= 24) {
                  return SystemTypeName("float4");
               }
               elsif ($_[2] <= 53) {
                  return SystemTypeName("float8");
               }
               else {
                  $_[0]->ereport(ERROR,
                        ERRCODE_INVALID_PARAMETER_VALUE,
                         "precision for type float must be less than 54 bits",
                         $_[0]->YYLLoc($_[2], 2));
               }
            }
         | /*EMPTY*/
            {
               return SystemTypeName("float8");
            }
      ;

/*
 * SQL92 bit-field data types
 * The following implements BIT() and BIT VARYING().
 */
Bit:      BitWithLength
            {
               return $_[1];
            }
         | BitWithoutLength
            {
               return $_[1];
            }
      ;

/* ConstBit is like Bit except "BIT" defaults to unspecified length */
/* See notes for ConstCharacter, which addresses same issue for "CHAR" */
ConstBit:   BitWithLength
            {
               return $_[1];
            }
         | BitWithoutLength
            {
               $_[1]->typmods(NIL);
               return $_[1];
            }
      ;

BitWithLength:
         BIT opt_varying '(' expr_list ')'
            {
               my $n = SystemTypeName($_[2] ? 'varbit' : 'bit');
               $n->typmods($_[4]);
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
      ;

BitWithoutLength:
         BIT opt_varying
            {
               /* bit defaults to bit(1), varbit to no limit */
               if ($_[2])
               {
                  return SystemTypeName("varbit");
               }
               else
               {
                  my $n = SystemTypeName("bit");
                  $n->typmods( lappend(makeIntConst(1, -1)) );
                  return $n;
               }
               $n->location( $_[0]->YYLLoc($_[1], 1) );
            }
      ;


/*
 * SQL92 character data types
 * The following implements CHAR() and VARCHAR().
 */
Character:  CharacterWithLength
            {
               return $_[1];
            }
         | CharacterWithoutLength
            {
               return $_[1];
            }
      ;

ConstCharacter:  CharacterWithLength
            {
               return $_[1];
            }
         | CharacterWithoutLength
            {
               /* Length was not specified so allow to be unrestricted.
                * This handles problems with fixed-length (bpchar) strings
                * which in column definitions must default to a length
                * of one, but should not be constrained if the length
                * was not specified.
                */
               $_[1]->typmods(NIL);
               return $_[1];
            }
      ;

CharacterWithLength:  character '(' Iconst ')' opt_charset
            {
               $_[1] .= '_'.$_[5]
                  if (defined $_[5] && $_[5] eq "sql_text");

               return SystemTypeName($_[1]);
               $n->typmods(lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))));
               $n->location( $_[0]->YYLLoc($_[1], 1) );
            }
      ;

CharacterWithoutLength:    character opt_charset
            {
               $_[1] .= '_'.$_[2]
                  if (defined $_[2] && $_[2] eq "sql_text");

               return SystemTypeName($_[1]);

               /* char defaults to char(1), varchar to no limit */
               $n->typmods(lappend(makeIntConst(1, -1)))
                  if ($_[1] eq "bpchar");

               $n->location( $_[0]->YYLLoc($_[1], 1) );
            }
      ;

character:   CHARACTER opt_varying
                              { $_[2] ? "varchar": "bpchar" }
         | CHAR opt_varying
                              { $_[2] ? "varchar": "bpchar" }
         | VARCHAR
                              { "varchar" }
         | NATIONAL CHARACTER opt_varying
                              { $_[3] ? "varchar": "bpchar" }
         | NATIONAL CHAR opt_varying
                              { $_[3] ? "varchar": "bpchar" }
         | NCHAR opt_varying
                              { $_[2] ? "varchar": "bpchar" }
      ;

opt_varying:
         VARYING                            { TRUE  }
         | /*EMPTY*/                        { FALSE }
      ;

opt_charset:
         CHARACTER SET ColId                { $_[3] }
         | /*EMPTY*/                        { NULL  }
      ;

/*
 * SQL92 date/time types
 */
ConstDatetime:
         TIMESTAMP '(' Iconst ')' opt_timezone
            {
               my $n = SystemTypeName('timestamp'.($_[5] ? 'tz' : ''));
               $n->typmods(lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))));
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | TIMESTAMP opt_timezone
            {
               my $n = SystemTypeName('timestamp'.($_[2] ? 'tz' : ''));
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | TIME '(' Iconst ')' opt_timezone
            {
               my $n = SystemTypeName('time'.($_[5] ? 'tz' : ''));
               $n->typmods(lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))));
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
         | TIME opt_timezone
            {
               my $n = SystemTypeName('time'.($_[2] ? 'tz' : ''));
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
      ;

ConstInterval:
         INTERVAL
            {
               my $n = SystemTypeName("interval");
               $n->location( $_[0]->YYLLoc($_[1], 1) );
               return $n;
            }
      ;

opt_timezone:
         WITH_TIME ZONE                     { TRUE  }
         | WITHOUT TIME ZONE                { FALSE }
         | /*EMPTY*/                        { FALSE }
      ;

opt_interval:
         YEAR
            { lappend(makeIntConst(INTERVAL_MASK(YEAR), $_[0]->YYLLoc($_[1], 1))) }
         | MONTH
            { lappend(makeIntConst(INTERVAL_MASK(MONTH), $_[0]->YYLLoc($_[1], 1))) }
         | DAY
            { lappend(makeIntConst(INTERVAL_MASK(DAY), $_[0]->YYLLoc($_[1], 1))) }
         | HOUR
            { lappend(makeIntConst(INTERVAL_MASK(HOUR), $_[0]->YYLLoc($_[1], 1))) }
         | MINUTE
            { lappend(makeIntConst(INTERVAL_MASK(MINUTE), $_[0]->YYLLoc($_[1], 1))) }
         | interval_second
            { $_[1] }
         | YEAR TO MONTH
            {
               return lappend(makeIntConst(INTERVAL_MASK(YEAR) |
                                     INTERVAL_MASK(MONTH), $_[0]->YYLLoc($_[1], 1)));
            }
         | DAY TO HOUR
            {
               return lappend(makeIntConst(INTERVAL_MASK(DAY) |
                                     INTERVAL_MASK(HOUR), $_[0]->YYLLoc($_[1], 1)));
            }
         | DAY TO MINUTE
            {
               return lappend(makeIntConst(INTERVAL_MASK(DAY) |
                                     INTERVAL_MASK(HOUR) |
                                     INTERVAL_MASK(MINUTE), $_[0]->YYLLoc($_[1], 1)));
            }
         | DAY TO interval_second
            {
               linitial($_[3]) = makeIntConst(INTERVAL_MASK(DAY) |
                                    INTERVAL_MASK(HOUR) |
                                    INTERVAL_MASK(MINUTE) |
                                    INTERVAL_MASK(SECOND), $_[0]->YYLLoc($_[1], 1));
               return $_[3];
            }
         | HOUR TO MINUTE
            {
               return lappend(makeIntConst(INTERVAL_MASK(HOUR) |
                                     INTERVAL_MASK(MINUTE), $_[0]->YYLLoc($_[1], 1)));
            }
         | HOUR TO interval_second
            {
               linitial($_[3]) = makeIntConst(INTERVAL_MASK(HOUR) |
                                    INTERVAL_MASK(MINUTE) |
                                    INTERVAL_MASK(SECOND), $_[0]->YYLLoc($_[1], 1));
               return $_[3];
            }
         | MINUTE TO interval_second
            {
               linitial($_[3]) = makeIntConst(INTERVAL_MASK(MINUTE) |
                                    INTERVAL_MASK(SECOND), $_[0]->YYLLoc($_[1], 1));
               return $_[3];
            }
         | /*EMPTY*/
            { NULL }
      ;

interval_second:
         SECOND
            {
               return lappend(makeIntConst(INTERVAL_MASK(SECOND), $_[0]->YYLLoc($_[1], 1)));
            }
         | SECOND '(' Iconst ')'
            {
               return lappend(makeIntConst(INTERVAL_MASK(SECOND), $_[0]->YYLLoc($_[1], 1)),
                              makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3)));
            }
      ;


/*****************************************************************************
 *
 *   expression grammar
 *
 *****************************************************************************/

/*
 * General expressions
 * This is the heart of the expression syntax.
 *
 * We have two expression types: a_expr is the unrestricted kind, and
 * b_expr is a subset that must be used in some places to avoid shift/reduce
 * conflicts.  For example, we can't do BETWEEN as "BETWEEN a_expr AND a_expr"
 * because that use of AND conflicts with AND as a boolean operator.  So,
 * b_expr is used in BETWEEN and we remove boolean keywords from b_expr.
 *
 * Note that '(' a_expr ')' is a b_expr, so an unrestricted expression can
 * always be used by surrounding it with parens.
 *
 * c_expr is all the productions that are common to a_expr and b_expr;
 * it's factored out just to eliminate redundant coding.
 */
a_expr:    c_expr                           { $_[1] }
         | a_expr TYPECAST Typename
               { makeTypeCast($_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr COLLATE any_name
            {
               return SQL::Translator::Statement::CollateClause->new(
                  arg => $_[1],
                  collname => $_[3],
                  location => $_[0]->YYLLoc($_[2], 2),
               );
            }
         | a_expr AT TIME ZONE a_expr         %prec AT
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("timezone"),
                  args => lappend($_[5], $_[1]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
            }
      /*
       * These operators must be called out explicitly in order to make use
       * of bison's automatic operator-precedence handling.  All other
       * operator names are handled by the generic productions using "Op",
       * below; and all those operators will have the same precedence.
       *
       * If you add more explicitly-known operators, be sure to add them
       * also to b_expr and to the MathOp list above.
       */
         | '+' a_expr               %prec UMINUS
            {  makeSimpleA_Expr(AEXPR_OP, "+", NULL, $_[2], $_[0]->YYLLoc($_[1], 1)) }
         | '-' a_expr               %prec UMINUS
            { doNegate($_[2], $_[0]->YYLLoc($_[1], 1)) }
         | a_expr '+' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "+", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '-' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "-", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '*' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "*", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '/' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "/", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '%' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "%", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '^' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "^", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '<' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "<", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '>' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, ">", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr '=' a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "=", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }

         | a_expr qual_Op a_expr            %prec Op
            {  makeA_Expr(AEXPR_OP, $_[2], $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | qual_Op a_expr               %prec Op
            {  makeA_Expr(AEXPR_OP, $_[1], NULL, $_[2], $_[0]->YYLLoc($_[1], 1)) }
         | a_expr qual_Op               %prec POSTFIXOP
            {  makeA_Expr(AEXPR_OP, $_[2], $_[1], NULL, $_[0]->YYLLoc($_[2], 2)) }

         | a_expr AND a_expr
            {  makeA_Expr(AEXPR_AND, NIL, $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr OR a_expr
            {  makeA_Expr(AEXPR_OR, NIL, $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | NOT a_expr
            {  makeA_Expr(AEXPR_NOT, NIL, NULL, $_[2], $_[0]->YYLLoc($_[1], 1)) }

         | a_expr LIKE a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "~~", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr LIKE a_expr ESCAPE a_expr
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("like_escape"),
                  args => lappend($_[3], $_[5]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "~~", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr NOT LIKE a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "!~~", $_[1], $_[4], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr NOT LIKE a_expr ESCAPE a_expr
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("like_escape"),
                  args => lappend($_[4], $_[6]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "!~~", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr ILIKE a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "~~*", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr ILIKE a_expr ESCAPE a_expr
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("like_escape"),
                  args => lappend($_[3], $_[5]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "~~*", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr NOT ILIKE a_expr
            {  makeSimpleA_Expr(AEXPR_OP, "!~~*", $_[1], $_[4], $_[0]->YYLLoc($_[2], 2)) }
         | a_expr NOT ILIKE a_expr ESCAPE a_expr
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("like_escape"),
                  args => lappend($_[4], $_[6]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "!~~*", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }

         | a_expr SIMILAR TO a_expr            %prec SIMILAR
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("similar_escape"),
                  args => lappend($_[4], makeNullAConst(-1)),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "~", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr SIMILAR TO a_expr ESCAPE a_expr
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("similar_escape"),
                  args => lappend($_[4], $_[6]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "~", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr NOT SIMILAR TO a_expr         %prec SIMILAR
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("similar_escape"),
                  args => lappend($_[5], makeNullAConst(-1)),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "!~", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr NOT SIMILAR TO a_expr ESCAPE a_expr
            {
               my $n = SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("similar_escape"),
                  args => lappend($_[5], $_[7]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[2], 2),
               );
               return makeSimpleA_Expr(AEXPR_OP, "!~", $_[1], $n, $_[0]->YYLLoc($_[2], 2));
            }

         /* NullTest clause
          * Define SQL92-style Null test clause.
          * Allow two forms described in the standard:
          *   a IS NULL
          *   a IS NOT NULL
          * Allow two SQL extensions
          *   a ISNULL
          *   a NOTNULL
          */
         | a_expr IS NULL                     %prec IS
            {
               return SQL::Translator::Statement::NullTest->new(
                  arg => $_[1],
                  nulltesttype => IS_NULL,
               );
            }
         | a_expr ISNULL
            {
               return SQL::Translator::Statement::NullTest->new(
                  arg => $_[1],
                  nulltesttype => IS_NULL,
               );
            }
         | a_expr IS NOT NULL                  %prec IS
            {
               return SQL::Translator::Statement::NullTest->new(
                  arg => $_[1],
                  nulltesttype => IS_NOT_NULL,
               );
            }
         | a_expr NOTNULL
            {
               return SQL::Translator::Statement::NullTest->new(
                  arg => $_[1],
                  nulltesttype => IS_NOT_NULL,
               );
            }
         | row OVERLAPS row
            {
               return makeOverlaps($_[1], $_[3], $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr IS TRUE                     %prec IS
            {
               return SQL::Translator::Statement::BooleanTest->new(
                  arg          => $_[1],
                  booltesttype => IS_TRUE,
               );
            }
         | a_expr IS NOT TRUE                  %prec IS
            {
               return SQL::Translator::Statement::BooleanTest->new(
                  arg          => $_[1],
                  booltesttype => IS_NOT_TRUE,
               );
            }
         | a_expr IS FALSE                     %prec IS
            {
               return SQL::Translator::Statement::BooleanTest->new(
                  arg          => $_[1],
                  booltesttype => IS_FALSE,
               );
            }
         | a_expr IS NOT FALSE                  %prec IS
            {
               return SQL::Translator::Statement::BooleanTest->new(
                  arg          => $_[1],
                  booltesttype => IS_NOT_FALSE,
               );
            }
         | a_expr IS UNKNOWN                     %prec IS
            {
               return SQL::Translator::Statement::BooleanTest->new(
                  arg          => $_[1],
                  booltesttype => IS_UNKNOWN,
               );
            }
         | a_expr IS NOT UNKNOWN                  %prec IS
            {
               return SQL::Translator::Statement::BooleanTest->new(
                  arg          => $_[1],
                  booltesttype => IS_NOT_UNKNOWN,
               );
            }
         | a_expr IS DISTINCT FROM a_expr         %prec IS
            {
               return makeSimpleA_Expr(AEXPR_DISTINCT, "=", $_[1], $_[5], $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr IS NOT DISTINCT FROM a_expr      %prec IS
            {
               return makeA_Expr(AEXPR_NOT, NIL, NULL,
                            makeSimpleA_Expr(AEXPR_DISTINCT,
                                               "=", $_[1], $_[6], $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));

            }
         | a_expr IS OF '(' type_list ')'         %prec IS
            {
               return makeSimpleA_Expr(AEXPR_OF, "=", $_[1],  $_[5], $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr IS NOT OF '(' type_list ')'      %prec IS
            {
               return makeSimpleA_Expr(AEXPR_OF, "<>", $_[1],  $_[6], $_[0]->YYLLoc($_[2], 2));
            }
         /*
          *   Ideally we would not use hard-wired operators below but
          *   instead use opclasses.  However, mixed data types and other
          *   issues make this difficult:
          *   http://archives.postgresql.org/pgsql-hackers/2008-08/msg01142.php
          */
         | a_expr BETWEEN opt_asymmetric b_expr AND b_expr      %prec BETWEEN
            {
               return makeA_Expr(AEXPR_AND, NIL,
                   makeSimpleA_Expr(AEXPR_OP, ">=", $_[1], $_[4], $_[0]->YYLLoc($_[2], 2)),
                   makeSimpleA_Expr(AEXPR_OP, "<=", $_[1], $_[6], $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr NOT BETWEEN opt_asymmetric b_expr AND b_expr   %prec BETWEEN
            {
               return makeA_Expr(AEXPR_OR, NIL,
                   makeSimpleA_Expr(AEXPR_OP, "<", $_[1], $_[5], $_[0]->YYLLoc($_[2], 2)),
                   makeSimpleA_Expr(AEXPR_OP, ">", $_[1], $_[7], $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr BETWEEN SYMMETRIC b_expr AND b_expr         %prec BETWEEN
            {
               return makeA_Expr(AEXPR_OR, NIL,
                   makeA_Expr(AEXPR_AND, NIL,
                       makeSimpleA_Expr(AEXPR_OP, ">=", $_[1], $_[4], $_[0]->YYLLoc($_[2], 2)),
                       makeSimpleA_Expr(AEXPR_OP, "<=", $_[1], $_[6], $_[0]->YYLLoc($_[2], 2)),
                                 $_[0]->YYLLoc($_[2], 2)),
                   makeA_Expr(AEXPR_AND, NIL,
                       makeSimpleA_Expr(AEXPR_OP, ">=", $_[1], $_[6], $_[0]->YYLLoc($_[2], 2)),
                       makeSimpleA_Expr(AEXPR_OP, "<=", $_[1], $_[4], $_[0]->YYLLoc($_[2], 2)),
                                 $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr NOT BETWEEN SYMMETRIC b_expr AND b_expr      %prec BETWEEN
            {
               return makeA_Expr(AEXPR_AND, NIL,
                   makeA_Expr(AEXPR_OR, NIL,
                       makeSimpleA_Expr(AEXPR_OP, "<", $_[1], $_[5], $_[0]->YYLLoc($_[2], 2)),
                       makeSimpleA_Expr(AEXPR_OP, ">", $_[1], $_[7], $_[0]->YYLLoc($_[2], 2)),
                                 $_[0]->YYLLoc($_[2], 2)),
                   makeA_Expr(AEXPR_OR, NIL,
                       makeSimpleA_Expr(AEXPR_OP, "<", $_[1], $_[7], $_[0]->YYLLoc($_[2], 2)),
                       makeSimpleA_Expr(AEXPR_OP, ">", $_[1], $_[5], $_[0]->YYLLoc($_[2], 2)),
                                 $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr IN in_expr
            {
               /* in_expr returns a SubLink or a list of a_exprs */
               if ($_[3]->isa('SQL::Translator::Statement::SubLink')) {
                  #* generate foo = ANY (subquery)
                  $_[3]->subLinkType(ANY_SUBLINK);
                  $_[3]->testexpr($_[1]);
                  $_[3]->operName( lappend(makeString("=")) );
                  $_[3]->location( $_[0]->YYLLoc($_[2], 2) );
                  return $_[3];
               }
               else {
                  #* generate scalar IN expression
                  return makeSimpleA_Expr(AEXPR_IN, "=", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2));
               }
            }
         | a_expr NOT IN in_expr
            {
               /* in_expr returns a SubLink or a list of a_exprs */
               if ($_[4]->isa('SQL::Translator::Statement::SubLink')) {
                  #* generate foo = ANY (subquery)
                  $_[4]->subLinkType(ANY_SUBLINK);
                  $_[4]->testexpr($_[1]);
                  $_[4]->operName( lappend(makeString("=")) );
                  $_[4]->location( $_[0]->YYLLoc($_[3], 3) );
                  #* Stick a NOT on top
                  return makeA_Expr(AEXPR_NOT, NIL, NULL, $_[4], $_[0]->YYLLoc($_[2], 2));
               }
               else {
                  #* generate scalar NOT IN expression
                  return makeSimpleA_Expr(AEXPR_IN, "<>", $_[1], $_[4], $_[0]->YYLLoc($_[2], 2));
               }
            }
         | a_expr subquery_Op sub_type select_with_parens   %prec Op
            {
               return SQL::Translator::Statement::SubLink->new(
                  subLinkType => $_[3],
                  testexpr => $_[1],
                  operName => $_[2],
                  subselect => $_[4],
                  location => $_[0]->YYLLoc($_[2], 2),
               );
            }
         | a_expr subquery_Op sub_type '(' a_expr ')'      %prec Op
            {
               return makeA_Expr(
                  ($_[3] eq ANY_SUBLINK ? AEXPR_OP_ANY : AEXPR_OP_ALL),
                  $_[2], $_[1], $_[5], $_[0]->YYLLoc($_[2], 2)
               );
            }
         | UNIQUE select_with_parens
            /* Not sure how to get rid of the parentheses
             * but there are lots of shift/reduce errors without them.
             *
             * Should be able to implement this by plopping the entire
             * select into a node, then transforming the target expressions
             * from whatever they are into count(*), and testing the
             * entire result equal to one.
             * But, will probably implement a separate node in the executor.
             */
            {
               $_[0]->ereport(ERROR,
                     ERRCODE_FEATURE_NOT_SUPPORTED,
                      "UNIQUE predicate is not yet implemented",
                      $_[0]->YYLLoc($_[1], 1));
            }
         | a_expr IS DOCUMENT               %prec IS
            {
               return makeXmlExpr(IS_DOCUMENT, NULL, NIL,
                            lappend($_[1]), $_[0]->YYLLoc($_[2], 2));
            }
         | a_expr IS NOT DOCUMENT            %prec IS
            {
               return makeA_Expr(AEXPR_NOT, NIL, NULL,
                                  makeXmlExpr(IS_DOCUMENT, NULL, NIL,
                                           lappend($_[1]), $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));
            }
      ;

/*
 * Restricted expressions
 *
 * b_expr is a subset of the complete expression syntax defined by a_expr.
 *
 * Presently, AND, NOT, IS, and IN are the a_expr keywords that would
 * cause trouble in the places where b_expr is used.  For simplicity, we
 * just eliminate all the boolean-keyword-operator productions from b_expr.
 */
b_expr:      c_expr
            { $_[1] }
         | b_expr TYPECAST Typename
            { makeTypeCast($_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | '+' b_expr               %prec UMINUS
            {  makeSimpleA_Expr(AEXPR_OP, "+", NULL, $_[2], $_[0]->YYLLoc($_[1], 1)) }
         | '-' b_expr               %prec UMINUS
            { doNegate($_[2], $_[0]->YYLLoc($_[1], 1)) }
         | b_expr '+' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "+", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '-' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "-", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '*' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "*", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '/' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "/", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '%' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "%", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '^' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "^", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '<' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "<", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '>' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, ">", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr '=' b_expr
            {  makeSimpleA_Expr(AEXPR_OP, "=", $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | b_expr qual_Op b_expr            %prec Op
            {  makeA_Expr(AEXPR_OP, $_[2], $_[1], $_[3], $_[0]->YYLLoc($_[2], 2)) }
         | qual_Op b_expr               %prec Op
            {  makeA_Expr(AEXPR_OP, $_[1], NULL, $_[2], $_[0]->YYLLoc($_[1], 1)) }
         | b_expr qual_Op               %prec POSTFIXOP
            {  makeA_Expr(AEXPR_OP, $_[2], $_[1], NULL, $_[0]->YYLLoc($_[2], 2)) }
         | b_expr IS DISTINCT FROM b_expr      %prec IS
            {
               return makeSimpleA_Expr(AEXPR_DISTINCT, "=", $_[1], $_[5], $_[0]->YYLLoc($_[2], 2));
            }
         | b_expr IS NOT DISTINCT FROM b_expr   %prec IS
            {
               return makeA_Expr(AEXPR_NOT, NIL,
                  NULL,  makeSimpleA_Expr(AEXPR_DISTINCT, "=", $_[1], $_[6], $_[0]->YYLLoc($_[2], 2)), $_[0]->YYLLoc($_[2], 2));
            }
         | b_expr IS OF '(' type_list ')'      %prec IS
            {
               return makeSimpleA_Expr(AEXPR_OF, "=", $_[1],  $_[5], $_[0]->YYLLoc($_[2], 2));
            }
         | b_expr IS NOT OF '(' type_list ')'   %prec IS
            {
               return makeSimpleA_Expr(AEXPR_OF, "<>", $_[1],  $_[6], $_[0]->YYLLoc($_[2], 2));
            }
         | b_expr IS DOCUMENT               %prec IS
            {
               return makeXmlExpr(IS_DOCUMENT, NULL, NIL,
                            lappend($_[1]), $_[0]->YYLLoc($_[2], 2));
            }
         | b_expr IS NOT DOCUMENT            %prec IS
            {
               return makeA_Expr(AEXPR_NOT, NIL, NULL,
                                  makeXmlExpr(IS_DOCUMENT, NULL, NIL,
                                           lappend($_[1]), $_[0]->YYLLoc($_[2], 2)),
                                  $_[0]->YYLLoc($_[2], 2));
            }
      ;

/*
 * Productions that can be used in both a_expr and b_expr.
 *
 * Note: productions that refer recursively to a_expr or b_expr mostly
 * cannot appear here.   However, it's OK to refer to a_exprs that occur
 * inside parentheses, such as function arguments; that cannot introduce
 * ambiguity to the b_expr syntax.
 */
c_expr:    columnref                      { $_[1] }
         | AexprConst                     { $_[1] }
         | PARAM opt_indirection
            {
               my $p = makeNode(ParamRef);
               $p->number($_[1]);
               $p->location( $_[0]->YYLLoc($_[1], 1) );
               if ($_[2]) {
                  return makeNode(A_Indirection);
                     arg => $p,
                     indirection => check_indirection($_[2]),
                  );
               }
               return $p;
            }
         | '(' a_expr ')' opt_indirection
            {
               if ($_[4]) {
                  return makeNode(A_Indirection);
                     arg => $_[2],
                     indirection => check_indirection($_[4]),
                  );
               }
               return $_[2];
            }
         | case_expr
            { $_[1] }
         | func_expr
            { $_[1] }
         | select_with_parens         %prec UMINUS
            {
               return SQL::Translator::Statement::SubLink->new(
                  subLinkType => EXPR_SUBLINK,
                  testexpr => NULL,
                  operName => NIL,
                  subselect => $_[1],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | EXISTS select_with_parens
            {
               return SQL::Translator::Statement::SubLink->new(
                  subLinkType => EXISTS_SUBLINK,
                  testexpr => NULL,
                  operName => NIL,
                  subselect => $_[2],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | ARRAY select_with_parens
            {
               return SQL::Translator::Statement::SubLink->new(
                  subLinkType => ARRAY_SUBLINK,
                  testexpr => NULL,
                  operName => NIL,
                  subselect => $_[2],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | ARRAY array_expr
            {
               #* point outermost A_ArrayExpr to the ARRAY keyword
               $_[2]->location( $_[0]->YYLLoc($_[1], 1) );
               return $_[2];
            }
         | row
            {
               return SQL::Translator::Statement::RowExpr->new(
                  args       => $_[1],
                  row_typeid => InvalidOid,   #* not analyzed yet
                  location   => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

/*
 * func_expr is split out from c_expr just so that we have a classification
 * for "everything that is a function call or looks like one".  This isn't
 * very important, but it saves us having to document which variants are
 * legal in the backwards-compatible functional-index syntax for CREATE INDEX.
 * (Note that many of the special SQL functions wouldn't actually make any
 * sense as functional index entries, but we ignore that consideration here.)
 */
func_expr:   func_name '(' ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => $_[4],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' func_arg_list ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => $_[3],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => $_[5],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' VARIADIC func_arg_expr ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => lappend($_[4]),
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => TRUE,
                  over          => $_[6],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' func_arg_list ',' VARIADIC func_arg_expr ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => lappend($_[3], $_[6]),
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => TRUE,
                  over          => $_[8],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' func_arg_list sort_clause ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => $_[3],
                  agg_order     => $_[4],
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => $_[6],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' ALL func_arg_list opt_sort_clause ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => $_[4],
                  agg_order     => $_[5],
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  #* Ideally we'd mark the FuncCall node to indicate
                  #* "must be an aggregate", but there's no provision
                  #* for that in FuncCall at the moment.
                  func_variadic => FALSE,
                  over          => $_[7],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' DISTINCT func_arg_list opt_sort_clause ')' over_clause
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => $_[4],
                  agg_order     => $_[5],
                  agg_star      => FALSE,
                  agg_distinct  => TRUE,
                  func_variadic => FALSE,
                  over          => $_[7],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | func_name '(' '*' ')' over_clause
            /*
             * We consider AGGREGATE(*) to invoke a parameterless
             * aggregate.  This does the right thing for COUNT(*),
             * and there are no other aggregates in SQL92 that accept
             * '*' as parameter.
             *
             * The FuncCall node is also marked agg_star = TRUE,
             * so that later processing can detect what the argument
             * really was.
             */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => $_[1],
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => TRUE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => $_[5],
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | CURRENT_DATE
            /*
             * Translate as "'now'::text::date".
             *
             * We cannot use "'now'::date" because coerce_type() will
             * immediately reduce that to a constant representing
             * today's date.  We need to delay the conversion until
             * runtime, else the wrong things will happen when
             * CURRENT_DATE is used in a column default value or rule.
             *
             * This could be simplified if we had a way to generate
             * an expression tree representing runtime application
             * of type-input conversion functions.  (As of PG 7.3
             * that is actually possible, but not clear that we want
             * to rely on it.)
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               return makeTypeCast($n, SystemTypeName("date"), -1);
            }
         | CURRENT_TIME
            /*
             * Translate as "'now'::text::timetz".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               return makeTypeCast($n, SystemTypeName("timetz"), -1);
            }
         | CURRENT_TIME '(' Iconst ')'
            /*
             * Translate as "'now'::text::timetz(n)".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               my $d = SystemTypeName("timetz");
               $d->typmods( lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               return makeTypeCast($n, $d, -1);
            }
         | CURRENT_TIMESTAMP
            /*
             * Translate as "now()", since we have a function that
             * does exactly what is needed.
             */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("now"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | CURRENT_TIMESTAMP '(' Iconst ')'
            /*
             * Translate as "'now'::text::timestamptz(n)".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               my $d = SystemTypeName("timestamptz");
               $d->typmods( lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               return makeTypeCast($n, $d, -1);
            }
         | LOCALTIME
            /*
             * Translate as "'now'::text::time".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               return makeTypeCast($n, SystemTypeName("time"), -1);
            }
         | LOCALTIME '(' Iconst ')'
            /*
             * Translate as "'now'::text::time(n)".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               my $d = SystemTypeName("time");
               $d->typmods( lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               return makeTypeCast($n, $d, -1);
            }
         | LOCALTIMESTAMP
            /*
             * Translate as "'now'::text::timestamp".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               return makeTypeCast($n, SystemTypeName("timestamp"), -1);
            }
         | LOCALTIMESTAMP '(' Iconst ')'
            /*
             * Translate as "'now'::text::timestamp(n)".
             * See comments for CURRENT_DATE.
             */
            {
               my $n = makeStringConstCast("now", $_[0]->YYLLoc($_[1], 1), SystemTypeName("text"));
               my $d = SystemTypeName("timestamp");
               $d->typmods( lappend(makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3))) );
               return makeTypeCast($n, $d, -1);
            }
         | CURRENT_ROLE
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("current_user"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | CURRENT_USER
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("current_user"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | SESSION_USER
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("session_user"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | USER
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("current_user"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | CURRENT_CATALOG
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("current_database"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | CURRENT_SCHEMA
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("current_schema"),
                  args          => NIL,
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | CAST '(' a_expr AS Typename ')'
            { makeTypeCast($_[3], $_[5], $_[0]->YYLLoc($_[1], 1)) }
         | EXTRACT '(' extract_list ')'
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("date_part"),
                  args          => $_[3],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | OVERLAY '(' overlay_list ')'
            /* overlay(A PLACING B FROM C FOR D) is converted to
             * overlay(A, B, C, D)
             * overlay(A PLACING B FROM C) is converted to
             * overlay(A, B, C)
             */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("overlay"),
                  args          => $_[3],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | POSITION '(' position_list ')'
            /* position(A in B) is converted to position(B, A) */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("position"),
                  args          => $_[3],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | SUBSTRING '(' substr_list ')'
            /* substring(A from B for C) is converted to
             * substring(A, B, C) - thomas 2000-11-28
             */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("substring"),
                  args          => $_[3],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | TREAT '(' a_expr AS Typename ')'
            /* TREAT(expr AS target) converts expr of a particular type to target,
             * which is defined to be a subtype of the original expression.
             * In SQL99, this is intended for use with structured UDTs,
             * but let's make this a generally useful form allowing stronger
             * coercions than are handled by implicit casting.
             */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  #* Convert SystemTypeName() to SystemFuncName() even though
                  #* at the moment they result in the same thing.
                  funcname      => SystemFuncName($_[5]->names->[-1]),
                  args          => lappend($_[3]),
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | TRIM '(' BOTH trim_list ')'
            /* various trim expressions are defined in SQL92
             * - thomas 1997-07-19
             */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("btrim"),
                  args          => $_[4],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | TRIM '(' LEADING trim_list ')'
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("ltrim"),
                  args          => $_[4],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | TRIM '(' TRAILING trim_list ')'
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("rtrim"),
                  args          => $_[4],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | TRIM '(' trim_list ')'
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname      => SystemFuncName("btrim"),
                  args          => $_[3],
                  agg_order     => NIL,
                  agg_star      => FALSE,
                  agg_distinct  => FALSE,
                  func_variadic => FALSE,
                  over          => NULL,
                  location      => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | NULLIF '(' a_expr ',' a_expr ')'
            {
               return makeSimpleA_Expr(AEXPR_NULLIF, "=", $_[3], $_[5], $_[0]->YYLLoc($_[1], 1));
            }
         | COALESCE '(' expr_list ')'
            {
               return SQL::Translator::Statement::CoalesceExpr->new(
                  args     => $_[3],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | GREATEST '(' expr_list ')'
            {
               return SQL::Translator::Statement::MinMaxExpr->new(
                  args     => $_[3],
                  op       => IS_GREATEST,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | LEAST '(' expr_list ')'
            {
               return SQL::Translator::Statement::MinMaxExpr->new(
                  args     => $_[3],
                  op       => IS_LEAST,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | XMLCONCAT '(' expr_list ')'
            {
               return makeXmlExpr(IS_XMLCONCAT, NULL, NIL, $_[3], $_[0]->YYLLoc($_[1], 1));
            }
         | XMLELEMENT '(' NAME ColLabel ')'
            {
               return makeXmlExpr(IS_XMLELEMENT, $_[4], NIL, NIL, $_[0]->YYLLoc($_[1], 1));
            }
         | XMLELEMENT '(' NAME ColLabel ',' xml_attributes ')'
            {
               return makeXmlExpr(IS_XMLELEMENT, $_[4], $_[6], NIL, $_[0]->YYLLoc($_[1], 1));
            }
         | XMLELEMENT '(' NAME ColLabel ',' expr_list ')'
            {
               return makeXmlExpr(IS_XMLELEMENT, $_[4], NIL, $_[6], $_[0]->YYLLoc($_[1], 1));
            }
         | XMLELEMENT '(' NAME ColLabel ',' xml_attributes ',' expr_list ')'
            {
               return makeXmlExpr(IS_XMLELEMENT, $_[4], $_[6], $_[8], $_[0]->YYLLoc($_[1], 1));
            }
         | XMLEXISTS '(' c_expr xmlexists_argument ')'
            /* xmlexists(A PASSING [BY REF] B [BY REF]) is
             * converted to xmlexists(A, B) */
            {
               return SQL::Translator::Statement::FunctionCall->new(
                  funcname => SystemFuncName("xmlexists"),
                  args => lappend($_[3], $_[4]),
                  agg_order => NIL,
                  agg_star => FALSE,
                  agg_distinct => FALSE,
                  func_variadic => FALSE,
                  over => NULL,
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | XMLFOREST '(' xml_attribute_list ')'
            {
               return makeXmlExpr(IS_XMLFOREST, NULL, $_[3], NIL, $_[0]->YYLLoc($_[1], 1));
            }
         | XMLPARSE '(' document_or_content a_expr xml_whitespace_option ')'
            {
               my $x = makeXmlExpr(IS_XMLPARSE, NULL, NIL,
                           lappend($_[4], makeBoolAConst($_[5], -1)),
                           $_[0]->YYLLoc($_[1], 1));
               $x->xmloption($_[3]);
               return $x;
            }
         | XMLPI '(' NAME ColLabel ')'
            {
               return makeXmlExpr(IS_XMLPI, $_[4], NULL, NIL, $_[0]->YYLLoc($_[1], 1));
            }
         | XMLPI '(' NAME ColLabel ',' a_expr ')'
            {
               return makeXmlExpr(IS_XMLPI, $_[4], NULL, lappend($_[6]), $_[0]->YYLLoc($_[1], 1));
            }
         | XMLROOT '(' a_expr ',' xml_root_version opt_xml_root_standalone ')'
            {
               return makeXmlExpr(IS_XMLROOT, NULL, NIL,
                            lappend($_[3], $_[5], $_[6]), $_[0]->YYLLoc($_[1], 1));
            }
         | XMLSERIALIZE '(' document_or_content a_expr AS SimpleTypename ')'
            {
               return SQL::Translator::Statement::XMLSerialize->new(
                  xmloption => $_[3],
                  expr      => $_[4],
                  typeName  => $_[6],
                  location  => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

/*
 * SQL/XML support
 */
xml_root_version: VERSION a_expr
            { $_[2] }
         | VERSION NO VALUE
            { makeNullAConst(-1) }
      ;

opt_xml_root_standalone: ',' STANDALONE YES
            { makeIntConst(XML_STANDALONE_YES, -1) }
         | ',' STANDALONE NO
            { makeIntConst(XML_STANDALONE_NO, -1) }
         | ',' STANDALONE NO VALUE
            { makeIntConst(XML_STANDALONE_NO_VALUE, -1) }
         | /*EMPTY*/
            { makeIntConst(XML_STANDALONE_OMITTED, -1) }
      ;

xml_attributes: XMLATTRIBUTES '(' xml_attribute_list ')'   { $_[3] }
      ;

xml_attribute_list:   xml_attribute_el               { lappend($_[1]) }
         | xml_attribute_list ',' xml_attribute_el   { lappend($_[1], $_[3]) }
      ;

xml_attribute_el: a_expr AS ColLabel
            {
               return SQL::Translator::Statement::ResTarget->new(
                  name        => $_[3],
                  indirection => NIL,
                  val         => $_[1],
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | a_expr
            {
               return SQL::Translator::Statement::ResTarget->new(
                  name        => NULL,
                  indirection => NIL,
                  val         => $_[1],
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

document_or_content: DOCUMENT                  { XMLOPTION_DOCUMENT }
         | CONTENT                             { XMLOPTION_CONTENT  }
      ;

xml_whitespace_option: PRESERVE WHITESPACE     { TRUE  }
         | STRIP WHITESPACE                    { FALSE }
         | /*EMPTY*/                           { FALSE }
      ;

/* We allow several variants for SQL and other compatibility. */
xmlexists_argument:
         PASSING c_expr
            {
               return $_[2];
            }
         | PASSING c_expr BY REF
            {
               return $_[2];
            }
         | PASSING BY REF c_expr
            {
               return $_[4];
            }
         | PASSING BY REF c_expr BY REF
            {
               return $_[4];
            }
      ;


/*
 * Window Definitions
 */
window_clause:
         WINDOW window_definition_list         { $_[2] }
         | /*EMPTY*/                           { NULL }
      ;

window_definition_list:
         window_definition                  { lappend($_[1]) }
         | window_definition_list ',' window_definition
                                            { lappend($_[1], $_[3]) }
      ;

window_definition:
         ColId AS window_specification
            {
               $_[3]->name($_[1]);
               return $_[3];
            }
      ;

over_clause: OVER window_specification
            { $_[2] }
         | OVER ColId
            {
               return SQL::Translator::Statement::WindowDef->new(
                  name            => $_[2],
                  refname         => NULL,
                  partitionClause => NIL,
                  orderClause     => NIL,
                  frameOptions    => FRAMEOPTION_DEFAULTS,
                  startOffset     => NULL,
                  endOffset       => NULL,
                  location        => $_[0]->YYLLoc($_[2], 2),
               );
            }
         | /*EMPTY*/
            { NULL }
      ;

window_specification: '(' opt_existing_window_name opt_partition_clause
                  opt_sort_clause opt_frame_clause ')'
            {
               return SQL::Translator::Statement::WindowDef->new(
                  name            => NULL,
                  refname         => $_[2],
                  partitionClause => $_[3],
                  orderClause     => $_[4],
                  #* copy relevant fields of opt_frame_clause
                  frameOptions    => $_[5]->frameOptions,
                  startOffset     => $_[5]->startOffset,
                  endOffset       => $_[5]->endOffset,
                  location        => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

/*
 * If we see PARTITION, RANGE, or ROWS as the first token after the '('
 * of a window_specification, we want the assumption to be that there is
 * no existing_window_name; but those keywords are unreserved and so could
 * be ColIds.  We fix this by making them have the same precedence as IDENT
 * and giving the empty production here a slightly higher precedence, so
 * that the shift/reduce conflict is resolved in favor of reducing the rule.
 * These keywords are thus precluded from being an existing_window_name but
 * are not reserved for any other purpose.
 */
opt_existing_window_name: ColId                  { $_[1] }
         | /*EMPTY*/            %prec Op         { NULL }
      ;

opt_partition_clause: PARTITION BY expr_list     { $_[3] }
         | /*EMPTY*/                             { NULL }
      ;

/*
 * For frame clauses, we return a WindowDef, but only some fields are used:
 * frameOptions, startOffset, and endOffset.
 *
 * This is only a subset of the full SQL:2008 frame_clause grammar.
 * We don't support <window frame exclusion> yet.
 */
opt_frame_clause:
         RANGE frame_extent
            {
               WindowDef *n = $_[2];
               n->frameOptions |= FRAMEOPTION_NONDEFAULT | FRAMEOPTION_RANGE;
               if (n->frameOptions & (FRAMEOPTION_START_VALUE_PRECEDING |
                                 FRAMEOPTION_END_VALUE_PRECEDING))
                  $_[0]->ereport(ERROR,
                        ERRCODE_FEATURE_NOT_SUPPORTED,
                         "RANGE PRECEDING is only supported with UNBOUNDED",
                         $_[0]->YYLLoc($_[1], 1));
               if (n->frameOptions & (FRAMEOPTION_START_VALUE_FOLLOWING |
                                 FRAMEOPTION_END_VALUE_FOLLOWING))
                  $_[0]->ereport(ERROR,
                        ERRCODE_FEATURE_NOT_SUPPORTED,
                         "RANGE FOLLOWING is only supported with UNBOUNDED",
                         $_[0]->YYLLoc($_[1], 1));
               );
            }
         | ROWS frame_extent
            {
               $_[2]->frameOptions |= FRAMEOPTION_NONDEFAULT | FRAMEOPTION_ROWS;
               return $_[2];
            }
         | /*EMPTY*/
            {
               return SQL::Translator::Statement::WindowDef->new(
                  frameOptions => FRAMEOPTION_DEFAULTS,
                  startOffset  => NULL,
                  endOffset    => NULL,
               );
            }
      ;

frame_extent: frame_bound
            {
               #* reject invalid cases
               $_[0]->ereport(ERROR,
                     ERRCODE_WINDOWING_ERROR,
                      "Frame start cannot be UNBOUNDED FOLLOWING",
                      $_[0]->YYLLoc($_[1], 1))
                  if ($_[1]->frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING);
               $_[0]->ereport(ERROR,
                     ERRCODE_WINDOWING_ERROR,
                      "Frame starting from following row cannot end with current row",
                      $_[0]->YYLLoc($_[1], 1))
                  if ($_[1]->frameOptions & FRAMEOPTION_START_VALUE_FOLLOWING);
               $_[1]->frameOptions |= FRAMEOPTION_END_CURRENT_ROW;
               return $_[1];
            }
         | BETWEEN frame_bound AND frame_bound
            {
               my $n1 = $_[2];
               my $n2 = $_[4];
               #* form merged options
               my $frameOptions = $n1->frameOptions;
               #* shift converts START_ options to END_ options
               $frameOptions |= $n2->frameOptions << 1;
               $frameOptions |= FRAMEOPTION_BETWEEN;

               #* reject invalid cases
               $_[0]->ereport(ERROR,
                     ERRCODE_WINDOWING_ERROR,
                      "Frame start cannot be UNBOUNDED FOLLOWING",
                      $_[0]->YYLLoc($_[2], 2))
                  if ($frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING);
               $_[0]->ereport(ERROR,
                     ERRCODE_WINDOWING_ERROR,
                      "Frame end cannot be UNBOUNDED PRECEDING",
                      $_[0]->YYLLoc($_[4], 4))
                  if ($frameOptions & FRAMEOPTION_START_UNBOUNDED_PRECEDING);
               $_[0]->ereport(ERROR,
                     ERRCODE_WINDOWING_ERROR,
                      "Frame starting from current row cannot have preceding rows",
                      $_[0]->YYLLoc($_[4], 4))
                  if ($frameOptions & FRAMEOPTION_START_CURRENT_ROW && $frameOptions & FRAMEOPTION_END_VALUE_PRECEDING);
               $_[0]->ereport(ERROR,
                     ERRCODE_WINDOWING_ERROR,
                      "Frame starting from following row cannot have preceding rows",
                      $_[0]->YYLLoc($_[4], 4))
               if ($frameOptions & FRAMEOPTION_START_VALUE_FOLLOWING &&
                   $frameOptions & (FRAMEOPTION_END_VALUE_PRECEDING | FRAMEOPTION_END_CURRENT_ROW));

               $n1->frameOptions($frameOptions);
               $n1->endOffset( $n2->startOffset );
               return $n1;
            }
      ;

/*
 * This is used for both frame start and frame end, with output set up on
 * the assumption it's frame start; the frame_extent productions must reject
 * invalid cases.
 */
frame_bound:
         UNBOUNDED PRECEDING
            {
               return SQL::Translator::Statement::WindowDef->new(
                  frameOptions => FRAMEOPTION_START_UNBOUNDED_PRECEDING,
                  startOffset  => NULL,
                  endOffset    => NULL,
               );
            }
         | UNBOUNDED FOLLOWING
            {
               return SQL::Translator::Statement::WindowDef->new(
                  frameOptions => FRAMEOPTION_START_UNBOUNDED_FOLLOWING,
                  startOffset  => NULL,
                  endOffset    => NULL,
               );
            }
         | CURRENT ROW
            {
               return SQL::Translator::Statement::WindowDef->new(
                  frameOptions => FRAMEOPTION_START_CURRENT_ROW,
                  startOffset  => NULL,
                  endOffset    => NULL,
               );
            }
         | a_expr PRECEDING
            {
               return SQL::Translator::Statement::WindowDef->new(
                  frameOptions => FRAMEOPTION_START_VALUE_PRECEDING,
                  startOffset  => $_[1],
                  endOffset    => NULL,
               );
            }
         | a_expr FOLLOWING
            {
               return SQL::Translator::Statement::WindowDef->new(
                  frameOptions => FRAMEOPTION_START_VALUE_FOLLOWING,
                  startOffset  => $_[1],
                  endOffset    => NULL,
               );
            }
      ;


/*
 * Supporting nonterminals for expressions.
 */

/* Explicit row production.
 *
 * SQL99 allows an optional ROW keyword, so we can now do single-element rows
 * without conflicting with the parenthesized a_expr production.  Without the
 * ROW keyword, there must be more than one a_expr inside the parens.
 */
row:       ROW '(' expr_list ')'         { $_[3] }
         | ROW '(' ')'                   { NULL }
         | '(' expr_list ',' a_expr ')'  { lappend($_[2], $_[4]) }
      ;

sub_type:  ANY                           { ANY_SUBLINK }
         | SOME                          { ANY_SUBLINK }
         | ALL                           { ALL_SUBLINK }
      ;

all_Op:    Op                            { $_[1] }
         | MathOp                        { $_[1] }
      ;

MathOp:    '+'                           { "+" }
         | '-'                           { "-" }
         | '*'                           { "*" }
         | '/'                           { "/" }
         | '%'                           { "%" }
         | '^'                           { "^" }
         | '<'                           { "<" }
         | '>'                           { ">" }
         | '='                           { "=" }
      ;

qual_Op:   Op
               { lappend(makeString($_[1])) }
         | OPERATOR '(' any_operator ')'
               { $_[3] }
      ;

qual_all_Op:
         all_Op
               { lappend(makeString($_[1])) }
         | OPERATOR '(' any_operator ')'
               { $_[3] }
      ;

subquery_Op:
         all_Op
               { lappend(makeString($_[1])) }
         | OPERATOR '(' any_operator ')'
               { $_[3] }
         | LIKE
               { lappend(makeString("~~")) }
         | NOT LIKE
               { lappend(makeString("!~~")) }
         | ILIKE
               { lappend(makeString("~~*")) }
         | NOT ILIKE
               { lappend(makeString("!~~*")) }
/* cannot put SIMILAR TO here, because SIMILAR TO is a hack.
 * the regular expression is preprocessed by a function (similar_escape),
 * and the ~ operator for posix regular expressions is used.
 *        x SIMILAR TO y     ->    x ~ similar_escape(y)
 * this transformation is made on the fly by the parser upwards.
 * however the SubLink structure which handles any/some/all stuff
 * is not ready for such a thing.
 */
         ;

expr_list:   a_expr
            {
               return lappend($_[1]);
            }
         | expr_list ',' a_expr
            {
               return lappend($_[1], $_[3]);
            }
      ;

/* function arguments can have names */
func_arg_list:  func_arg_expr
            {
               return lappend($_[1]);
            }
         | func_arg_list ',' func_arg_expr
            {
               return lappend($_[1], $_[3]);
            }
      ;

func_arg_expr:  a_expr
            {
               return $_[1];
            }
         | param_name COLON_EQUALS a_expr
            {
               return SQL::Translator::Statement::NamedArgExpr->new(
                  name      => $_[1],
                  arg       => $_[3],
                  argnumber => -1,      #* until determined
                  location  => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

type_list:   Typename                        { lappend($_[1]) }
         | type_list ',' Typename            { lappend($_[1], $_[3]) }
      ;

array_expr: '[' expr_list ']'
            {
               return makeAArrayExpr($_[2], $_[0]->YYLLoc($_[1], 1));
            }
         | '[' array_expr_list ']'
            {
               return makeAArrayExpr($_[2], $_[0]->YYLLoc($_[1], 1));
            }
         | '[' ']'
            {
               return makeAArrayExpr(NIL, $_[0]->YYLLoc($_[1], 1));
            }
      ;

array_expr_list: array_expr                    { lappend($_[1]) }
         | array_expr_list ',' array_expr      { lappend($_[1], $_[3]) }
      ;


extract_list:
         extract_arg FROM a_expr
            {
               return lappend(makeStringConst($_[1], $_[0]->YYLLoc($_[1], 1)), $_[3]);
            }
         | /*EMPTY*/                        { NULL }
      ;

/* Allow delimited string Sconst in extract_arg as an SQL extension.
 * - thomas 2001-04-12
 */
extract_arg:
         IDENT                           { $_[1]    }
         | YEAR                          { "year"   }
         | MONTH                         { "month"  }
         | DAY                           { "day"    }
         | HOUR                          { "hour"   }
         | MINUTE                        { "minute" }
         | SECOND                        { "second" }
         | Sconst                        { $_[1]    }
      ;

/* OVERLAY() arguments
 * SQL99 defines the OVERLAY() function:
 * o overlay(text placing text from int for int)
 * o overlay(text placing text from int)
 * and similarly for binary strings
 */
overlay_list:
         a_expr overlay_placing substr_from substr_for
            {
               return lappend($_[1], $_[2], $_[3], $_[4]);
            }
         | a_expr overlay_placing substr_from
            {
               return lappend($_[1], $_[2], $_[3]);
            }
      ;

overlay_placing:
         PLACING a_expr
            { $_[2] }
      ;

/* position_list uses b_expr not a_expr to avoid conflict with general IN */

position_list:
         b_expr IN b_expr                  { lappend($_[3], $_[1]) }
         | /*EMPTY*/                       { NULL }
      ;

/* SUBSTRING() arguments
 * SQL9x defines a specific syntax for arguments to SUBSTRING():
 * o substring(text from int for int)
 * o substring(text from int) get entire string from starting point "int"
 * o substring(text for int) get first "int" characters of string
 * o substring(text from pattern) get entire string matching pattern
 * o substring(text from pattern for escape) same with specified escape char
 * We also want to support generic substring functions which accept
 * the usual generic list of arguments. So we will accept both styles
 * here, and convert the SQL9x style to the generic list for further
 * processing. - thomas 2000-11-28
 */
substr_list:
         a_expr substr_from substr_for
            {
               return lappend($_[1], $_[2], $_[3]);
            }
         | a_expr substr_for substr_from
            {
               /* not legal per SQL99, but might as well allow it */
               return lappend($_[1], $_[3], $_[2]);
            }
         | a_expr substr_from
            {
               return lappend($_[1], $_[2]);
            }
         | a_expr substr_for
            {
               /*
                * Since there are no cases where this syntax allows
                * a textual FOR value, we forcibly cast the argument
                * to int4.  The possible matches in pg_proc are
                * substring(text,int4) and substring(text,text),
                * and we don't want the parser to choose the latter,
                * which it is likely to do if the second argument
                * is unknown or doesn't have an implicit cast to int4.
                */
               return lappend($_[1], makeIntConst(1, -1),
                           makeTypeCast($_[2],
                                     SystemTypeName("int4"), -1));
            }
         | expr_list
            {
               return $_[1];
            }
         | /*EMPTY*/
            { NULL }
      ;

substr_from:
         FROM a_expr                          { $_[2] }
      ;

substr_for: FOR a_expr                        { $_[2] }
      ;

trim_list:   a_expr FROM expr_list            { lappend($_[3], $_[1]) }
         | FROM expr_list                     { $_[2] }
         | expr_list                          { $_[1] }
      ;

in_expr:   select_with_parens
            {
               return SQL::Translator::Statement::SubLink->new(
                  subselect => $_[1],
                  #* other fields will be filled later
               );
            }
         | '(' expr_list ')'                  { $_[2] }
      ;

/*
 * Define SQL92-style case clause.
 * - Full specification
 *   CASE WHEN a = b THEN c ... ELSE d END
 * - Implicit argument
 *   CASE a WHEN b THEN c ... ELSE d END
 */
case_expr:   CASE case_arg when_clause_list case_default END
            {
               return SQL::Translator::Statement::CaseExpr->new(
                  casetype  => InvalidOid,  #* not analyzed yet
                  arg       => $_[2],
                  args      => $_[3],
                  defresult => $_[4],
                  location  => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

when_clause_list:
         /* There must be at least one */
           when_clause                          { lappend($_[1]) }
         | when_clause_list when_clause         { lappend($_[1], $_[2]) }
      ;

when_clause:
         WHEN a_expr THEN a_expr
            {
               return SQL::Translator::Statement::CaseWhen->new(
                  expr     => $_[2],
                  result   => $_[4],
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

case_default:
         ELSE a_expr                        { $_[2] }
         | /*EMPTY*/                        { NULL  }
      ;

case_arg:   a_expr                          { $_[1] }
         | /*EMPTY*/                        { NULL  }
      ;

columnref:   ColId
            {
               return makeColumnRef($_[1], NIL, $_[0]->YYLLoc($_[1], 1));
            }
         | ColId indirection
            {
               return makeColumnRef($_[1], $_[2], $_[0]->YYLLoc($_[1], 1));
            }
      ;

indirection_el:
         '.' attr_name
            {
               return makeString($_[2]);
            }
         | '.' '*'
            {
               return makeNode(A_Star);
            }
         | '[' a_expr ']'
            {
               A_Indices *ai = makeNode(A_Indices);
               ai->lidx = NULL;
               ai->uidx = $_[2];
               return ai;
            }
         | '[' a_expr ':' a_expr ']'
            {
               A_Indices *ai = makeNode(A_Indices);
               ai->lidx = $_[2];
               ai->uidx = $_[4];
               return ai;
            }
      ;

indirection:
           indirection_el                      { lappend($_[1]) }
         | indirection indirection_el          { lappend($_[1], $_[2]) }
      ;

opt_indirection:
         /*EMPTY*/                             { NULL }
         | opt_indirection indirection_el      { lappend($_[1], $_[2]) }
      ;

opt_asymmetric: ASYMMETRIC
         | /*EMPTY*/
      ;

/*
 * The SQL spec defines "contextually typed value expressions" and
 * "contextually typed row value constructors", which for our purposes
 * are the same as "a_expr" and "row" except that DEFAULT can appear at
 * the top level.
 */

ctext_expr:
         a_expr               {  $_[1] }
         | DEFAULT
            {
               return SQL::Translator::Statement::SetToDefault->new(
                  location => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;

ctext_expr_list:
           ctext_expr                          { lappend($_[1]) }
         | ctext_expr_list ',' ctext_expr      { lappend($_[1], $_[3]) }
      ;

/*
 * We should allow ROW '(' ctext_expr_list ')' too, but that seems to require
 * making VALUES a fully reserved word, which will probably break more apps
 * than allowing the noise-word is worth.
 */
ctext_row: '(' ctext_expr_list ')'               { $_[2] }
      ;


/*****************************************************************************
 *
 *   target list for SELECT
 *
 *****************************************************************************/

target_list:
           target_el                        { lappend($_[1]) }
         | target_list ',' target_el        { lappend($_[1], $_[3]) }
      ;

target_el:   a_expr AS ColLabel
            {
               return SQL::Translator::Statement::ResTarget->new(
                  name        => $_[3],
                  indirection => NIL,
                  val         => $_[1],
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
         /*
          * We support omitting AS only for column labels that aren't
          * any known keyword.  There is an ambiguity against postfix
          * operators: is "a ! b" an infix expression, or a postfix
          * expression and a column label?  We prefer to resolve this
          * as an infix expression, which we accomplish by assigning
          * IDENT a precedence higher than POSTFIXOP.
          */
         | a_expr IDENT
            {
               return SQL::Translator::Statement::ResTarget->new(
                  name        => $_[2],
                  indirection => NIL,
                  val         => $_[1],
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | a_expr
            {
               return SQL::Translator::Statement::ResTarget->new(
                  name        => NULL,
                  indirection => NIL,
                  val         => $_[1],
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
         | '*'
            {
               return SQL::Translator::Statement::ResTarget->new(
                  name        => NULL,
                  indirection => NIL,
                  val         => SQL::Translator::Statement::Column::Reference->new(
                     fields   => lappend(makeNode(A_Star)),
                     location => $_[0]->YYLLoc($_[1], 1),
                  ),
                  location    => $_[0]->YYLLoc($_[1], 1),
               );
            }
      ;


/*****************************************************************************
 *
 *   Names and constants
 *
 *****************************************************************************/

qualified_name_list:
           qualified_name                            { lappend($_[1]) }
         | qualified_name_list ',' qualified_name    { lappend($_[1], $_[3]) }
      ;

/*
 * The production for a qualified relation name has to exactly match the
 * production for a qualified func_name, because in a FROM clause we cannot
 * tell which we are parsing until we see what comes after it ('(' for a
 * func_name, something else for a relation). Therefore we allow 'indirection'
 * which may contain subscripts, and reject that case in the C code.
 */
qualified_name:
         ColId
            {
               return makeRangeVar(NULL, $_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | ColId indirection
            {
               check_qualified_name($_[2]);
               my $n = makeRangeVar(NULL, NULL, $_[0]->YYLLoc($_[1], 1));
               for (scalar @{$_[2]}) {
                  when (1) {
                     $n->catalogname(NULL);
                     $n->schemaname ($_[1]);
                     $n->relname    ($_[2]->[0]);
                  }
                  when (2) {
                     $n->catalogname($_[1]);
                     $n->schemaname ($_[2]->[0]);
                     $n->relname    ($_[2]->[1]);
                  }
                  default {
                     $_[0]->ereport(ERROR, ERRCODE_SYNTAX_ERROR,
                        sprintf("improper qualified name (too many dotted names): %s", NameListToString(lcons(makeString($_[1]), $_[2]))),
                        $_[0]->YYLLoc($_[1], 1));
                  }
               }
               return $n;
            }
      ;

name_list:   name
               { lappend(makeString($_[1])) }
         | name_list ',' name
               { lappend($_[1], makeString($_[3])) }
      ;


name:       ColId                           { $_[1] };

database_name:
            ColId                           { $_[1] };

access_method:
            ColId                           { $_[1] };

attr_name:  ColLabel                        { $_[1] };

index_name: ColId                           { $_[1] };

file_name:  Sconst                          { $_[1] };

/*
 * The production for a qualified func_name has to exactly match the
 * production for a qualified columnref, because we cannot tell which we
 * are parsing until we see what comes after it ('(' or Sconst for a func_name,
 * anything else for a columnref).  Therefore we allow 'indirection' which
 * may contain subscripts, and reject that case in the C code.  (If we
 * ever implement SQL99-like methods, such syntax may actually become legal!)
 */
func_name:   type_function_name
               { lappend(makeString($_[1])) }
         | ColId indirection
               {
                  return $_[0]->check_func_name(lcons(makeString($_[1]), $_[2]));
               }
      ;


/*
 * Constants
 */
AexprConst: Iconst
            {
               return makeIntConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | FCONST
            {
               return makeFloatConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | Sconst
            {
               return makeStringConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | BCONST
            {
               return makeBitStringConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | XCONST
            {
               /* This is a bit constant per SQL99:
                * Without Feature F511, "BIT data type",
                * a <general literal> shall not be a
                * <bit string literal> or a <hex string literal>.
                */
               return makeBitStringConst($_[1], $_[0]->YYLLoc($_[1], 1));
            }
         | func_name Sconst
            {
               /* generic type 'literal' syntax */
               my $t = makeTypeNameFromNameList($_[1]);
               $t->location( $_[0]->YYLLoc($_[1], 1) );
               return makeStringConstCast($_[2], $_[0]->YYLLoc($_[2], 2), $t);
            }
         | func_name '(' func_arg_list ')' Sconst
            {
               /* generic syntax with a type modifier */
               my $t = makeTypeNameFromNameList($_[1]);

               /*
                * We must use func_arg_list in the production to avoid
                * reduce/reduce conflicts, but we don't actually wish
                * to allow NamedArgExpr in this context.
                */
               
               for (@{$_[3]}) {
                  if (blessed $_->[0] && $_->[0]->isa('SQL::Translator::Statement::NamedArgExpr')) {
                     $_[0]->ereport(ERROR,
                            ERRCODE_SYNTAX_ERROR,
                             "type modifier cannot have parameter name",
                             arg->location);
                  }
               }
               $t->typmods ($_[3]);
               $t->location( $_[0]->YYLLoc($_[1], 1) );
               return makeStringConstCast($_[5], $_[0]->YYLLoc($_[5], 5), $t);
            }
         | ConstTypename Sconst
            {
               return makeStringConstCast($_[2], $_[0]->YYLLoc($_[2], 2), $_[1]);
            }
         | ConstInterval Sconst opt_interval
            {
               $_[1]->typmods($_[3]);
               return makeStringConstCast($_[2], $_[0]->YYLLoc($_[2], 2), $_[1]);
            }
         | ConstInterval '(' Iconst ')' Sconst opt_interval
            {
               my $t = $_[1];
               if (defined $_[6]) {
                  if (@{$_[6]} != 1) {
                     $_[0]->ereport(ERROR,
                           ERRCODE_SYNTAX_ERROR,
                            "interval precision specified twice",
                            $_[0]->YYLLoc($_[1], 1));
                  }
                  $t->typmods = lappend( $_[6],                                 makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3)) );
               }
               else {
                  $t->typmods = lappend( makeIntConst(INTERVAL_FULL_RANGE, -1), makeIntConst($_[3], $_[0]->YYLLoc($_[3], 3)) );
               }
               return makeStringConstCast($_[5], $_[0]->YYLLoc($_[5], 5), $t);
            }
         | TRUE
            {
               return makeBoolAConst(TRUE, $_[0]->YYLLoc($_[1], 1));
            }
         | FALSE
            {
               return makeBoolAConst(FALSE, $_[0]->YYLLoc($_[1], 1));
            }
         | NULL
            {
               return makeNullAConst($_[0]->YYLLoc($_[1], 1));
            }
      ;

Iconst:      ICONST                           { $_[1] };
Sconst:      SCONST                           { $_[1] };
RoleId:      ColId                            { $_[1] };

SignedIconst: Iconst                          { $_[1] }
         | '+' Iconst                         { + $_[2] }
         | '-' Iconst                         { - $_[2] }
      ;

/*
 * Name classification hierarchy.
 *
 * IDENT is the lexeme returned by the lexer for identifiers that match
 * no known keyword.  In most cases, we can accept certain keywords as
 * names, not only IDENTs.   We prefer to accept as many such keywords
 * as possible to minimize the impact of "reserved words" on programmers.
 * So, we divide names into several possible classes.  The classification
 * is chosen in part to make keywords acceptable as names wherever possible.
 */

/* Column identifier --- names that can be column, table, etc names.
 */
ColId:     IDENT                            { $_[1] }
         | unreserved_keyword               { $_[1] }
         | col_name_keyword                 { $_[1] }
      ;

/* Type/function identifier --- names that can be type or function names.
 */
type_function_name:   IDENT                 { $_[1] }
         | unreserved_keyword               { $_[1] }
         | type_func_name_keyword           { $_[1] }
      ;

/* Column label --- allowed labels in "AS" clauses.
 * This presently includes *all* Postgres keywords.
 */
ColLabel:  IDENT                            { $_[1] }
         | unreserved_keyword               { $_[1] }
         | col_name_keyword                 { $_[1] }
         | type_func_name_keyword           { $_[1] }
         | reserved_keyword                 { $_[1] }
      ;


/*
 * Keyword category lists.  Generally, every keyword present in
 * the Postgres grammar should appear in exactly one of these lists.
 *
 * Put a new keyword into the first list that it can go into without causing
 * shift or reduce conflicts.  The earlier lists define "less reserved"
 * categories of keywords.
 *
 * Make sure that each keyword's category in kwlist.h matches where
 * it is listed here.  (Someday we may be able to generate these lists and
 * kwlist.h's table from a common master list.)
 */

/* "Unreserved" keywords --- available for use as any kind of name.
 */
unreserved_keyword:
           ABORT
         | ABSOLUTE
         | ACCESS
         | ACTION
         | ADD
         | ADMIN
         | AFTER
         | AGGREGATE
         | ALSO
         | ALTER
         | ALWAYS
         | ASSERTION
         | ASSIGNMENT
         | AT
         | ATTRIBUTE
         | BACKWARD
         | BEFORE
         | BEGIN
         | BY
         | CACHE
         | CALLED
         | CASCADE
         | CASCADED
         | CATALOG
         | CHAIN
         | CHARACTERISTICS
         | CHECKPOINT
         | CLASS
         | CLOSE
         | CLUSTER
         | COLLATION
         | COMMENT
         | COMMENTS
         | COMMIT
         | COMMITTED
         | CONFIGURATION
         | CONNECTION
         | CONSTRAINTS
         | CONTENT
         | CONTINUE
         | CONVERSION
         | COPY
         | COST
         | CSV
         | CURRENT
         | CURSOR
         | CYCLE
         | DATA
         | DATABASE
         | DAY
         | DEALLOCATE
         | DECLARE
         | DEFAULTS
         | DEFERRED
         | DEFINER
         | DELETE
         | DELIMITER
         | DELIMITERS
         | DICTIONARY
         | DISABLE
         | DISCARD
         | DOCUMENT
         | DOMAIN
         | DOUBLE
         | DROP
         | EACH
         | ENABLE
         | ENCODING
         | ENCRYPTED
         | ENUM
         | ESCAPE
         | EXCLUDE
         | EXCLUDING
         | EXCLUSIVE
         | EXECUTE
         | EXPLAIN
         | EXTENSION
         | EXTERNAL
         | FAMILY
         | FIRST
         | FOLLOWING
         | FORCE
         | FORWARD
         | FUNCTION
         | FUNCTIONS
         | GLOBAL
         | GRANTED
         | HANDLER
         | HEADER
         | HOLD
         | HOUR
         | IDENTITY
         | IF
         | IMMEDIATE
         | IMMUTABLE
         | IMPLICIT
         | INCLUDING
         | INCREMENT
         | INDEX
         | INDEXES
         | INHERIT
         | INHERITS
         | INLINE
         | INPUT
         | INSENSITIVE
         | INSERT
         | INSTEAD
         | INVOKER
         | ISOLATION
         | KEY
         | LABEL
         | LANGUAGE
         | LARGE
         | LAST
         | LC_COLLATE
         | LC_CTYPE
         | LEVEL
         | LISTEN
         | LOAD
         | LOCAL
         | LOCATION
         | LOCK
         | MAPPING
         | MATCH
         | MAXVALUE
         | MINUTE
         | MINVALUE
         | MODE
         | MONTH
         | MOVE
         | NAME
         | NAMES
         | NEXT
         | NO
         | NOTHING
         | NOTIFY
         | NOWAIT
         | NULLS
         | OBJECT
         | OF
         | OFF
         | OIDS
         | OPERATOR
         | OPTION
         | OPTIONS
         | OWNED
         | OWNER
         | PARSER
         | PARTIAL
         | PARTITION
         | PASSING
         | PASSWORD
         | PLANS
         | PRECEDING
         | PREPARE
         | PREPARED
         | PRESERVE
         | PRIOR
         | PRIVILEGES
         | PROCEDURAL
         | PROCEDURE
         | QUOTE
         | RANGE
         | READ
         | REASSIGN
         | RECHECK
         | RECURSIVE
         | REF
         | REINDEX
         | RELATIVE
         | RELEASE
         | RENAME
         | REPEATABLE
         | REPLACE
         | REPLICA
         | RESET
         | RESTART
         | RESTRICT
         | RETURNS
         | REVOKE
         | ROLE
         | ROLLBACK
         | ROWS
         | RULE
         | SAVEPOINT
         | SCHEMA
         | SCROLL
         | SEARCH
         | SECOND
         | SECURITY
         | SEQUENCE
         | SEQUENCES
         | SERIALIZABLE
         | SERVER
         | SESSION
         | SET
         | SHARE
         | SHOW
         | SIMPLE
         | STABLE
         | STANDALONE
         | START
         | STATEMENT
         | STATISTICS
         | STDIN
         | STDOUT
         | STORAGE
         | STRICT
         | STRIP
         | SYSID
         | SYSTEM
         | TABLES
         | TABLESPACE
         | TEMP
         | TEMPLATE
         | TEMPORARY
         | TEXT
         | TRANSACTION
         | TRIGGER
         | TRUNCATE
         | TRUSTED
         | TYPE
         | UNBOUNDED
         | UNCOMMITTED
         | UNENCRYPTED
         | UNKNOWN
         | UNLISTEN
         | UNLOGGED
         | UNTIL
         | UPDATE
         | VACUUM
         | VALID
         | VALIDATE
         | VALIDATOR
         | VALUE
         | VARYING
         | VERSION
         | VIEW
         | VOLATILE
         | WHITESPACE
         | WITHOUT
         | WORK
         | WRAPPER
         | WRITE
         | XML
         | YEAR
         | YES
         | ZONE
      ;

/* Column identifier --- keywords that can be column, table, etc names.
 *
 * Many of these keywords will in fact be recognized as type or function
 * names too; but they have special productions for the purpose, and so
 * can't be treated as "generic" type or function names.
 *
 * The type names appearing here are not usable as function names
 * because they can be followed by '(' in typename productions, which
 * looks too much like a function call for an LR(1) parser.
 */
col_name_keyword:
           BETWEEN
         | BIGINT
         | BIT
         | BOOLEAN
         | CHAR
         | CHARACTER
         | COALESCE
         | DEC
         | DECIMAL
         | EXISTS
         | EXTRACT
         | FLOAT
         | GREATEST
         | INOUT
         | INT
         | INTEGER
         | INTERVAL
         | LEAST
         | NATIONAL
         | NCHAR
         | NONE
         | NULLIF
         | NUMERIC
         | OUT
         | OVERLAY
         | POSITION
         | PRECISION
         | REAL
         | ROW
         | SETOF
         | SMALLINT
         | SUBSTRING
         | TIME
         | TIMESTAMP
         | TREAT
         | TRIM
         | VALUES
         | VARCHAR
         | XMLATTRIBUTES
         | XMLCONCAT
         | XMLELEMENT
         | XMLEXISTS
         | XMLFOREST
         | XMLPARSE
         | XMLPI
         | XMLROOT
         | XMLSERIALIZE
      ;

/* Type/function identifier --- keywords that can be type or function names.
 *
 * Most of these are keywords that are used as operators in expressions;
 * in general such keywords can't be column names because they would be
 * ambiguous with variables, but they are unambiguous as function identifiers.
 *
 * Do not include POSITION, SUBSTRING, etc here since they have explicit
 * productions in a_expr to support the goofy SQL9x argument syntax.
 * - thomas 2000-11-28
 */
type_func_name_keyword:
           AUTHORIZATION
         | BINARY
         | CONCURRENTLY
         | CROSS
         | CURRENT_SCHEMA
         | FREEZE
         | FULL
         | ILIKE
         | INNER
         | IS
         | ISNULL
         | JOIN
         | LEFT
         | LIKE
         | NATURAL
         | NOTNULL
         | OUTER
         | OVER
         | OVERLAPS
         | RIGHT
         | SIMILAR
         | VERBOSE
      ;

/* Reserved keyword --- these keywords are usable only as a ColLabel.
 *
 * Keywords appear here if they could not be distinguished from variable,
 * type, or function names in some contexts.  Don't put things here unless
 * forced to.
 */
reserved_keyword:
           ALL
         | ANALYSE
         | ANALYZE
         | AND
         | ANY
         | ARRAY
         | AS
         | ASC
         | ASYMMETRIC
         | BOTH
         | CASE
         | CAST
         | CHECK
         | COLLATE
         | COLUMN
         | CONSTRAINT
         | CREATE
         | CURRENT_CATALOG
         | CURRENT_DATE
         | CURRENT_ROLE
         | CURRENT_TIME
         | CURRENT_TIMESTAMP
         | CURRENT_USER
         | DEFAULT
         | DEFERRABLE
         | DESC
         | DISTINCT
         | DO
         | ELSE
         | END
         | EXCEPT
         | FALSE
         | FETCH
         | FOR
         | FOREIGN
         | FROM
         | GRANT
         | GROUP
         | HAVING
         | IN
         | INITIALLY
         | INTERSECT
         | INTO
         | LEADING
         | LIMIT
         | LOCALTIME
         | LOCALTIMESTAMP
         | NOT
         | NULL
         | OFFSET
         | ON
         | ONLY
         | OR
         | ORDER
         | PLACING
         | PRIMARY
         | REFERENCES
         | RETURNING
         | SELECT
         | SESSION_USER
         | SOME
         | SYMMETRIC
         | TABLE
         | THEN
         | TO
         | TRAILING
         | TRUE
         | UNION
         | UNIQUE
         | USER
         | USING
         | VARIADIC
         | WHEN
         | WHERE
         | WINDOW
         | WITH
      ;

%%

sub lappend { 
   [ map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ ];
}

#* Process result of ConstraintAttributeSpec, and set appropriate bool flags
#* in the output command node.  Pass NULL for any flags the particular
#* command doesn't support.
#* static void
#* processCASbits(int cas_bits, int location, const char *constrType,
#*             bool *deferrable, bool *initdeferred, bool *not_valid,
#*             core_yyscan_t yyscanner)
sub processCASbits {
   my ($cas_bits, $location, $constr_type, $n,
       $can_deferrable, $can_initdeferred, $can_not_valid) = @_;

   if (cas_bits & (CAS_DEFERRABLE | CAS_INITIALLY_DEFERRED)) {
      $can_deferrable
         or $_[0]->ereport(ERROR,
               ERRCODE_FEATURE_NOT_SUPPORTED,
                /* translator: %s is CHECK, UNIQUE, or similar */
                sprintf("%s constraints cannot be marked DEFERRABLE",
                     constrType),
                location);
      $n->deferrable(true);
   }

   if (cas_bits & CAS_INITIALLY_DEFERRED) {
      $can_initdeferred
         or $_[0]->ereport(ERROR,
               ERRCODE_FEATURE_NOT_SUPPORTED,
                /* translator: %s is CHECK, UNIQUE, or similar */
                sprintf("%s constraints cannot be marked DEFERRABLE",
                     constrType),
                location);
      $n->initdeferred(true);
   }

   if (cas_bits & CAS_NOT_VALID) {
      $can_not_valid
         or $_[0]->ereport(ERROR,
               ERRCODE_FEATURE_NOT_SUPPORTED,
                /* translator: %s is CHECK, UNIQUE, or similar */
                sprintf("%s constraints cannot be marked NOT VALID",
                     constrType),
                location);
      $n->not_valid(true);
   }
}

use constant {
   TRUE  => 1,
   FALSE => 0,
   NIL   => undef,
   NULL  => undef,
}

__PACKAGE__->lexer(\&_Lexer);


